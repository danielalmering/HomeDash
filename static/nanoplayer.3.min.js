/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @license
	 * nanoStream Player
	 * Copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	 * http://www.nanocosmos.de
	 * sales@nanocosmos.de
	 *
	 * LEGAL NOTICE:
	 * This material is subject to the terms and conditions defined in
	 * separate license conditions ('LICENSE.txt')
	 * All information contained herein is, and remains the property
	 * of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	 * contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	 * or copyright law. Dissemination of this information or reproduction of this material
	 * is strictly forbidden unless prior written permission is obtained from nanocosmos.
	 * All modifications will remain property of nanocosmos.
	 */

	// nanoPlayer.js

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(2),
	        __webpack_require__(3),
	        __webpack_require__(98),
	        __webpack_require__(132),
	        __webpack_require__(96),
	        __webpack_require__(17),
	        __webpack_require__(6),
	        __webpack_require__(11)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (version, NanoCore, NanoView, BintuSource, propagator, configHandler, EventEmitter, BrowserInfo) {
	        'use strict';

	        var coreEvents = NanoCore.events;
	        var states = NanoCore.states;
	        var coreEmptyConfig = NanoCore.emptyConfig;
	        var pauseReasons = NanoCore.pauseReasons;
	        var capabilities = NanoCore.capabilities;

	        var viewEvents = NanoView.events;
	        var viewEmptyConfig = NanoView.emptyConfig;

	        var bintuEmptyConfig = BintuSource.emptyConfig;

	        /**
	         * @file NanoPlayer 3.10.0
	         * @author nanocosmos IT GmbH
	         * @copyright (c) 2017 nanocosmos IT GmbH. All rights reserved.
	         * @version 3.10.0
	         * @see [Release History]{@link https://demo.nanocosmos.de/nanoplayer/docs/nanoplayer3/release-history.html}
	         */

	        /**
	         * @class NanoPlayer
	         * @classdesc NanoPlayer Public API Class 3.10.0
	         * @version 3.10.0
	         * @constructor
	         * @description The constructor. The source can be loaded via script tag, AMD (requirejs) or CommonJS
	         * @param {string} playerDivId - The div element the player will be embedded into.
	         * @example {@lang xml}
	         * <script type="text/javascript" src="nanoplayer.3.min.js"></script>
	         * <script type="text/javascript">
	         *     var player;
	         *     document.addEventListener('DOMContentLoaded', function () {
	         *         player = new NanoPlayer('playerDiv');
	         *     });
	         * </script>
	         * @example {@lang xml}
	         * <script type="text/javascript" src="require.js"></script>
	         * <script type="text/javascript">
	         *     var player;
	         *     requirejs.config({
	         *         paths: {
	         *             // loads the player ...
	         *             // for a local copy of the minified player use a relative path e.g. 'js/nanoplayer.3.min'
	         *             // if 'baseUrl' is defined a local path have to be relative to the base path
	         *             nanoplayer: '//demo.nanocosmos.de/nanoplayer/api/nanoplayer.3.min.js'
	         *         },
	         *         waitSeconds: 20, // timeout for loading modules
	         *     });
	         *     require('nanoplayer', function() {
	         *         player = new NanoPlayer('playerDiv');
	         *     });
	         * </script>
	         */
	        function NanoPlayer (playerDivId) {
	            if (!(typeof playerDivId === 'string' || playerDivId instanceof String)) {
	                throw new Error('The param "playerDivId" must be of type "String"');
	            }

	            /**
	             * @alias version
	             * @memberOf NanoPlayer#
	             * @description The version of the player.
	             * @type {string}
	             */
	            this.version = version.NANOPLAYER;

	            console.log('NanoPlayer api version: ' + this.version);

	            /**
	             * @alias coreversion
	             * @memberOf NanoPlayer#
	             * @description The version of the core.
	             * @type {string}
	             */
	            this.coreversion = '';

	            /**
	             * @alias viewversion
	             * @memberOf NanoPlayer#
	             * @description The version of the view.
	             * @type {string}
	             */
	            this.viewversion = '';

	            /**
	             * @alias type
	             * @memberOf NanoPlayer#
	             * @description The type of the player.
	             * @type {string}
	             */
	            this.type = 'default';

	            /**
	             * @alias id
	             * @memberOf NanoPlayer#
	             * @description The unique id of the player.
	             * @type {string}
	             */
	            this.id = '';

	            this._playerDivId = playerDivId;

	            this._core = null;
	        }

	        var proto = (NanoPlayer.prototype = Object.create(EventEmitter.prototype));

	        /**
	         * @typedef {object} NanoPlayer~config
	         * @description The config object to pass as param for the 'setup' call.
	         * @see [NanoPlayer.setup]{@link NanoPlayer#setup}
	         * @property {object}  source - The object to configure the source to play, one of the following properties have to be set.
	         * @property {object}  [source.h5live] - The h5live object to configure the h5live connection.
	         * @property {object}  source.h5live.server - The h5live server object.
	         * @property {string}  [source.h5live.server.websocket] - The h5live websocket url.
	         * @property {string}  [source.h5live.server.progressive] - The h5live progressive download url.
	         * @property {string}  [source.h5live.server.hls] - The h5live hls url. Have to be set for playback on iOS 10 or higher. iOS 9 or lower is not supported.
	         * @property {string}  [source.h5live.token] - The h5live server token.
	         * @property {object}  [source.h5live.rtmp] - The rtmp playout object for h5live playback.
	         * @property {string}  source.h5live.rtmp.url - The rtmp playout url. Have to include the domain, port and application e.g. 'rtmp://example.com:80/live'.
	         * @property {string}  source.h5live.rtmp.streamname - The rtmp streamname.
	         * @property {object}  [source.h5live.security] - The h5live security object for h5live playback.
	         * @property {string}  source.h5live.security.token - The security service token.
	         * @property {string}  source.h5live.security.expires - The time the token expires (system time).
	         * @property {string}  source.h5live.security.options - The security options.
	         * @property {string}  source.h5live.security.tag - The custom tag to decrypt the token.
	         * @property {object}  [source.h5live.params] - The params object to pass custom query parameters over the connection. Parameters can be passed as key/value pairs.
	         * @property {object}  [source.bintu] - An bintu object to get sources.
	         * @property {string}  source.bintu.streamid - The bintu stream id.
	         * @property {string}  [source.bintu.apiurl="https://bintu.nanocosmos.de"] - The bintu api url.
	         * @property {string}  [source.hls] - An hls playout url as string.
	         * @property {object}  [playback] - The object to configure the playback.
	         * @property {boolean}  [playback.autoplay=true] - Enable/disable autoplay (default: true). <br><b>IMPORTANT</b>: Browsers (mostly mobile) with stricter autoplay policy only allow autoplay with muted audio or within a user interaction (tap, click etc.). To allow autoplay in this case set the 'muted' property to 'true'. Known browsers are: Safari 11 on Mac OS X and Safari 10/11 on iOS, Chrome on Android (desktop versions follow in early 2018). See our [<b>nanocosmos-blog</b>]{@link https://www.nanocosmos.de/blog/2018/03/autoplay-on-web-pages-with-h5live-player-for-ultra-low-latency-live-streams/} for more informations.
	         * @property {boolean}  [playback.muted=false] - Mute/unmute the player (default: false). <br><b>IMPORTANT</b>: Browsers (mostly mobile) with stricter autoplay policy only allow autoplay with muted audio. To allow autoplay set the 'muted' property to 'true'. See property 'autoplay' for more informations.
	         * @property {boolean}  [playback.metadata=false] - Enable/disable metadata (default: false).
	         * @property {string}  [playback.forceTech] - Force the player to use this tech - possible values: "h5live", "flash", "hls.native"
	         * @property {string}  [playback.flashplayer] - A absolute or relative path to the "nano.player.swf". If not set the player will be required from the base path.
	         * @property {string}  [playback.videoId] - An element id of a existing video tag that should be used for playback. No new element will be created and after destroy it will be kept.
	         * @property {boolean}  [playback.keepConnection=false] - If enabled the player will have always a connection to the h5live server.
	         * @property {object}  [playback.reconnect] - The reconnect object to configure the reconnect settings. See [errorcodes]{@link NanoPlayer~errorcode} for reconnect possibility.
	         * @property {number}  playback.reconnect.minDelay=2 - The minimum time to reconnect in seconds. The lowest possible value is 1 sec.
	         * @property {number}  playback.reconnect.maxDelay=10 - The maximum time to reconnect in seconds.
	         * @property {number}  playback.reconnect.delaySteps=10 - This number of steps till the maximum delay should reached.
	         * @property {number}  playback.reconnect.maxRetries=10 - The maximum count of reconnect tries. If set to zero no reconnect will be done.
	         * @property {object}  [style] - The object to configure the style of the player.
	         * @property {string}  [style.width='640px'] - The width of the player in pixels (e.g 320px) or percentage (80%) (height or aspectratio have to be set too). Use 'auto' to keep the parents size (height and aspectratio have no effect).
	         * @property {string}  [style.height] - The height of the player in pixels (e.g 240px) or percentage (45%)  (width or aspectratio have to be set too). Use 'auto' to keep the parents size (width and aspectratio have no effect).
	         * @property {string}  [style.aspectratio='16/9'] - The aspectratio of the player (e.g. 16/9) (width or height have to be set too).
	         * @property {boolean}  [style.controls=true] - Show/hide video controls.
	         * @property {boolean}  [style.interactive=true] - Enable/disable interactivity of the player on click/touch.
	         * @property {boolean}  [style.view=true] - Enable/disable view port handling/animations.
	         * @property {string}  [style.scaling='letterbox'] - Set's the display mode for the video inside the player - possible values: "letterbox", "fill", "crop", "original", "resize".
	         * @property {boolean}  [style.keepFrame=false] - If true the last played frame will be displayed after a pause.
	         * @property {boolean}  [style.displayAudioOnly=true] - If true a audio symbol will be shown in case of a stream with audio only.
	         * @property {boolean}  [style.audioPlayer=false] - If true a player will be created as an audio player without video functionality. Controls can be enabled/disabled. The size can be customized via 'width' and 'height'. Default is 640px * 51px.
	         * @property {object}  [events] - The object to set handlers to the player events.
	         * @property {function} [events.onReady] - Fires if the player is ready to play after successful setup.
	         * @property {function} [events.onPlay] - Fires if playout is started.
	         * @property {function} [events.onPause] - Fires if playout is paused.
	         * @property {function} [events.onLoading] - Fires if playout was stopped or player is ready after setup and tries to play.
	         * @property {function} [events.onStartBuffering] - Fires if playout is started but no media is available.
	         * @property {function} [events.onStopBuffering] - Fires if playout resumes after buffering.
	         * @property {function} [events.onError] - Fires if any kind of error occures.
	         * @property {function} [events.onStats] - Fires if the player has measured statistics.
	         * @property {function} [events.onMetaData] - Fires if the player has received metadata.
	         * @property {function} [events.onMuted] - Fires if the player is muted.
	         * @property {function} [events.onUnmuted] - Fires if the player is unmuted.
	         * @property {function} [events.onVolumeChange] - Fires if the player's volume has changed.
	         * @property {function} [events.onStreamInfo] - Fires if stream info is available.
	         * @property {function} [events.onWarning] - Fires if something is not as expected, but functionality works.
	         * @property {object}  [tweaks] - The object to tweak the player (only h5live).
	         * @property {object} [tweaks.buffer] - The bufffer object.
	         * @property {number} tweaks.buffer.min - The minimum time to buffer.
	         * @property {number} tweaks.buffer.start - The buffer time when the playout starts.
	         * @property {number} tweaks.buffer.target - The target buffer time.
	         * @property {number} tweaks.buffer.limit - The buffer time limit before increase play speed.
	         * @property {number} tweaks.buffer.max - The maximum time to buffer.
	         * @property {object} [tweaks.bufferDynamic] - The bufffer dynamic object.
	         * @property {number} tweaks.bufferDynamic.offsetThreshold - The threshold time between two bufferings in seconds. If the measured value is lower, the buffer will be increased by offsetStep.
	         * @property {number} tweaks.bufferDynamic.offsetStep - The step to increase in seconds. Also the step to decrease in cooldown.
	         * @property {number} tweaks.bufferDynamic.cooldownTime - The time to check stable playback. If stable playback is detected, the buffer values will be decreased till original buffer values are reached.
	         * @example
	         * var config = {
	         *     source: {
	         *         bintu: {
	         *             streamid: 'q23rf2tzw3h6754iretmft7irt'
	         *         }
	         *     }
	         * }
	         * @example
	         * var config = {
	         *     source: {
	         *         h5live: {
	         *             server: {
	         *                 websocket: 'wss://h5live.nanocosmos.de/h5live/stream',
	         *                 hls: 'https://h5live.nanocosmos.de/h5live/http/playlist.m3u8'
	         *             },
	         *             rtmp: {
	         *                 url: 'rtmp://example.nanocosmos.de:80/live',
	         *                 streamname: 'h5liveStream'
	         *             },
	         *             security: {
	         *                 token: 'awe456b367g4e6rm8f56hbe6gd8f5m8df6n8idf6tf8mfd68ndi',
	         *                 expires: '1519819200',
	         *                 options: '15',
	         *                 tag: 'anyTag'
	         *             }
	         *         }
	         *     },
	         *     playback: {
	         *         autoplay: false,
	         *         metadata: true,
	         *         keepConnection: true,
	         *         reconnect: {
	         *             minDelay: 2.5,
	         *             maxDelay: 12.5,
	         *             delaySteps: 6,
	         *             maxRetries: 20
	         *         }
	         *     },
	         *     events: {
	         *         onWarning: function (e) {
	         *             console.log(e);
	         *         }
	         *     },
	         *     style: {
	         *         width: '1280px',
	         *         height: '720px'
	         *     },
	         *     tweaks: {
	         *         buffer: {
	         *             min: 0.2,
	         *             start: 0.5,
	         *             max: 8.0,
	         *             target: 1.2,
	         *             limit: 1.7
	         *         },
	         *         bufferDynamic: {
	         *             offsetThreshold: 2,
	         *             offsetStep: 0.5,
	         *             cooldownTime: 10
	         *         }
	         *     }
	         * }
	         * @example
	         * var config = {
	         *     source: {
	         *         h5live: {
	         *             server: {
	         *                 websocket: 'wss://h5live.nanocosmos.de/h5live/stream',
	         *                 hls: 'https://h5live.nanocosmos.de/h5live/http/playlist.m3u8'
	         *             },
	         *             params: {
	         *                 url: 'rtmp://example.nanocosmos.de:80/live',
	         *                 stream: 'h5liveStream',
	         *                 custom_key: 'custom_value'
	         *             }
	         *         }
	         *     },
	         *     playback: {
	         *         autoplay: false,
	         *         videoId: 'myVideoTagId'
	         *     },
	         *     events: {
	         *         onStats: function (e) {
	         *             console.log(e);
	         *         }
	         *     },
	         *     style: {
	         *        view: false
	         *     }
	         * }
	         * @example
	         * var config = {
	         *     source: {
	         *         h5live: {
	         *             server: {
	         *                 websocket: 'wss://h5live.nanocosmos.de/h5live/stream',
	         *                 hls: 'https://h5live.nanocosmos.de/h5live/http/playlist.m3u8'
	         *             },
	         *             rtmp: {
	         *                 url: 'rtmp://example.nanocosmos.de:80/live',
	         *                 streamname: 'gwr23t4q3g3'
	         *             }
	         *         },
	         *         token: "{\"type\":\"token1\",\"key\":\"exampleToken\"}"
	         *     },
	         *     playback: {
	         *         autoplay: true,
	         *         muted: true
	         *     },
	         *     events: {
	         *         onReady: function (e) {
	         *             console.log('player ready with ' + JSON.stringify(e));
	         *         },
	         *         onPlay: function (e) {
	         *             console.log('playing');
	         *         },
	         *         onPause: function (e) {
	         *             console.log('pause');
	         *             if (e.data.reason !== 'normal') {
	         *                 alert('Paused with reason: ' + e.data.reason);
	         *             }
	         *         },
	         *         onError: function (e) {
	         *             try {
	         *                 var err = JSON.stringify(e);
	         *                 if (err === '{}') {
	         *                     err = e.message;
	         *                 }
	         *                 e = err;
	         *             } catch (err) { }
	         *             console.log(e);
	         *             alert(e);
	         *         },
	         *         onMetaData: function (e) {
	         *             console.log(e);
	         *         },
	         *         onStats: function (e) {
	         *             console.log(e);
	         *         },
	         *         onStreamInfo: function (e) {
	         *             console.log(e);
	         *         },
	         *     },
	         *     style: {
	         *         width: '1280px',
	         *         aspectratio: '16/9',
	         *         controls: false,
	         *         scaling: 'crop'
	         *     }
	         * }
	         */

	        /**
	         * @event NanoPlayer~onReady
	         * @description The ready event to pass in the 'config.events' object at the setup call. Fires if the player is ready to play after successful setup.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {config} data.config - The config object.
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onReady = function (event) {
	         *     comnsole.log('Ready: ' + JSON.stringify(event.data.config));
	         * }
	         * config.events.onReady = onReady;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onPlay
	         * @description The play event to pass in the 'config.events' object at the setup call. Fires if playout is started.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object (empty).
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onPlay = function (event) {
	         *     comnsole.log('Playing');
	         * };
	         * config.events.onPlay = onPlay;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onPause
	         * @description The pause event to pass in the 'config.events' object at the setup call. Fires if playout is paused.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {NanoPlayer~pausereason} data.reason - The reason of pausing.
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onPause = function (event) {
	         *     comnsole.log('Pause');
	         *     if (event.data.reason !== 'normal') {
	         *          alert('Paused with reason: ' + event.data.reason);
	         *     }
	         * };
	         * config.events.onPause = onPause;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onLoading
	         * @description The load event to pass in the 'config.events' object at the setup call. Fires if playout was stopped or player is ready after setup and tries to play.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {number} data.connectDelay - The time in milliseconds to wait for initializing the connection to the server to get the stream. Is zero if no reconnect is imminent.
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onLoading = function (event) {
	         *     comnsole.log('Loading with delay of ' + event.data.connectDelay + ' milliseconds');
	         * };
	         * config.events.onLoading = onLoading;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onStartBuffering
	         * @description The start buffering event to pass in the 'config.events' object at the setup call. Fires if playout is started but no media is available.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object (empty).
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onStartBuffering = function (event) {
	         *     comnsole.log('Buffering');
	         * };
	         * config.events.onStartBuffering = onStartBuffering;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onStopBuffering
	         * @description The stop buffering event to pass in the 'config.events' object at the setup call. Fires if playout resumes after buffering.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object (empty).
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onStopBuffering = function (event) {
	         *     comnsole.log('Resume');
	         * };
	         * config.events.onStopBuffering = onStopBuffering;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onError
	         * @description The error event to pass in the 'config.events' object at the setup call. Fires if any kind of error occures.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {NanoPlayer~errorcode} data.code - The error code.
	         * @property {string} data.message - The error cause as human readable string.
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onError = function (event) {
	         *     alert('Error: ' + event.data.code + ' ' + event.data.message);
	         * };
	         * config.events.onError = onError;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @typedef {number} NanoPlayer~errorcode
	         * @description The possible error codes in a onError event.
	         * @see [onError]{@link NanoPlayer~event:onError}
	         * @property {PlayerError} 1000-1999
	         * @property 1000-1999.1001 - No rtmp url set.
	         * @property 1000-1999.1002 - No server set.
	         * @property 1000-1999.1003 - Could not play because player has not been configured.
	         * @property 1000-1999.1004 - Could not pause because player was not in playing state before.
	         * @property 1000-1999.1005 - Playback must be initialized by user gesture.
	         * @property 1000-1999.1006 - Buffer config is invalid.
	         * @property 1000-1999.1007 - Playback suspended by external reason.
	         * @property 1000-1999.1008 - Playback error.
	         *
	         * @property {StreamError} 2000-2999
	         * @property 2000-2999.2001 - The requested stream can not be found.
	         * @property 2000-2999.2002 - No media available.
	         * @property 2000-2999.2011 - Received metadata with wrong index.
	         * @property 2000-2999.2012 - Received metadata with invalid json string.
	         * @property 2000-2999.2013 - Received metadata but no start index.
	         * @property 2000-2999.2014 - Received metadata with start index but currently process another.
	         *
	         * @property {MediaError} 3000-3999
	         * @property 3000-3999.3001 - A fetching process of the media aborted by user.
	         * @property 3000-3999.3002 - An error occurred when downloading media.
	         * @property 3000-3999.3003 - An error occurred when decoding media.
	         * @property 3000-3999.3004 - The received audio/video is not supported.
	         *
	         * @property {NetworkError} 4000-4999
	         * @property {General} 4000-4999.4000-4099
	         * @property 4000-4999.4000-4099.4001 - Could not establish connection. Maybe wrong protocol or path.
	         * @property 4000-4999.4000-4099.4002 - Connection error.
	         * @property 4000-4999.4000-4099.4003 - Maximum number of reconnection tries reached.
	         * @property 4000-4999.4000-4099.4004 - Reconnection configuration invalid.
	         * @property {WebSocket} 4000-4999.4100-4199
	         * @property 4000-4999.4100-4199.4101 - An endpoint is "going away", such as a server going down or a browser having navigated away from a page.
	         * @property 4000-4999.4100-4199.4102 - An endpoint is terminating the connection due to a protocol error. Reconnect possible.
	         * @property 4000-4999.4100-4199.4103 - An endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message). Reconnect possible.
	         * @property 4000-4999.4100-4199.4104 - Reserved. The specific meaning might be defined in the future.
	         * @property 4000-4999.4100-4199.4105 - No status code was actually present. Reconnect possible.
	         * @property 4000-4999.4100-4199.4106 - Maybe no network, wrong url or server down. Reconnect possible.
	         * @property 4000-4999.4100-4199.4107 - An endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [http://tools.ietf.org/html/rfc3629] data within a text message). Reconnect possible.
	         * @property 4000-4999.4100-4199.4108 - An endpoint is terminating the connection because it has received a message that "violates its policy". This reason is given either if there is no other sutible reason, or if there is a need to hide specific details about the policy. Reconnect possible.
	         * @property 4000-4999.4100-4199.4109 - An endpoint is terminating the connection because it has received a message that is too big for it to process. Reconnect possible.
	         * @property 4000-4999.4100-4199.4110 - An endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake.
	         * @property 4000-4999.4100-4199.4111 - A server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request. Reconnect possible.
	         * @property 4000-4999.4100-4199.4115 - The connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified). Reconnect possible.
	         * @property {Http} 4000-4999.4400-4499
	         * @property 4000-4999.4400-4499.4400 - Bad request. Maybe stream parameters are missing or malformed.
	         * @property 4000-4999.4400-4499.4403 - Access denied. The authentication token is missing or invalid.
	         * @property 4000-4999.4400-4499.4500 - The connection has been rejected due an internal server error. Reconnect possible.
	         * @property 4000-4999.4400-4499.4503 - The requested service is currently unavailable. Reconnect possible.
	         * @property {Security} 4000-4999.4900-4999
	         * @property 4000-4999.4900-4999.4900 - The security service has been rejected due an internal server error.
	         * @property 4000-4999.4900-4999.4901 - The security service denied access. The authentication token is invalid.
	         * @property 4000-4999.4900-4999.4903 - The security service denied access. The url is expired or a token parameter is missing (expires, token, or options).
	         * @property 4000-4999.4900-4999.4904 - The security service can not be found.
	         */

	        /**
	         * @event NanoPlayer~onStats
	         * @description The stats event to pass in the 'config.events' object at the setup call. Fires if the player has measured statistics.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {object} data.stats - The stats object.
	         * @property {number} data.stats.currentTime - The current time of the video.
	         * @property {object} data.stats.playout - The playout object.
	         * @property {number} data.stats.playout.start - The start play time of the video.
	         * @property {number} data.stats.playout.end - The end play time of the video.
	         * @property {object} data.stats.buffer - The buffer object.
	         * @property {number} data.stats.buffer.start - The start buffer time of the video.
	         * @property {number} data.stats.buffer.end - The end buffer time of the video.
	         * @property {object} data.stats.buffer.delay - The delay buffer object.
	         * @property {number} data.stats.buffer.delay.current - The current delay time.
	         * @property {number} data.stats.buffer.delay.avg - The average delay time over the last second.
	         * @property {number} data.stats.buffer.delay.min - The minimum delay time over the last second.
	         * @property {number} data.stats.buffer.delay.max - The maximum delay time over the last second.
	         * @property {object} data.stats.bitrate - The bitrate object.
	         * @property {number} data.stats.bitrate.current - The current bitrate in Bit/s. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number} data.stats.bitrate.avg - The average bitrate in Bit/s over the last 10 seconds. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number} data.stats.bitrate.min - The minimum bitrate in Bit/s over the last 10 seconds. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number} data.stats.bitrate.max - The maximum bitrate in Bit/s over the last 10 seconds. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {object} data.stats.framerate - The framerate object.
	         * @property {number} data.stats.framerate.current - The current network framerate. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number} data.stats.framerate.avg - The average network framerate over the last 10 seconds. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number} data.stats.framerate.min - The minimum network framerate over the last 10 seconds. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number} data.stats.framerate.max - The maximum network framerate over the last 10 seconds. Is '0' if not available. NOT AVAILABLE FOR IOS.
	         * @property {object} data.stats.quality - The video playback quality object.
	         * @property {number} data.stats.quality.corruptedVideoFrames - The total number of corrupted video frames. ONLY AVAILABLE FOR FIREFOX.
	         * @property {number} data.stats.quality.corruptedVideoFramesCurrent - The number of corrupted video frames within the last second. ONLY AVAILABLE FOR FIREFOX.
	         * @property {number} data.stats.quality.creationTime -The time in miliseconds since the start of the navigation and the creation of the video element. ONLY AVAILABLE FOR FIREFOX.
	         * @property {number} data.stats.quality.droppedVideoFrames - The total number of dropped video frames. ONLY AVAILABLE FOR FIREFOX.
	         * @property {number} data.stats.quality.droppedVideoFramesCurrent - The number of dropped video frames within the last second. ONLY AVAILABLE FOR FIREFOX.
	         * @property {number} data.stats.quality.totalVideoFrames - The total number of created and dropped video frames since creation of the video element. ONLY AVAILABLE FOR FIREFOX.
	         * @example
	         * // player instance of NanoPlayer
	         * var onStats = function (event) {
	         *     comnsole.log('Stats: ' + JSON.stringify(event.data.stats));
	         * };
	         * config.events.onStats = onStats;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onMetaData
	         * @description The metadata event to pass in the 'config.events' object at the setup call. The config param 'playback.metadata' have to be set to true. Fires if the player receives metadata.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {string} data.handlerName - The name of the metadata handler.
	         * @property {*} data.message - The metadata message.
	         * @property {number} data.streamTime - The timestamp of the metadata in relation to currentTime.
	         * @example
	         * // player instance of NanoPlayer
	         * var onMetaData = function (event) {
	         *     comnsole.log('MetaData: ' + JSON.stringify(event.data));
	         * };
	         * config.events.onMetaData = onMetaData;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onMuted
	         * @description The muted event to pass in the 'config.events' object at the setup call. Fires if the player is muted.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {number} data.volume - The current volume in a range from 0.0 to 1.0.
	         * @example
	         * // player instance of NanoPlayer
	         * var onMuted = function (event) {
	         *     comnsole.log('Muted with volume: ' + event.data.volume);
	         * };
	         * config.events.onMetaData = onMetaData;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onUnmuted
	         * @description The muted event to pass in the 'config.events' object at the setup call. Fires if the player is unmuted.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {number} data.volume - The current volume in a range from 0.0 to 1.0.
	         * @example
	         * // player instance of NanoPlayer
	         * var onUnmuted = function (event) {
	         *     comnsole.log('Unmuted with volume: ' + event.data.volume);
	         * };
	         * config.events.onMetaData = onMetaData;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onVolumeChange
	         * @description The muted event to pass in the 'config.events' object at the setup call. Fires if the player's volume has changed.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {number} data.volume - The current volume in a range from 0.0 to 1.0.
	         * @example
	         * // player instance of NanoPlayer
	         * var onVolumeChange = function (event) {
	         *     comnsole.log('Volume: ' + event.data.volume);
	         * };
	         * config.events.onMetaData = onMetaData;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onStreamInfo
	         * @description The stream info event to pass in the 'config.events' object at the setup call. Fires if informations about a stream is available right before playback starts.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {object} data.streamInfo - The stream info object.
	         * @property {string} data.streamInfo.url - The complete stream url with parameters.
	         * @property {boolean} data.streamInfo.haveAudio - Indicates if the stream contains audio.
	         * @property {boolean} data.streamInfo.haveVideo - Indicates if the stream contains video.
	         * @property {object|null} data.streamInfo.audioInfo - The audio info object. Is 'null' if the stream contains no audio.
	         * @property {number|null} data.streamInfo.audioInfo.bitsPerSample - The bits per sample. Is 'null' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number|null} data.streamInfo.audioInfo.sampleRate - The audio sample rate. Is 'null' if not available. NOT AVAILABLE FOR IOS.
	         * @property {number|null} data.streamInfo.audioInfo.channels - The number of audio channels. Is 'null' if not available. NOT AVAILABLE FOR IOS.
	         * @property {object|null} data.streamInfo.videoInfo - The stream info object. Is 'null' if the stream contains no video.
	         * @property {number|null} data.streamInfo.videoInfo.width - The width of the video. Is 'null' if not available.
	         * @property {number|null} data.streamInfo.videoInfo.height - The height of the video. Is 'null' if not available.
	         * @property {number|null} data.streamInfo.videoInfo.frameRate - The video frame rate. Is 'null' if not available. NOT AVAILABLE FOR IOS.
	         * @example
	         * // player instance of NanoPlayer
	         * var onStreamInfo = function (event) {
	         *     comnsole.log('StreamInfo: ' + JSON.stringify(event.data.streamInfo));
	         * };
	         * config.events.onStreamInfo = onStreamInfo;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoPlayer~onWarning
	         * @description The error event to pass in the 'config.events' object at the setup call. Fires if something is not as expected, but functionality works.
	         * @see [config]{@link NanoPlayer~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {string} id - The unique id of the player instance.
	         * @property {string} version - The version of the player.
	         * @property {object} data - The data object.
	         * @property {string} data.message - The warning as human readable string.
	         * @property {NanoPlayer~state} state - The player state.
	         * @example
	         * // player instance of NanoPlayer
	         * var onWarning = function (event) {
	         *     console.log('Warning: ' + event.data.message);
	         * };
	         * config.events.onWarning = onWarning;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @alias setup
	         * @memberOf NanoPlayer#
	         * @description Initializes the player with a given config object.
	         * @param {config} config - The config object for the player including sources, events, styles.
	         * @returns {Promise.<config|error>}
	         * @example
	         * // player instance of NanoPlayer
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */
	        proto.setup = function (config) {
	            var self = this;
	            var setupConfig = {};
	            configHandler.extend(config, setupConfig);
	            return BintuSource.setup(setupConfig).then(function (_config) {
	                return self._setup(_config);
	            });
	        };

	        /**
	         * @alias destroy
	         * @memberOf NanoPlayer#
	         * @description Cleans up the player and removes all nested elements from the container div.
	         * @example
	         * // player instance of NanoPlayer
	         * player.destroy();
	         * player.setup(config);
	         */
	        proto.destroy = function () {
	            this.removeAllListeners();
	            this._view && this._view.destroy();
	            this._core && this._core.destroy();
	        };

	        proto._setup = function (setupConfig) {
	            var self = this;
	            var bintuConfig = bintuEmptyConfig.create();
	            var coreConfig = coreEmptyConfig.create();
	            var viewConfig = viewEmptyConfig.create();
	            configHandler.merge(setupConfig, bintuConfig);
	            configHandler.clean(bintuConfig);
	            configHandler.merge(setupConfig, coreConfig);
	            configHandler.clean(coreConfig);
	            configHandler.merge(setupConfig, viewConfig);
	            configHandler.clean(viewConfig);
	            this._bintuConfig = bintuConfig;
	            this._coreConfig = coreConfig;
	            this._viewConfig = viewConfig;
	            return new Promise(function (resolve, reject) {
	                if (viewConfig.style && viewConfig.style.view) {
	                    self._initView(viewConfig);
	                    self._viewPropagator = propagator.create(self._view, NanoPlayer.viewEvents, self);
	                }
	                try {
	                    var core = new NanoCore(self._playerDivId);
	                    self._corePropagator = propagator.create(core, NanoPlayer.coreEvents, self);
	                    self._setPublicListeners(coreConfig.events, self);
	                    self._connectLayers();
	                    core.setup(coreConfig).then(
	                        function (successConfig) {
	                            self.coreversion = core.version;
	                            self.type = core.type;
	                            self.id = core.id;
	                            self._core = core;
	                            if (viewConfig.style && viewConfig.style.view) {
	                                self._view.postSetup(core._realPlayer._mediaElementId);
	                            }
	                            configHandler.extend(bintuConfig, successConfig);
	                            configHandler.extend(viewConfig, successConfig);
	                            configHandler.clean(successConfig);
	                            resolve(successConfig);
	                        },
	                        function (error) {
	                            if (viewConfig.style && viewConfig.style.view) {
	                                self._view.handleView(NanoPlayer.states.UNINITIALIZED);
	                            }
	                            reject(error);
	                        }
	                    );
	                }
	                catch (err) {
	                    if (viewConfig.style && viewConfig.style.view) {
	                        self._view.handleView(NanoPlayer.states.UNINITIALIZED);
	                    }
	                    reject(err);
	                }
	            });
	        };

	        proto._initView = function (viewConfig) {
	            this._view = new NanoView();
	            this._view.version = this.version;
	            this.viewversion = this._view.version;
	            this._view.setBaseValues(this._playerDivId);
	            this._view.baseSetup(viewConfig);
	        };

	        proto._setPublicListeners = function (events, target) {
	            for (var key in events) {
	                if (events.hasOwnProperty(key) && typeof events[key] === 'function') {
	                    var event = key.replace('on', '');
	                    var handler = events[key];
	                    target.on(event, handler);
	                    delete events[key];
	                }
	            }
	        };

	        proto._removeAllListeners = function () {
	            this.removeAllListeners();
	        };

	        proto._connectLayers = function () {
	            var coreExcludes = [NanoPlayer.coreEvents.MEDIA];

	            function iterate (events, excludes, source, listener) {
	                for (var key in events) {
	                    if (events.hasOwnProperty(key) && excludes.indexOf(events[key]) === -1) {
	                        source.on(events[key], listener.bind(this));
	                    }
	                }
	            }

	            iterate(NanoPlayer.coreEvents, coreExcludes, this, this._onCoreEvent.bind(this));
	            iterate(NanoPlayer.viewEvents, [], this, this._onViewEvent.bind(this));
	        };

	        proto._onCoreEvent = function (event) {
	            if (this._view) {
	                if (event.name === NanoPlayer.coreEvents.STATS) {
	                    this._view.handleStats(event.data.stats);
	                    return;
	                }
	                if (event.name === NanoPlayer.coreEvents.STATE_CHANGE) {
	                    this._view.update(event);
	                }
	                if (event.name === NanoPlayer.coreEvents.STREAM_INFO) {
	                    this._view.handleStreamInfo(event);
	                }
	                if (event.name === NanoPlayer.coreEvents.MUTE || event.name === NanoPlayer.coreEvents.UNMUTE) {
	                    this._view.handleMute(event.name === NanoPlayer.coreEvents.MUTE);
	                }
	                if (event.name === NanoPlayer.coreEvents.VOLUME_CHANGE) {
	                    this._view.handleVolume(event.data.volume);
	                }
	                if (event.name === NanoPlayer.coreEvents.METADATA) {
	                    this._view.handleMetaData(event);
	                }
	            }
	        };

	        proto._onViewEvent = function (event) {
	            if (event.name === NanoPlayer.viewEvents.PLAY) {
	                this._core.play();
	            }
	            else if (event.name === NanoPlayer.viewEvents.PAUSE) {
	                this._core.pause();
	            }
	            if (event.name === NanoPlayer.viewEvents.MUTE) {
	                this._core.mute();
	            }
	            else if (event.name === NanoPlayer.viewEvents.UNMUTE) {
	                this._core.unmute();
	            }
	            if (event.name === NanoPlayer.viewEvents.VOLUME_CHANGE) {
	                this._core.setVolume(event.data.volume);
	            }
	        };

	        proto._callMethod = function () {
	            if (!this._core) {
	                throw new Error('Player not initialized!');
	            }
	            this._core[arguments[0]].apply(this._core, Array.prototype.slice.call(arguments, 1));
	        };

	        /**
	         * @alias play
	         * @memberOf NanoPlayer#
	         * @description Plays the player.
	         * @example
	         * // player instance of NanoPlayer
	         * player.play();
	         */
	        proto.play = function () {
	            this._callMethod('play');
	        };

	        /**
	         * @alias pause
	         * @memberOf NanoPlayer#
	         * @description Pauses the player.
	         * @example
	         * // player instance of NanoPlayer
	         * player.pause();
	         */
	        proto.pause = function () {
	            this._callMethod('pause');
	        };

	        /**
	         * @alias mute
	         * @memberOf NanoPlayer#
	         * @description Mutes the player.
	         * @example
	         * // player instance of NanoPlayer
	         * player.mute();
	         */
	        proto.mute = function () {
	            this._callMethod('mute');
	        };

	        /**
	         * @alias unmute
	         * @memberOf NanoPlayer#
	         * @description Unmutes the player.
	         * @example
	         * // player instance of NanoPlayer
	         * player.unmute();
	         */
	        proto.unmute = function () {
	            this._callMethod('unmute');
	        };

	        /**
	         * @alias setVolume
	         * @memberOf NanoPlayer#
	         * @description Sets the volume of the player.
	         * @param {number} volume - The volume to set in a range from 0.0 to 1.0.
	         * @example
	         * // player instance of NanoPlayer
	         * player.setVolume(0.3);
	         */
	        proto.setVolume = function (volume) {
	            this._callMethod('setVolume', volume);
	        };

	        /**
	         * @alias state
	         * @typedef {number} NanoPlayer~state
	         * @description The state of the player.
	         * @see [Events]{@link NanoPlayer~event:onError}
	         * @property 1 - UNINITIALIZED
	         * @property 2 - IDLE
	         * @property 3 - READY
	         * @property 4 - LOADING
	         * @property 5 - PLAYING
	         * @property 6 - PAUSED
	         * @property 7 - BUFFERING
	         * @property 8 - UNKNOWN
	         * @property 9 - PLAYBACK_NOT_STARTED
	         * @property 10 - PLAYBACK_SUSPENDED
	         * @property 11 - PAUSING
	         * @property 12 - PLAYBACK_ERROR
	         * @property 13 - RECONNECTION_IMMINENT
	         * @property 14 - CONNECTION_ERROR
	         */
	        NanoPlayer.states = states;
	        NanoPlayer.coreEvents = coreEvents;
	        NanoPlayer.viewEvents = viewEvents;

	        /**
	         * @typedef {string} NanoPlayer~pausereason
	         * @description The possible pause reason in a onPause event.
	         * @see [onPause]{@link NanoPlayer~event:onPause}
	         * @property normal Paused by user.
	         * @property buffer Paused by buffer timeout. The stream was stopped or the buffer was underrunned.
	         * @property connectionclose Paused by network connection close.
	         * @property servernotfound Paused because of the h5live server was not found.
	         * @property streamnotfound Paused by loading timeout. The stream could not found.
	         * @property interactionrequired Paused because auto playback is denied. Can happen especially on mobile.
	         * @property playbacksuspended Paused because the playback was suspended by an external reason.
	         * @property playbackerror Paused because the playback had an error.
	         * @property reconnectionimminent Paused because the connection was closed by an external reason and a reconnect will be prepared.
	         *
	         */
	        NanoPlayer.pauseReasons = pauseReasons;

	        /**
	         * @alias capabilities
	         * @memberOf NanoPlayer#
	         * @constant
	         * @type {string[]}
	         * @description The supported tech names of the player.
	         */
	        NanoPlayer.capabilities = capabilities;

	        /**
	         * @alias performance marks
	         * @description This marks will be set via 'performance.mark()' and are related to a websocket connection only. Marks can be read with performance.getEntriesByName(name) that returns an array with objects. The object has the properties 'entryType=mark', 'name' and 'startTime'. The middle part of the name string is the element id of the player container. Not supported on Safari 11 OSX and iOS.
	         * @property {string} nano.[playerDivId].connecting Will be set if the websocket connect is started.
	         * @property {string} nano.[playerDivId].connected Will be set if the websocket connection is established.
	         * @property {string} nano.[playerDivId].disconnected Will be set if the websocket connection is closed.
	         * @property {string} nano.[playerDivId].resuming Will be set if the websocket connection is established and a play command will be send (keepConnection only).
	         * @property {string} nano.[playerDivId].firstFragmentReceived Will be set if the first fragment is received over the websocket connection.
	         * @property {string} nano.[playerDivId].firstFrameRendered  Will be set if the first frame is received over the websocket connection.
	         */

	        window.NanoPlayer = NanoPlayer;

	        return NanoPlayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	    Auto-generated on build, do not modify!

	    General info file for builds.
	    Compatible to grunt AND requirejs.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){
	    return { NANOPLAYER: '3.10.0' };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @license
	 * nanoStream Player Core
	 * Copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	 * http://www.nanocosmos.de
	 * sales@nanocosmos.de
	 *
	 * LEGAL NOTICE:
	 * This material is subject to the terms and conditions defined in
	 * separate license conditions ('LICENSE.txt')
	 * All information contained herein is, and remains the property
	 * of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	 * contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	 * or copyright law. Dissemination of this information or reproduction of this material
	 * is strictly forbidden unless prior written permission is obtained from nanocosmos.
	 * All modifications will remain property of nanocosmos.
	 */

	// NanoCore.js

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(5),
	        __webpack_require__(10),
	        __webpack_require__(7),
	        __webpack_require__(8),
	        __webpack_require__(9),
	        __webpack_require__(4),
	        __webpack_require__(15),
	        __webpack_require__(96),
	        __webpack_require__(19),
	        __webpack_require__(97)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        IPlayer,
	        playerFactory,
	        emptyConfig,
	        events,
	        states,
	        pauseReason,
	        version,
	        propagator,
	        configValidator,
	        Promise
	    ) {
	        'use strict';

	        /**
	         * @file NanoCore Class (requirejs module).
	         * @author nanocosmos IT GmbH
	         * @copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	         */

	        /**
	         * @class NanoCore
	         * @classdesc NanoCore Public API Class (requirejs module)
	         * @constructor
	         * @description The constructor, 'requirejs' have to be used to load the class.
	         * @param {string} playerDivId - The div element the player will be embedded into.
	         */
	        function NanoCore (playerDivId) {
	            configValidator.validatePlayerDivId(playerDivId);

	            /**
	             * @alias version
	             * @memberOf NanoCore#
	             * @description The version of the player.
	             * @type {string}
	             */
	            this.version = version.CORE;

	            console.debug('NanoCore api version: ' + this.version);

	            /**
	             * @alias type
	             * @memberOf NanoCore#
	             * @description The type of the player.
	             * @type {string}
	             */
	            this.type = 'default';

	            this._playerDivId = playerDivId;

	            this._dummyPlayer = new IPlayer(this._playerDivId);
	            this._realPlayer = this._dummyPlayer;
	        }

	        var proto = (NanoCore.prototype = Object.create(IPlayer.prototype));

	        /**
	         * @typedef {object} NanoCore~config
	         * @description The config object to pass as param for the 'setup' call.
	         * @see [NanoCore.setup]{@link NanoCore#setup}
	         * @property {object}  source - The object to configure the source to play, one of the following properties have to be set.
	         * @property {string|NanoCore~rtmp}  [source.rtmp] - An complete rtmp playout url as string or object.
	         * @property {string}  [source.hls] - An hls playout url as string.
	         * @property {string}  [source.dash] - An dash playout url as string.
	         * @property {object}  [source.bintu] - An bintu object to get sources.
	         * @property {string}  source.bintu.streamid - The bintu stream id.
	         * @property {string}  [source.bintu.apiurl="https://bintu.nanocosmos.de"] - The bintu api url.
	         * @property {object}  [source.h5live] - The h5live object to configure the h5live connection.
	         * @property {object}  source.h5live.server - The h5live server object.
	         * @property {string}  [source.h5live.server.websocket] - The h5live websocket url.
	         * @property {string}  [source.h5live.server.progressive] - The h5live progressive download url.
	         * @property {string}  [source.h5live.server.hls] - The h5live hls url.
	         * @property {string}  [source.h5live.token] - The h5live security token.
	         * @property {string|rtmp}  [source.h5live.rtmp] - An complete rtmp playout url as string or object.
	         * @property {object}  [playback] - The object to configure the playback.
	         * @property {boolean}  [playback.autoplay=true] - Enable/disable autoplay (default: true).
	         * @property {boolean}  [playback.muted=false] - Mute/Unmute the player (default: false).
	         * @property {boolean}  [playback.metadata=false] - Enable/disable metadata (default: false).
	         * @property {NanoCore~preferredTech[]}  [playback.preferredTech] - Defines with tech should be preferred for playout.
	         * @property {string}  [playback.forceTech] - Force the player to use this tech - possible values: "flash", "h5live", "hls", "dash".
	         * @property {string}  [playback.flashplayer] - A absolute or relative path to the "nano.player.swf". If not set the player will be required from the base path.
	         * @property {string}  [style.cropMode='letterbox'] - Set's the display mode for the video inside the player - possible values: "letterbox", "fit", "crop", "original", "resize".
	         * @property {object}  [events] - The object to set handlers to the player events.
	         * @property {object}  [tweaks] - The object to tweak the player (only h5live).
	         * @property {object} [tweaks.buffer] - The bufffer object
	         * @property {number} tweaks.buffer.min - The minimum time to buffer
	         * @property {number} tweaks.buffer.start - The buffer time when the playout starts
	         * @property {number} tweaks.buffer.max - The maximum time to buffer
	         * @property {number} tweaks.buffer.target - The target buffer time
	         * @property {number} tweaks.buffer.limit - The buffer time limit before increase play speed
	         * @example
	         * var config = {
	         *     source: {
	         *         bintu: {
	         *             streamid: 'q23rf2tzw3h6754iretmft7irt'
	         *         }
	         *     }
	         * }
	         * @example
	         * var config = {
	         *     source: {
	         *         h5live: {
	         *             server: {
	         *                 websocket: 'wss://h5live.server.de:443/h5live/stream',
	         *             rtmp: {
	         *                 url: 'rtmp://example.nanocosmos.de:80/live',
	         *                 streamname: 'h5liveStream'
	         *             }
	         *         }
	         *     },
	         *     playback: {
	         *         autoplay: false,
	         *         metadata: true
	         *     },
	         *     events: {
	         *         onStats: function (e) {
	         *             console.log(e);
	         *         }
	         *     },
	         *     tweaks: {
	         *         buffer: {
	         *             min: 0.2,
	         *             start: 0.5,
	         *             max: 8.0,
	         *             target: 1.2,
	         *             limit: 1.7
	         *         }
	         *     }
	         * }
	         * @example
	         * var config = {
	         *     source: {
	         *         rtmp: 'rtmp://example.nanocosmos.de:80/live/gwr23t4q3g3',
	         *         hls: 'http://example.nanocosmos.de:8080/hls/gwr23t4q3g3/index.m3u8',
	         *         dash: 'http://example.nanocosmos.de:8080/dash/gwr23t4q3g3/index.mpd'
	         *     },
	         *     playback: {
	         *         autoplay: true,
	         *         muted: false,
	         *         preferredTech: [
	         *             {
	         *                 player: 'html5',
	         *                 streaming: 'dash'
	         *             }
	         *         ],
	         *         forceTech: 'hls'
	         *     },
	         *     events: {
	         *         onReady: function (e) {
	         *             console.log('player ready with ' + JSON.stringify(e));
	         *         },
	         *         onPlay: function (e) {
	         *             console.log('playing');
	         *         },
	         *         onPause: function (e) {
	         *             console.log('pause');
	         *         },
	         *         onError: function (e) {
	         *             try {
	         *                 var err = JSON.stringify(e);
	         *                 if (err === '{}') {
	         *                     err = e.message;
	         *                 }
	         *                 e = err;
	         *             } catch (err) { }
	         *             console.log(e);
	         *             alert(e);
	         *         },
	         *         onMetaData: function (e) {
	         *             console.log(e);
	         *         },
	         *         onStats: function (e) {
	         *             console.log(e);
	         *         }
	         *     }
	         * }
	         */

	        /**
	         * @typedef {object} NanoCore~preferredTech
	         * @description The object for 'preferredTech' in the config object.
	         * @see [config]{@link NanoCore~config}
	         * @property {string}  player - The type of player to use - possible values: "html5".
	         * @property {string}  streaming - The type of playout tech to use - possible values: "hls", "dash".
	         * @example
	         * {
	         *    "player": "html5",
	         *    "streaming": "hls"
	         * }
	         */

	        /**
	         * @typedef {object} NanoCore~rtmp
	         * @description The object for 'rtmp' in the config object.
	         * @see [config]{@link NanoCore~config}
	         * @property {string}  url - The server url.
	         * @property {string}  streamname - The stream name.
	         * @example
	         * {
	         *    "url": "bintu-stream.nanocosmos.de:80/live",
	         *    "streamname": "fres5t236z"
	         * }
	         */

	        /**
	         * @event NanoCore~onReady
	         * @description The ready event to pass in the 'config.events' object at the setup call. Fires if the player is ready to play after successful setup.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {config} data.config - The config object.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onReady = function (event) {
	         *     comnsole.log('Ready: ' + JSON.stringify(event.data.config));
	         * }
	         * config.events.onReady = onReady;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoCore~onPlay
	         * @description The play event to pass in the 'config.events' object at the setup call. Fires if playout is started.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onPlay = function (event) {
	         *     comnsole.log('Playing');
	         * };
	         * config.events.onPlay = onPlay;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoCore~onPause
	         * @description The pause event to pass in the 'config.events' object at the setup call. Fires if playout is paused.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {string} data.reason - The reason of pausing.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onPause = function (event) {
	         *     comnsole.log('Pause');
	         *     if (event.data.reason !== 'normal') {
	         *          alert('Paused with reason: ' + event.data.reason);
	         *     }
	         * };
	         * config.events.onPause = onPause;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoCore~onLoading
	         * @description The load event to pass in the 'config.events' object at the setup call. Fires if playout was stopped or player is ready after setup and tries to play.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onLoading = function (event) {
	         *     comnsole.log('Loading');
	         * };
	         * config.events.onLoading = onLoading;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoCore~onStartBuffering
	         * @description The start buffering event to pass in the 'config.events' object at the setup call. Fires if playout is started but no media is available.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onStartBuffering = function (event) {
	         *     comnsole.log('Buffering');
	         * };
	         * config.events.onStartBuffering = onStartBuffering;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoCore~onStopBuffering
	         * @description The stop buffering event to pass in the 'config.events' object at the setup call. Fires if playout resumes after buffering.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onStopBuffering = function (event) {
	         *     comnsole.log('Resume');
	         * };
	         * config.events.onStopBuffering = onStopBuffering;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @event NanoCore~onError
	         * @description The error event to pass in the 'config.events' object at the setup call. Fires if any kind of error occures.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {NanoCore~errorcode} data.code - The error code.
	         * @property {string} data.message - The error cause as human readable string.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onError = function (event) {
	         *     alert('Error: ' + event.data.code + ' ' + event.data.message);
	         * };
	         * config.events.onError = onError;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @typedef {number} NanoCore~errorcode
	         * @description The possible error codes in a onError event.
	         * @see [onError]{@link NanoCore~event:onError}
	         * @property {PlayerError}  1000-1999
	         * @property {number}  1000-1999.1001 - No rtmp url set.
	         * @property {number}  1000-1999.1002 - No server set.
	         * @property {number}  1000-1999.1003 - Could not play because player has not been configured.
	         * @property {number}  1000-1999.1004 - Could not pause because player was not in playing state before.
	         *
	         * @property {StreamError}  2000-2999
	         * @property {number}  2000-2999.2001 - The requested stream can not be found.
	         * @property {number}  2000-2999.2002 - No media available.
	         *
	         * @property {MediaError}  3000-3999
	         * @property {number}  3000-3999.3001 - A fetching process of the media aborted by user.
	         * @property {number}  3000-3999.3002 - An error occurred when downloading media.
	         * @property {number}  3000-3999.3003 - An error occurred when decoding media.
	         * @property {number}  3000-3999.3004 - The received audio/video is not supported.
	         *
	         * @property {NetworkError}  4000-4999
	         * @property {General}  4000-4999.4000-4099
	         * @property {number}  4000-4999.4000-4099.4001 - Could not establish connection. Maybe wrong protocol or path.
	         * @property {number}  4000-4999.4000-4099.4002 - Connection error.
	         * @property {WebSocket} 4000-4999.4100-4199
	         * @property {number}  4000-4999.4100-4199.4101 - An endpoint is "going away", such as a server going down or a browser having navigated away from a page.
	         * @property {number}  4000-4999.4100-4199.4102 - An endpoint is terminating the connection due to a protocol error.
	         * @property {number}  4000-4999.4100-4199.4103 - An endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
	         * @property {number}  4000-4999.4100-4199.4104 - Reserved. The specific meaning might be defined in the future.
	         * @property {number}  4000-4999.4100-4199.4105 - No status code was actually present.
	         * @property {number}  4000-4999.4100-4199.4106 - Maybe no network, wrong url or server down.
	         * @property {number}  4000-4999.4100-4199.4107 - An endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [http://tools.ietf.org/html/rfc3629] data within a text message).
	         * @property {number}  4000-4999.4100-4199.4108 - An endpoint is terminating the connection because it has received a message that "violates its policy". This reason is given either if there is no other sutible reason, or if there is a need to hide specific details about the policy.
	         * @property {number}  4000-4999.4100-4199.4109 - An endpoint is terminating the connection because it has received a message that is too big for it to process.
	         * @property {number}  4000-4999.4100-4199.4110 - An endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake.
	         * @property {number}  4000-4999.4100-4199.4111 - A server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
	         * @property {number}  4000-4999.4100-4199.4115 - The connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).
	         * @property {Http}  4000-4999.4400-4499
	         * @property {number}  4000-4999.4400-4499.4400 - Bad request. Maybe stream parameters are missing or malformed.
	         * @property {number}  4000-4999.4400-4499.4403 - Access denied. The authentication token is missing or invalid.
	         * @property {number}  4000-4999.4400-4499.4500 - The connection has been rejected due an internal server error.
	         */

	        /**
	         * @event NanoCore~onStats
	         * @description The stats (h5live only) event to pass in the 'config.events' object at the setup call. Fires if the player has measured statistics.
	         * @see [config]{@link NanoCore~config}
	         * @type {object}
	         * @property {string} name - The event name.
	         * @property {string} player - The player name (id of the playerDiv).
	         * @property {object} data - The data object.
	         * @property {object} data.stats - The stats object.
	         * @property {number} data.stats.currentTime - The current time of the video.
	         * @property {object} data.stats.playout - The playout object.
	         * @property {number} data.stats.playout.start - The start play time of the video.
	         * @property {number} data.stats.playout.end - The end play time of the video.
	         * @property {object} data.stats.buffer - The buffer object.
	         * @property {number} data.stats.buffer.start - The start buffer time of the video.
	         * @property {number} data.stats.buffer.end - The end buffer time of the video.
	         * @property {object} data.stats.buffer.delay - The delay buffer object.
	         * @property {number} data.stats.buffer.delay.current - The current delay time.
	         * @property {number} data.stats.buffer.delay.avg - The average delay time over the last second.
	         * @property {number} data.stats.buffer.delay.min - The minimum delay time over the last second.
	         * @property {number} data.stats.buffer.delay.max - The maximum delay time over the last second.
	         * @property {HTMLMediaElement} data.currentTarget - The media element.
	         * @example
	         * // player instance of NanoCore
	         * var onStats = function (event) {
	         *     comnsole.log('Stats: ' + JSON.stringify(event.data.stats));
	         * };
	         * config.events.onStats = onStats;
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */

	        /**
	         * @alias setup
	         * @memberOf NanoCore#
	         * @description Initializes the player with a given config object.
	         * @param {config} config - The config object for the player including sources, events, styles.
	         * @returns {Promise.<config|error>}
	         * @example
	         * // player instance of NanoCore
	         * player.setup(config).then(function (config) {
	         *     console.log('setup ok with config: ' + JSON.stringify(config)));
	         * }, function (error) {
	         *     console.log(error);
	         * });
	         */
	        proto.setup = function (config) {
	            return new Promise(
	                function (resolve, reject) {
	                    try {
	                        if (this._realPlayer && this._realPlayer !== this._dummyPlayer) {
	                            this._realPlayer.destroy();
	                            this._realPlayer = this._dummyPlayer;
	                        }

	                        playerFactory.create(this._playerDivId, config).then(
	                            function (player) {
	                                this.version = player.version;
	                                this.type = player.type;
	                                this._realPlayer = player;
	                                this._propagator = propagator.create(player, events, this);
	                                this._realPlayer.setup(config).then(
	                                    function (config) {
	                                        window.onbeforeunload = function () {
	                                            this._realPlayer.destroy();
	                                        }.bind(this);
	                                        this.id = config.id;
	                                        resolve(config);
	                                    }.bind(this),
	                                    reject
	                                );
	                            }.bind(this),
	                            function (error) {
	                                reject(error);
	                            }
	                        );
	                    }
	                    catch (err) {
	                        reject(err);
	                    }
	                }.bind(this)
	            );
	        };

	        /**
	         * @alias destroy
	         * @memberOf NanoCore#
	         * @description Destroys the player instance.
	         * @example
	         * // player instance of NanoCore
	         * player.destroy();
	         */
	        proto.destroy = function () {
	            this._realPlayer.destroy();
	        };

	        /**
	         * @alias play
	         * @memberOf NanoCore#
	         * @description Plays the player.
	         * @example
	         * // player instance of NanoCore
	         * player.play();
	         */
	        proto.play = function () {
	            this._realPlayer.play();
	        };

	        /**
	         * @alias pause
	         * @memberOf NanoCore#
	         * @description Pauses the player.
	         * @example
	         * // player instance of NanoCore
	         * player.pause();
	         */
	        proto.pause = function () {
	            this._realPlayer.pause();
	        };

	        /**
	         * @alias mute
	         * @memberOf NanoCore#
	         * @description Mutes the player.
	         * @example
	         * // player instance of NanoCore
	         * player.mute();
	         */
	        proto.mute = function () {
	            this._realPlayer.mute();
	        };

	        /**
	         * @alias unmute
	         * @memberOf NanoCore#
	         * @description Unmutes the player.
	         * @example
	         * // player instance of NanoCore
	         * player.unmute();
	         */
	        proto.unmute = function () {
	            this._realPlayer.unmute();
	        };

	        /**
	         * @alias setVolume
	         * @memberOf NanoCore#
	         * @description Sets the volume of the player.
	         * @param {number} volume - The volume to set in a range from 0.0 to 1.0.
	         * @example
	         * // player instance of NanoCore
	         * player.setVolume(0.3);
	         */
	        proto.setVolume = function (volume) {
	            this._realPlayer.setVolume(volume);
	        };

	        NanoCore.events = events;
	        NanoCore.states = states;
	        NanoCore.emptyConfig = emptyConfig;
	        NanoCore.pauseReasons = pauseReason;
	        NanoCore.version = version.CORE;
	        NanoCore.capabilities = playerFactory.capabilities;

	        return NanoCore;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-11-25.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'NORMAL'                : 'normal',
	        'BUFFER'                : 'buffer',
	        'CONNECTION_CLOSE'      : 'connectionclose',
	        'SERVER_NOT_FOUND'      : 'servernotfound',
	        'STREAM_NOT_FOUND'      : 'streamnotfound',
	        'INTERACTION_REQUIRED'  : 'interactionrequired',
	        'PLAYBACK_SUSPENDED'    : 'playbacksuspended',
	        'PLAYBACK_ERROR'        : 'playbackerror',
	        'RECONNECTION_IMMINENT' : 'reconnectionimminent'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	// iplayer.js - interface

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (EventEmitter) {
	    'use strict';

	    function IPlayer () {
	        this.version = undefined;

	        this.type = undefined;
	    }

	    var proto = (IPlayer.prototype = Object.create(EventEmitter.prototype));

	    proto.setup = function () {
	        throw new Error('"setup" must be implemented or player not initialized');
	    };

	    proto.destroy = function () {
	        throw new Error('"destroy" must be implemented or player not initialized');
	    };

	    proto.play = function () {
	        throw new Error('"play" must be implemented or player not initialized by call setup');
	    };

	    proto.pause = function () {
	        throw new Error('"pause" must be implemented or player not initialized by call setup');
	    };

	    proto.mute = function () {
	        throw new Error('"mute" must be implemented or player not initialized by call setup');
	    };

	    proto.unmute = function () {
	        throw new Error('"unmute" must be implemented or player not initialized by call setup');
	    };

	    proto.setVolume = function () {
	        throw new Error('"setVolume" must be implemented or player not initialized by call setup');
	    };

	    IPlayer.isSupported = function () {
	        return false;
	    };

	    IPlayer.supportedTechniques = [];

	    return IPlayer;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * EventEmitter v4.2.11 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - http://oli.me.uk/
	 * @preserve
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    /**
	     * Class for managing events.
	     * Can be extended to provide event functionality in other classes.
	     *
	     * @class EventEmitter Manages event registering and emitting.
	     */
	    function EventEmitter () {}

	    // Shortcuts to improve speed and size
	    var proto = EventEmitter.prototype;

	    /**
	     * Finds the index of the listener for the event in its storage array.
	     *
	     * @param {Function[]} listeners Array of listeners to search through.
	     * @param {Function} listener Method to look for.
	     * @return {Number} Index of the specified listener, -1 if not found
	     * @api private
	     */
	    function indexOfListener (listeners, listener) {
	        var i = listeners.length;
	        while (i--) {
	            if (listeners[i].listener === listener) {
	                return i;
	            }
	        }

	        return -1;
	    }

	    /**
	     * Alias a method while keeping the context correct, to allow for overwriting of target method.
	     *
	     * @param {String} name The name of the target method.
	     * @return {Function} The aliased method
	     * @api private
	     */
	    function alias (name) {
	        return function aliasClosure () {
	            return this[name].apply(this, arguments);
	        };
	    }

	    /**
	     * Returns the listener array for the specified event.
	     * Will initialise the event object and listener arrays if required.
	     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	     * Each property in the object response is an array of listener functions.
	     *
	     * @param {String|RegExp} evt Name of the event to return the listeners from.
	     * @return {Function[]|Object} All listener functions for the event.
	     */
	    proto.getListeners = function getListeners (evt) {
	        var events = this._getEvents();
	        var response;
	        var key;

	        // Return a concatenated array of all matching events if
	        // the selector is a regular expression.
	        if (evt instanceof RegExp) {
	            response = {};
	            for (key in events) {
	                if (events.hasOwnProperty(key) && evt.test(key)) {
	                    response[key] = events[key];
	                }
	            }
	        }
	        else {
	            response = events[evt] || (events[evt] = []);
	        }

	        return response;
	    };

	    /**
	     * Takes a list of listener objects and flattens it into a list of listener functions.
	     *
	     * @param {Object[]} listeners Raw listener objects.
	     * @return {Function[]} Just the listener functions.
	     */
	    proto.flattenListeners = function flattenListeners (listeners) {
	        var flatListeners = [];
	        var i;

	        for (i = 0; i < listeners.length; i += 1) {
	            flatListeners.push(listeners[i].listener);
	        }

	        return flatListeners;
	    };

	    /**
	     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	     *
	     * @param {String|RegExp} evt Name of the event to return the listeners from.
	     * @return {Object} All listener functions for an event in an object.
	     */
	    proto.getListenersAsObject = function getListenersAsObject (evt) {
	        var listeners = this.getListeners(evt);
	        var response;

	        if (listeners instanceof Array) {
	            response = {};
	            response[evt] = listeners;
	        }

	        return response || listeners;
	    };

	    /**
	     * Adds a listener function to the specified event.
	     * The listener will not be added if it is a duplicate.
	     * If the listener returns true then it will be removed after it is called.
	     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	     *
	     * @param {String|RegExp} evt Name of the event to attach the listener to.
	     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.addListener = function addListener (evt, listener) {
	        var listeners = this.getListenersAsObject(evt);
	        var listenerIsWrapped = typeof listener === 'object';
	        var key;

	        for (key in listeners) {
	            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
	                listeners[key].push(
	                    listenerIsWrapped
	                        ? listener
	                        : {
	                            'listener' : listener,
	                            'once'     : false
	                        }
	                );
	            }
	        }

	        return this;
	    };

	    /**
	     * Alias of addListener
	     */
	    proto.on = alias('addListener');

	    /**
	     * Semi-alias of addListener. It will add a listener that will be
	     * automatically removed after its first execution.
	     *
	     * @param {String|RegExp} evt Name of the event to attach the listener to.
	     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.addOnceListener = function addOnceListener (evt, listener) {
	        return this.addListener(evt, {
	            'listener' : listener,
	            'once'     : true
	        });
	    };

	    /**
	     * Alias of addOnceListener.
	     */
	    proto.once = alias('addOnceListener');

	    /**
	     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	     * You need to tell it what event names should be matched by a regex.
	     *
	     * @param {String} evt Name of the event to create.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.defineEvent = function defineEvent (evt) {
	        this.getListeners(evt);
	        return this;
	    };

	    /**
	     * Uses defineEvent to define multiple events.
	     *
	     * @param {String[]} evts An array of event names to define.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.defineEvents = function defineEvents (evts) {
	        for (var i = 0; i < evts.length; i += 1) {
	            this.defineEvent(evts[i]);
	        }
	        return this;
	    };

	    /**
	     * Removes a listener function from the specified event.
	     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	     *
	     * @param {String|RegExp} evt Name of the event to remove the listener from.
	     * @param {Function} listener Method to remove from the event.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.removeListener = function removeListener (evt, listener) {
	        var listeners = this.getListenersAsObject(evt);
	        var index;
	        var key;

	        for (key in listeners) {
	            if (listeners.hasOwnProperty(key)) {
	                index = indexOfListener(listeners[key], listener);

	                if (index !== -1) {
	                    listeners[key].splice(index, 1);
	                }
	            }
	        }

	        return this;
	    };

	    /**
	     * Alias of removeListener
	     */
	    proto.off = alias('removeListener');

	    /**
	     * Adds listeners in bulk using the manipulateListeners method.
	     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	     * You can also pass it a regular expression to add the array of listeners to all events that match it.
	     * Yeah, this function does quite a bit. That's probably a bad thing.
	     *
	     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	     * @param {Function[]} [listeners] An optional array of listener functions to add.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.addListeners = function addListeners (evt, listeners) {
	        // Pass through to manipulateListeners
	        return this.manipulateListeners(false, evt, listeners);
	    };

	    /**
	     * Removes listeners in bulk using the manipulateListeners method.
	     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	     * You can also pass it an event name and an array of listeners to be removed.
	     * You can also pass it a regular expression to remove the listeners from all events that match it.
	     *
	     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	     * @param {Function[]} [listeners] An optional array of listener functions to remove.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.removeListeners = function removeListeners (evt, listeners) {
	        // Pass through to manipulateListeners
	        return this.manipulateListeners(true, evt, listeners);
	    };

	    /**
	     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	     * The first argument will determine if the listeners are removed (true) or added (false).
	     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	     * You can also pass it an event name and an array of listeners to be added/removed.
	     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	     *
	     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.manipulateListeners = function manipulateListeners (remove, evt, listeners) {
	        var i;
	        var value;
	        var single = remove ? this.removeListener : this.addListener;
	        var multiple = remove ? this.removeListeners : this.addListeners;

	        // If evt is an object then pass each of its properties to this method
	        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
	            for (i in evt) {
	                if (evt.hasOwnProperty(i) && (value = evt[i])) {
	                    // Pass the single listener straight through to the singular method
	                    if (typeof value === 'function') {
	                        single.call(this, i, value);
	                    }
	                    else {
	                        // Otherwise pass back to the multiple function
	                        multiple.call(this, i, value);
	                    }
	                }
	            }
	        }
	        else {
	            // So evt must be a string
	            // And listeners must be an array of listeners
	            // Loop over it and pass each one to the multiple method
	            i = listeners.length;
	            while (i--) {
	                single.call(this, evt, listeners[i]);
	            }
	        }

	        return this;
	    };

	    /**
	     * Removes all listeners from a specified event.
	     * If you do not specify an event then all listeners will be removed.
	     * That means every event will be emptied.
	     * You can also pass a regex to remove all events that match it.
	     *
	     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.removeEvent = function removeEvent (evt) {
	        var type = typeof evt;
	        var events = this._getEvents();
	        var key;

	        // Remove different things depending on the state of evt
	        if (type === 'string') {
	            // Remove all listeners for the specified event
	            delete events[evt];
	        }
	        else if (evt instanceof RegExp) {
	            // Remove all events matching the regex.
	            for (key in events) {
	                if (events.hasOwnProperty(key) && evt.test(key)) {
	                    delete events[key];
	                }
	            }
	        }
	        else {
	            // Remove all listeners in all events
	            delete this._events;
	        }

	        return this;
	    };

	    /**
	     * Alias of removeEvent.
	     *
	     * Added to mirror the node API.
	     */
	    proto.removeAllListeners = alias('removeEvent');

	    /**
	     * Emits an event of your choice.
	     * When emitted, every listener attached to that event will be executed.
	     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	     * So they will not arrive within the array on the other side, they will be separate.
	     * You can also pass a regular expression to emit to all events that match it.
	     *
	     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	     * @param {Array} [args] Optional array of arguments to be passed to each listener.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.emitEvent = function emitEvent (evt, args) {
	        var listenersMap = this.getListenersAsObject(evt);
	        var listeners;
	        var listener;
	        var i;
	        var key;
	        var response;

	        for (key in listenersMap) {
	            if (listenersMap.hasOwnProperty(key)) {
	                listeners = listenersMap[key].slice(0);
	                i = listeners.length;

	                while (i--) {
	                    // If the listener returns true then it shall be removed from the event
	                    // The function is executed either with a basic call or an apply if there is an args array
	                    listener = listeners[i];

	                    if (listener.once === true) {
	                        this.removeListener(evt, listener.listener);
	                    }

	                    response = listener.listener.apply(this, args || []);

	                    if (response === this._getOnceReturnValue()) {
	                        this.removeListener(evt, listener.listener);
	                    }
	                }
	            }
	        }

	        return this;
	    };

	    /**
	     * Alias of emitEvent
	     */
	    proto.trigger = alias('emitEvent');

	    /**
	     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	     *
	     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	     * @param {...*} Optional additional arguments to be passed to each listener.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.emit = function emit (evt) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        if (!args.length) {
	            args.push({
	                'name' : evt,
	                'data' : {}
	            });
	        }
	        else if (args.length && typeof args[0] !== 'object') {
	            args[0] = {
	                'name' : evt,
	                'data' : args[0]
	            };
	        }
	        else if (args.length && !args[0].hasOwnProperty('data')) {
	            args[0] = {
	                'name' : evt,
	                'data' : args[0]
	            };
	        }
	        else {
	            args[0].name = evt;
	        }
	        return this.emitEvent(evt, args);
	    };

	    // MP: (event.name, event) and Array.prototype.slice.call(arguments, 1) sucks
	    proto.emitSimple = function emitSimple (name, payload, target) {
	        return this.emitEvent(name, [
	            {
	                'name'   : name || 'AnonymousEvent',
	                'target' : target || this, // TODO: is this too opening?
	                'data'   : payload || {}
	            }
	        ]);
	    };
	    // MP END

	    /**
	     * Sets the current value to check against when executing listeners. If a
	     * listeners return value matches the one set here then it will be removed
	     * after execution. This value defaults to true.
	     *
	     * @param {*} value The new value to check for when executing listeners.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     */
	    proto.setOnceReturnValue = function setOnceReturnValue (value) {
	        this._onceReturnValue = value;
	        return this;
	    };

	    /**
	     * Fetches the current value to check against when executing listeners. If
	     * the listeners return value matches this one then it should be removed
	     * automatically. It will return true by default.
	     *
	     * @return {*|Boolean} The current value to check for or the default, true.
	     * @api private
	     */
	    proto._getOnceReturnValue = function _getOnceReturnValue () {
	        if (this.hasOwnProperty('_onceReturnValue')) {
	            return this._onceReturnValue;
	        }
	        else {
	            return true;
	        }
	    };

	    /**
	     * Fetches the events object and creates one if required.
	     *
	     * @return {Object} The events storage object.
	     * @api private
	     */
	    proto._getEvents = function _getEvents () {
	        return this._events || (this._events = {});
	    };

	    return EventEmitter;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function create () {
	        return {
	            'playback': {
	                'autoplay'       : true,
	                'muted'          : false,
	                'metadata'       : false,
	                'forceTech'      : '',
	                'flashplayer'    : '',
	                'videoId'        : undefined,
	                'keepConnection' : false,
	                'reconnect'      : {
	                    'minDelay'   : 2,
	                    'maxDelay'   : 10,
	                    'delaySteps' : 10,
	                    'maxRetries' : 10
	                }
	            },
	            'source': {
	                'hls'    : '',
	                'h5live' : {
	                    'server': {
	                        'websocket'   : '',
	                        'progressive' : '',
	                        'hls'         : ''
	                    },
	                    'token' : '',
	                    'rtmp'  : {
	                        'url'        : '',
	                        'streamname' : ''
	                    },
	                    'security': {
	                        'token'   : '',
	                        'expires' : '',
	                        'options' : '',
	                        'tag'     : ''
	                    },
	                    'params': {}
	                }
	            },
	            'events': {
	                'onReady'            : undefined,
	                'onPlay'             : undefined,
	                'onPause'            : undefined,
	                'onLoading'          : undefined,
	                'onStartBuffering'   : undefined,
	                'onStopBuffering'    : undefined,
	                'onError'            : undefined,
	                'onMetaData'         : undefined,
	                'onFullscreenEnter'  : undefined,
	                'onFullscreenExit'   : undefined,
	                'onPlaybackFinished' : undefined,
	                'onMedia'            : undefined,
	                'onStats'            : undefined,
	                'onMute'             : undefined,
	                'onUnmute'           : undefined,
	                'onVolumeChange'     : undefined,
	                'onStreamInfo'       : undefined,
	                'onWarning'          : undefined
	            },
	            'tweaks': {
	                'buffer': {
	                    'min'    : undefined,
	                    'start'  : undefined,
	                    'max'    : undefined,
	                    'target' : undefined,
	                    'limit'  : undefined
	                },
	                'bufferDynamic': {
	                    'offsetThreshold' : undefined,
	                    'offsetStep'      : undefined,
	                    'cooldownTime'    : undefined
	                }
	            }
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'READY'             : 'Ready',
	        'ERROR'             : 'Error',
	        'PAUSE'             : 'Pause',
	        'LOADING'           : 'Loading',
	        'START_BUFFERING'   : 'StartBuffering',
	        'STOP_BUFFERING'    : 'StopBuffering',
	        'PLAY'              : 'Play',
	        'METADATA'          : 'MetaData',
	        'STATS'             : 'Stats',
	        'PLAYBACK_FINISHED' : 'PlaybackFinished',
	        'MEDIA'             : 'Media',
	        'STREAM_INFO'       : 'StreamInfo',
	        'MUTE'              : 'Mute',
	        'UNMUTE'            : 'Unmute',
	        'VOLUME_CHANGE'     : 'VolumeChange',
	        'STATE_CHANGE'      : 'StateChange',
	        'WARNING'           : 'Warning'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'UNINITIALIZED'         : 1,
	        'IDLE'                  : 2,
	        'READY'                 : 3,
	        'LOADING'               : 4,
	        'PLAYING'               : 5,
	        'PAUSED'                : 6,
	        'BUFFERING'             : 7,
	        'UNKNOWN'               : 8,
	        'PLAYBACK_NOT_STARTED'  : 9,
	        'PLAYBACK_SUSPENDED'    : 10,
	        'PAUSING'               : 11,
	        'PLAYBACK_ERROR'        : 12,
	        'RECONNECTION_IMMINENT' : 13,
	        'CONNECTION_ERROR'      : 14
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-11-30.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(12), __webpack_require__(95), __webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    browserInfo,
	    playerReferences,
	    errorMessages,
	    techNames
	) {
	    function filterBySupport (players) {
	        var filtered = players.filter(function (value) {
	            return value.isSupported();
	        });
	        if (!filtered.length) {
	            throw new Error(errorMessages.CLIENT_NOT_SUPPORTED);
	        }
	        return filtered;
	    }

	    function filterBySources (players, config) {
	        var sources = {};
	        sources[techNames.H5LIVE_WSS] = 'h5live';
	        sources[techNames.H5LIVE_HLS] = 'h5live';
	        sources[techNames.FLASH] = 'h5live';
	        sources[techNames.NATIVE] = 'hls';
	        var realSources = [];
	        var filtered = players.filter(function (player) {
	            let beenInSource = false;
	            player.supportedTechniques.forEach(function (techName) {
	                realSources.push(sources[techName]);
	                if (beenInSource === false) {
	                    beenInSource = config.hasOwnProperty('source') && config.source.hasOwnProperty(sources[techName]);
	                }
	            });
	            return beenInSource;
	        });
	        if (!filtered.length) {
	            throw new Error(errorMessages.SOURCE_NOT_SUPPORTED);
	        }
	        return filtered;
	    }

	    function filterByForced (players, config) {
	        var techs = [];
	        var includes = function (a, b) {
	            return a.indexOf(b) !== -1 || b.indexOf(a) !== -1;
	        };
	        var filtered = players.filter(function (player) {
	            techs = techs.concat(player.supportedTechniques);
	            let isIncluded = false;
	            player.supportedTechniques.forEach(function (techName) {
	                if (isIncluded === false) {
	                    isIncluded = config.playback.forceTech ? includes(techName, config.playback.forceTech) : true;
	                }
	            });
	            return isIncluded;
	        });
	        if (!filtered.length) {
	            throw new Error(errorMessages.FORCE_NOT_SUPPORTED.replace('$tech$', config.playback.forceTech));
	        }
	        return filtered;
	    }

	    function createPlayer (players, playerDivId) {
	        var Player = players[0];
	        return new Player(playerDivId);
	    }

	    function create (playerDivId, config) {
	        return new Promise(function (resolve, reject) {
	            var filtered = playerReferences;
	            try {
	                filtered = filterBySupport(filtered);
	                filtered = filterBySources(filtered, config);
	                filtered = filterByForced(filtered, config);
	                resolve(createPlayer(filtered, playerDivId));
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    }

	    return {
	        'create'       : create,
	        'capabilities' : function () {
	            var supportedTechniques = [];
	            playerReferences
	                .filter(function (player) {
	                    return player.isSupported();
	                })
	                .forEach(function (player) {
	                    supportedTechniques = supportedTechniques.concat(player.supportedTechniques);
	                });
	            return supportedTechniques;
	        }
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	// browserInfo.js

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    var unknown = 'Unknown';

	    // screen
	    var screenSize = '';
	    if (screen.width) {
	        var width = screen.width ? screen.width : '';
	        var height = screen.height ? screen.height : '';
	        screenSize += '' + width + ' x ' + height;
	    }

	    //browser
	    var nVer = navigator.appVersion;
	    var nAgt = navigator.userAgent;
	    var browser = navigator.appName;
	    var version = '' + parseFloat(navigator.appVersion);
	    var majorVersion = parseInt(navigator.appVersion, 10);
	    var nameOffset, verOffset, ix;

	    // Opera
	    if ((verOffset = nAgt.indexOf('Opera')) !== -1) {
	        browser = 'Opera';
	        version = nAgt.substring(verOffset + 6);
	        if ((verOffset = nAgt.indexOf('Version')) !== -1) {
	            version = nAgt.substring(verOffset + 8);
	        }
	    }

	    // NEWER Opera
	    if ((verOffset = nAgt.indexOf('OPR/')) !== -1) {
	        browser = 'Opera';
	        version = nAgt.substring(verOffset + 4);
	    }
	    else if ((verOffset = nAgt.indexOf('MSIE')) !== -1) {
	        // MSIE
	        browser = 'Microsoft Internet Explorer';
	        version = nAgt.substring(verOffset + 5);
	    }
	    else if (browser === 'Netscape' && (verOffset = nAgt.indexOf('Trident/')) !== -1) {
	        //IE 11 no longer identifies itself as MS IE, so trap it
	        //http://stackoverflow.com/questions/17907445/how-to-detect-ie11
	        browser = 'Microsoft Internet Explorer';
	        version = nAgt.substring(verOffset + 8);
	        if ((verOffset = nAgt.indexOf('rv:')) !== -1) {
	            version = nAgt.substring(verOffset + 3);
	        }
	    }
	    else if (browser === 'Netscape' && (verOffset = nAgt.indexOf('Edge/')) !== -1) {
	        // Microsoft Edge
	        browser = 'Microsoft Edge';
	        version = nAgt.substring(verOffset + 5);
	    }
	    else if ((verOffset = nAgt.indexOf('Chrome')) !== -1) {
	        // Chrome
	        browser = 'Chrome';
	        version = nAgt.substring(verOffset + 7);
	    }
	    else if ((verOffset = nAgt.indexOf('PhantomJS')) !== -1) {
	        // PhantomJS test framework - headless browser
	        browser = 'PhantomJS';
	        version = nAgt.substring(verOffset + 10);
	    }
	    else if ((verOffset = nAgt.indexOf('Safari')) !== -1) {
	        // Safari
	        browser = 'Safari';
	        version = nAgt.substring(verOffset + 7);
	        if ((verOffset = nAgt.indexOf('Version')) !== -1) {
	            version = nAgt.substring(verOffset + 8);
	        }

	        // Chrome on iPad identifies itself as Safari. Actual results do not match what Google claims
	        //  at: https://developers.google.com/chrome/mobile/docs/user-agent?hl=ja
	        //  No mention of chrome in the user agent string. However it does mention CriOS, which presumably
	        //  can be keyed on to detect it.
	        if (nAgt.indexOf('CriOS') !== -1) {
	            //Chrome on iPad spoofing Safari...correct it.
	            browser = 'Chrome';
	            //Don't believe there is a way to grab the accurate version number, so leaving that for now.
	        }
	    }
	    else if ((verOffset = nAgt.indexOf('Firefox')) !== -1) {
	        // Firefox
	        browser = 'Firefox';
	        version = nAgt.substring(verOffset + 8);
	    }
	    else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
	        // Other browsers
	        browser = nAgt.substring(nameOffset, verOffset);
	        version = nAgt.substring(verOffset + 1);
	        if (browser.toLowerCase() === browser.toUpperCase()) {
	            browser = navigator.appName;
	        }
	    }
	    // trim the version string
	    if ((ix = version.indexOf(';')) !== -1) version = version.substring(0, ix);
	    if ((ix = version.indexOf(' ')) !== -1) version = version.substring(0, ix);
	    if ((ix = version.indexOf(')')) !== -1) version = version.substring(0, ix);

	    majorVersion = parseInt('' + version, 10);
	    if (isNaN(majorVersion)) {
	        version = '' + parseFloat(navigator.appVersion);
	        majorVersion = parseInt(navigator.appVersion, 10);
	    }

	    // mobile version
	    var mobile = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(nVer);

	    // cookie
	    var cookieEnabled = !!navigator.cookieEnabled;

	    if (typeof navigator.cookieEnabled === 'undefined' && !cookieEnabled) {
	        document.cookie = 'testcookie';
	        cookieEnabled = document.cookie.indexOf('testcookie') !== -1;
	    }

	    // system
	    var os = unknown;
	    var clientStrings = [
	        {
	            's' : 'Windows 3.11',
	            'r' : /Win16/
	        },
	        {
	            's' : 'Windows 95',
	            'r' : /(Windows 95|Win95|Windows_95)/
	        },
	        {
	            's' : 'Windows ME',
	            'r' : /(Win 9x 4.90|Windows ME)/
	        },
	        {
	            's' : 'Windows 98',
	            'r' : /(Windows 98|Win98)/
	        },
	        {
	            's' : 'Windows CE',
	            'r' : /Windows CE/
	        },
	        {
	            's' : 'Windows 2000',
	            'r' : /(Windows NT 5.0|Windows 2000)/
	        },
	        {
	            's' : 'Windows XP',
	            'r' : /(Windows NT 5.1|Windows XP)/
	        },
	        {
	            's' : 'Windows Server 2003',
	            'r' : /Windows NT 5.2/
	        },
	        {
	            's' : 'Windows Vista',
	            'r' : /Windows NT 6.0/
	        },
	        {
	            's' : 'Windows 7',
	            'r' : /(Windows 7|Windows NT 6.1)/
	        },
	        {
	            's' : 'Windows 8.1',
	            'r' : /(Windows 8.1|Windows NT 6.3)/
	        },
	        {
	            's' : 'Windows 8',
	            'r' : /(Windows 8|Windows NT 6.2)/
	        },
	        {
	            's' : 'Windows NT 4.0',
	            'r' : /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
	        },
	        {
	            's' : 'Windows ME',
	            'r' : /Windows ME/
	        },
	        {
	            's' : 'Android',
	            'r' : /Android/
	        },
	        {
	            's' : 'Open BSD',
	            'r' : /OpenBSD/
	        },
	        {
	            's' : 'Sun OS',
	            'r' : /SunOS/
	        },
	        {
	            's' : 'Linux',
	            'r' : /(Linux|X11)/
	        },
	        {
	            's' : 'iOS',
	            'r' : /(iPhone|iPad|iPod)/
	        },
	        {
	            's' : 'Mac OS X',
	            'r' : /Mac OS X/
	        },
	        {
	            's' : 'Mac OS',
	            'r' : /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
	        },
	        {
	            's' : 'QNX',
	            'r' : /QNX/
	        },
	        {
	            's' : 'UNIX',
	            'r' : /UNIX/
	        },
	        {
	            's' : 'BeOS',
	            'r' : /BeOS/
	        },
	        {
	            's' : 'OS/2',
	            'r' : /OS\/2/
	        },
	        {
	            's' : 'Search Bot',
	            'r' : /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
	        }
	    ];
	    // TODO for in iterates over the keys of an object !!!! for array iteration use forEach()
	    for (var id in clientStrings) {
	        var cs = clientStrings[id];
	        if (cs.r.test(nAgt)) {
	            os = cs.s;
	            break;
	        }
	    }

	    var osVersion = unknown;

	    if (/Windows/.test(os)) {
	        if (/Windows (.*)/.exec(os)) {
	            osVersion = /Windows (.*)/.exec(os)[1];
	        }
	        os = 'Windows';
	    }

	    switch (os) {
	        case 'Mac OS X':
	            if (/Mac OS X (10[._\d]+)/.exec(nAgt)) {
	                osVersion = /Mac OS X (10[._\d]+)/.exec(nAgt)[1];
	            }
	            break;

	        case 'Android':
	            if (/Android ([._\d]+)/.exec(nAgt)) {
	                osVersion = /Android ([._\d]+)/.exec(nAgt)[1];
	            }
	            break;

	        case 'iOS':
	            osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
	            if (osVersion) {
	                osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
	            }
	            else {
	                osVersion = unknown;
	            }
	            break;
	    }

	    var browserInfo = {
	        'screen'         : screenSize,
	        'browser'        : browser,
	        'browserVersion' : version,
	        'mobile'         : mobile,
	        'os'             : os,
	        'osVersion'      : osVersion,
	        'cookies'        : cookieEnabled
	    };

	    return browserInfo;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*****
	 * This file is auto generated by the build process.
	 * Every modifications to this file will be overridden!
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	    __webpack_require__(13),
	    __webpack_require__(13),
	    __webpack_require__(91),
	    __webpack_require__(92)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(){
	    var result = [];
	    for(var i = 0; i < arguments.length; i++) {
	        result.push(arguments[i]);
	    }

	    return result;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	// iplayer.js - interface

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(5),
	        __webpack_require__(24),
	        __webpack_require__(15),
	        __webpack_require__(11),
	        __webpack_require__(16),
	        __webpack_require__(17),
	        __webpack_require__(6),
	        __webpack_require__(18),
	        __webpack_require__(19),
	        __webpack_require__(22),
	        __webpack_require__(7),
	        __webpack_require__(9),
	        __webpack_require__(23),
	        __webpack_require__(8),
	        __webpack_require__(14),
	        __webpack_require__(26),
	        __webpack_require__(21),
	        __webpack_require__(4),
	        __webpack_require__(27),
	        __webpack_require__(33),
	        __webpack_require__(35),
	        __webpack_require__(52),
	        __webpack_require__(61),
	        __webpack_require__(28),
	        __webpack_require__(30),
	        __webpack_require__(29),
	        __webpack_require__(31),
	        __webpack_require__(38)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        IPlayer,
	        listenerManager,
	        Version,
	        BrowserInfo,
	        Debug,
	        configHandler,
	        EventEmitter,
	        objectUtils,
	        configValidator,
	        conditions,
	        emptyConfig,
	        playerState,
	        networkState,
	        events,
	        errorCodes,
	        wsErrorReasons,
	        techNames,
	        pauseReason,
	        propagatorComponent,
	        performanceComponent,
	        logicManager,
	        networkManager,
	        mediaManager,
	        controlEvents,
	        logicEvents,
	        mediaEvents,
	        networkEvents,
	        apiEvents
	    ) {
	        'use strict';

	        var __debug = Debug.log;

	        function H5Live (playerDivId) {
	            configValidator.validatePlayerDivId(playerDivId);
	            this._setBaseValues(playerDivId);
	        }

	        H5Live.getSupportedTechniques = function () {
	            let supportedTechniques = [];
	            if (conditions.hasMediaSource) {
	                supportedTechniques.push(techNames.H5LIVE_WSS);
	            }
	            if (conditions.useHLS) {
	                supportedTechniques.push(techNames.H5LIVE_HLS);
	            }
	            return supportedTechniques;
	        };

	        H5Live.supportedTechniques = H5Live.getSupportedTechniques();

	        H5Live.isSupported = function () {
	            return H5Live.supportedTechniques.length > 0;
	        };

	        var proto = (H5Live.prototype = Object.create(IPlayer.prototype));

	        proto._setBaseValues = function (playerDivId) {
	            this.version = Version.CORE;
	            this.type = 'h5live';
	            this.id = Math.round(Math.random() * 10e10).toString();
	            this.networkState = this.NETWORK_STATE.UNINITIALIZED;
	            this._info = BrowserInfo;
	            this.config = emptyConfig.create();
	            this._playerDivId = '';
	            this._playing = false;
	            this._streamInfo = null;

	            this._pauseReason = '';

	            this._playerDivId = playerDivId;
	            this._mediaElementId = 'h5live-' + playerDivId;

	            this._componentEmitter = new EventEmitter();

	            /* eslint-disable */
	            // prettier-ignore
	            this._componentListeners = {
	                'logic': [
	                    { 'type' : logicEvents.LOADING_TIMEOUT,                'listener' : this._onLoadingTimeout.bind(this) },
	                    { 'type' : logicEvents.BUFFERING_TIMEOUT,              'listener' : this._onBufferingTimeout.bind(this) },
	                    { 'type' : logicEvents.SERVER_INFO,                    'listener' : this._onServerInfo.bind(this) },
	                    { 'type' : logicEvents.STREAM_INFO,                    'listener' : this._onStreamInfo.bind(this) },
	                    { 'type' : logicEvents.NO_KEEP_CONNECTION,             'listener' : this._onNoKeepConnection.bind(this) },
	                    { 'type' : logicEvents.MIME_TYPE_UNSUPPORTED,          'listener' : this._onMimeTypeUnsupported.bind(this) }
	                ],
	                'network': [
	                    { 'type' : networkEvents.CONNECTING,                   'listener' : this._onConnectionConnecting.bind(this) },
	                    { 'type' : networkEvents.CONNECTED,                    'listener' : this._onConnectionOpen.bind(this) },
	                    { 'type' : networkEvents.DISCONNECTED,                 'listener' : this._onConnectionClosed.bind(this) },
	                    { 'type' : networkEvents.RECONNECTING,                 'listener' : this._onConnectionReconnecting.bind(this) },
	                    { 'type' : networkEvents.RECONNECTION_IMMINENT,        'listener' : this._onConnectionReconnectionImminent.bind(this) },
	                    { 'type' : networkEvents.DESTROYED,                    'listener' : this._onConnectionDestroyed.bind(this) },
	                    { 'type' : networkEvents.INITIALIZATION_ERROR,         'listener' : this._onConnectionInitializationError.bind(this) },
	                    { 'type' : networkEvents.ERROR,                        'listener' : this._onConnectionError.bind(this) }
	                ],
	                'media': [
	                    { 'type' : mediaEvents.ERROR,                          'listener' : this._onError.bind(this) },
	                    { 'type' : mediaEvents.PLAYBACK_ERROR,                 'listener' : this._onMediaError.bind(this) },
	                    { 'type' : mediaEvents.PLAYBACK_STARTED,               'listener' : this._onMediaPlaying.bind(this) },
	                    { 'type' : mediaEvents.PLAYBACK_SUSPENDED,             'listener' : this._onMediaSuspended.bind(this) },
	                    { 'type' : mediaEvents.BUFFERING,                      'listener' : this._onMediaBuffering.bind(this) },
	                    { 'type' : mediaEvents.PLAY_START_ERROR,               'listener' : this._onPlayStartError.bind(this) }

	                ]
	            };
	            /* eslint-enable */

	            this._setState(this.STATE.IDLE);
	        };

	        proto._baseSetup = function (techName, config) {
	            configHandler.merge(config, this.config);
	            configHandler.clean(this.config);

	            var result;
	            if ((result = configValidator.validateConfig(techName, config))) {
	                return result;
	            }
	            else {
	                if (config.playback.videoId) {
	                    this._mediaElementId = config.playback.videoId;
	                }

	                this._setListeners(this.config.events, this);

	                var playerDiv = document.getElementById(this._playerDivId);

	                this._metaDataEnabled = this.config.playback.metadata;

	                var params = this.config.source.h5live.params,
	                    rtmp = this.config.source.h5live.rtmp;
	                var url = params && params.url ? params.url : rtmp && rtmp.url ? rtmp.url : null;
	                var stream = params && params.stream ? params.stream : rtmp && rtmp.streamname ? rtmp.streamname : null;
	                if (url && stream) {
	                    this.config.url = url + '/' + stream;
	                }
	                else {
	                    this.config.url = '';
	                }
	                this.config.type = this.type;
	                this.config.id = this.id;

	                this._components = {
	                    'network'     : networkManager.create(this._componentEmitter),
	                    'media'       : mediaManager.create(this._componentEmitter),
	                    'logic'       : logicManager.create(this._componentEmitter),
	                    'performance' : performanceComponent.create(this._componentEmitter, this._playerDivId),
	                    'propagator'  : propagatorComponent.create(this._componentEmitter, this)
	                };

	                for (var component in this._components) {
	                    if (
	                        this._componentListeners.hasOwnProperty(component) &&
	                        this._componentListeners[component].length
	                    ) {
	                        listenerManager.add({
	                            'target'    : this._componentEmitter,
	                            'listeners' : this._componentListeners[component]
	                        });
	                    }
	                }

	                this._emitConfig();

	                this._setupVideoElement(playerDiv);

	                return result;
	            }
	        };

	        proto.setup = function (config) {
	            return new Promise(
	                function (resolve, reject) {
	                    try {
	                        if (typeof config !== 'undefined') {
	                            var error = this._baseSetup(H5Live.supportedTechniques[0], config);

	                            if (error) {
	                                reject(error);
	                            }
	                            else {
	                                setTimeout(
	                                    function () {
	                                        this._setState(this.STATE.READY);
	                                        this._emit(events.READY, { 'config': this.config });
	                                        if (this.config.playback.autoplay) {
	                                            this.play();
	                                        }
	                                    }.bind(this),
	                                    20
	                                );

	                                resolve(this.config);
	                            }
	                        }
	                        else {
	                            reject(Error('No config passed'));
	                        }
	                    }
	                    catch (err) {
	                        reject(err);
	                    }
	                }.bind(this)
	            );
	        };

	        proto._destroy = function () {
	            this.removeAllListeners();

	            for (var component in this._components) {
	                if (this._components.hasOwnProperty(component)) {
	                    this._components[component].destroy();
	                    delete this._components[component];
	                }
	            }
	            for (var componentListener in this._componentListeners) {
	                if (
	                    this._componentListeners.hasOwnProperty(componentListener) &&
	                    this._componentListeners[componentListener].length
	                ) {
	                    listenerManager.remove({
	                        'target'    : this._componentEmitter,
	                        'listeners' : this._componentListeners[componentListener]
	                    });
	                }
	            }
	        };

	        proto.destroy = proto._destroy;

	        proto._emitConfig = function () {
	            // emit a copy of the config to all components
	            this._componentEmitter.emit(controlEvents.CONFIG, { 'config': objectUtils.copy(this.config) });
	        };

	        proto._setState = function (state) {
	            var data = arguments.length > 1 ? arguments[1] : {};
	            this.state = state;
	            data.state = state;
	            this._componentEmitter.emit(logicEvents.STATE_CHANGE, data);

	            //keep as legacy until removable
	            this._emit(events.STATE_CHANGE);
	        };

	        proto._debug = function (text, level) {
	            __debug('nanoplayer (' + this._playerDivId + '): ' + text, level);
	        };

	        proto._setListeners = function (events, target) {
	            for (var key in events) {
	                if (events.hasOwnProperty(key) && typeof events[key] === 'function') {
	                    var event = key.replace('on', '');
	                    var handler = events[key];
	                    target.on(event, handler);
	                }
	            }
	        };

	        proto._setupVideoElement = function (playerDiv) {
	            this._componentEmitter.emit(controlEvents.CREATE_VIDEO, {
	                'elementId' : this._mediaElementId,
	                'container' : playerDiv
	            });
	        };

	        proto._onPlayStartError = function (e) {
	            this._debug(e.data.error.name + ': ' + e.data.error.message, 1);

	            switch (e.data.error.name) {
	                case 'NotAllowedError':
	                    this._setState(this.STATE.PLAYBACK_NOT_STARTED);
	                    this._emitError(
	                        errorCodes.PLAYER.INTERACTION_REQUIRED,
	                        'Playback must be initialized by user gesture.'
	                    );
	                    this.pause(this.state);
	                    break;
	            }
	        };

	        proto._onError = function (e) {
	            if (this.state === this.STATE.PAUSING || this.state === this.STATE.PAUSED) return;
	            var message = '';
	            var errorCode = e.data.code;

	            switch (errorCode) {
	                case MediaError.MEDIA_ERR_ABORTED:
	                    message = 'A fetching process of the media aborted by user';
	                    break;
	                case MediaError.MEDIA_ERR_NETWORK:
	                    message = 'An error occurred when downloading media';
	                    break;
	                case MediaError.MEDIA_ERR_DECODE:
	                    message = 'An error occurred when decoding media';
	                    break;
	                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
	                    message = 'The received audio/video is not supported';
	                    break;
	                default:
	                    message = 'An unknown media error occurred';
	                    break;
	            }

	            this._debug(
	                'error media with state "' + this._getState() + '", networkstate "' + this._getNetworkState() + '"',
	                3
	            );
	            this._debug('error message: ' + message, 3);

	            this._setState(this.STATE.PLAYBACK_ERROR);
	            this._emitError(errorCode + 3000, message);
	            this.pause(this.state);
	            if (errorCode === MediaError.MEDIA_ERR_DECODE) {
	                setTimeout(this.play.bind(this), 1000);
	            }
	        };

	        proto._preparePlay = function (delay) {
	            this._setState(this.STATE.LOADING, { 'connectDelay': delay });
	            this._emit(events.LOADING, { 'connectDelay': delay });
	        };

	        proto.play = function () {
	            var delay = arguments.length ? arguments[0] : 0;
	            __debug('nanoplayer (' + this._playerDivId + '): play in state ' + this.state, 1);
	            if (this.state < this.STATE.READY) {
	                this._emitError(
	                    errorCodes.PLAYER.NOT_CONFIGURED,
	                    'Could not play because player has not been configured.'
	                );
	            }
	            else if (this.state === this.STATE.READY || this.state === this.STATE.PAUSED) {
	                this._playing = true;
	                if (delay) {
	                    setTimeout(
	                        function () {
	                            if (this.state === this.STATE.LOADING) {
	                                this._componentEmitter.emit(apiEvents.PLAY);
	                                this._componentEmitter.emit(controlEvents.PLAY);
	                            }
	                        }.bind(this),
	                        delay
	                    );
	                }
	                else {
	                    this._componentEmitter.emit(apiEvents.PLAY);
	                    this._componentEmitter.emit(controlEvents.PLAY);
	                }
	                this._preparePlay(delay);
	            }
	            else if (this.state === this.STATE.PAUSING) {
	                __debug('nanoplayer (' + this._playerDivId + 'play in PAUSING state, setting flag to resume');
	                this._resumeOnPause = true;
	            }
	        };

	        proto._onConnectionInitializationError = function (event) {
	            this._debug(
	                'error init connection with state "' +
	                    this._getState() +
	                    '", networkstate "' +
	                    this._getNetworkState() +
	                    '"',
	                2
	            );

	            this.networkState = event.connectionState;
	            var message = 'Connection initialization error.';
	            var data = event ? event.data : undefined;
	            if (data && data.message) {
	                message = data.message;
	            }
	            if (data && data.code) {
	                message += ' (code:' + data.code + ')';
	            }
	            if (data && data.name) {
	                message = data.name + ': ' + message;
	            }
	            this._emitError(errorCodes.NETWORK.COULD_NOT_ESTABLISH_CONNECTION, message);
	            this._setState(this.STATE.CONNECTION_ERROR);
	            this.pause(this.state);
	        };

	        proto._onConnectionError = function (event) {
	            this._debug(
	                'error connection with state "' +
	                    this._getState() +
	                    '", networkstate "' +
	                    this._getNetworkState() +
	                    '"',
	                2
	            );

	            this.networkState = event.connectionState;
	            var message = 'Connection error.';
	            var data = event ? event.data : undefined;
	            if (data && data.message) {
	                message = data.message;
	            }
	            if (data && data.code) {
	                message += ' (code:' + data.code + ')';
	            }
	            if (data && data.name) {
	                message = data.name + ': ' + message;
	            }
	            this._emitError(errorCodes.NETWORK.CONNECTION_ERROR, message);
	            this._setState(this.STATE.CONNECTION_ERROR);
	            this.pause(this.state);
	        };

	        proto._onConnectionConnecting = function (event) {
	            this._debug('connecting', 1);
	            this.networkState = event.connectionState;
	        };

	        proto._onConnectionOpen = function (event) {
	            event.data.count
	                ? this._debug('connection open after ' + event.data.count + ' reconnect tries', 1)
	                : this._debug('connection open', 1);
	            this.networkState = event.connectionState;
	        };

	        proto._onConnectionClosed = function (event) {
	            this._debug('connection closed', 1);

	            this.networkState = event.connectionState;
	            var message;
	            // See http://tools.ietf.org/html/rfc6455#section-7.4.1
	            if (wsErrorReasons.hasOwnProperty(+event.data.code)) {
	                message = wsErrorReasons[+event.data.code];
	            }
	            else {
	                message = 'Unknown reason';
	            }

	            var code = event.data.code;
	            if (code > 1000 && code < 4000) {
	                code += 3100;
	            }
	            this._debug(
	                'closed connection with state "' +
	                    this._getState() +
	                    '", networkstate "' +
	                    this._getNetworkState() +
	                    '"',
	                2
	            );
	            if (code > 4000) {
	                this._emitError(code, message);
	            }
	            this.pause(this.state);
	        };

	        proto._onConnectionDestroyed = function (event) {
	            this._debug('connection destroyed', 1);
	            this.networkState = event.connectionState;
	            if (this.state !== this.STATE.READY && !event.data) {
	                this.pause(this.state);
	            }
	        };

	        proto._onConnectionReconnecting = function (event) {
	            this._debug('reconnect attempt ' + event.data.count + ' started', 1);
	            this.networkState = event.connectionState;
	        };

	        proto._onConnectionReconnectionImminent = function (event) {
	            var code = event.data.code;
	            if (code > 1000 && code < 4000) {
	                code += 3100;
	            }
	            this._debug(
	                'connection ' +
	                    event.data.count +
	                    (event.data.count > 1 ? ' times' : ' time') +
	                    ' unexpectedly closed with code ' +
	                    code +
	                    ', but a reconnect will be prepared',
	                1
	            );
	            this._debug(
	                'reconnect attempt ' + event.data.count + ' starts in ' + Math.round(event.data.delay) + ' ms',
	                1
	            );
	            if (BrowserInfo.os !== 'iOS' || (BrowserInfo.os === 'iOS' && event.data.count > 1)) {
	                this._emitWarning(
	                    'Connection error: closed ' +
	                        event.data.count +
	                        (event.data.count > 1 ? ' times' : ' time') +
	                        ' unexpectedly with code ' +
	                        code +
	                        ', but a reconnect will be prepared in ' +
	                        (event.data.delay / 1000).toFixed(3) +
	                        ' s'
	                );
	            }
	            this.networkState = event.connectionState;
	            // TODO remove browser condition here
	            if (this._playing && BrowserInfo.os !== 'iOS') {
	                this._setState(this.STATE.RECONNECTION_IMMINENT);
	                this.pause(this.state);
	                this.play(event.data.delay);
	            }
	        };

	        proto._onServerInfo = function (event) {
	            this._debug('onServerInfo', 2);
	            try {
	                var stringified = JSON.stringify(event.data);
	                this._debug('' + stringified, 3);
	            }
	            catch (e) {}
	        };

	        proto._onStreamInfo = function (event) {
	            this._debug('onStreamInfo', 2);
	            this._emit(events.STREAM_INFO, event.data);
	        };

	        proto._onNoKeepConnection = function (event) {
	            this._debug('onNoKeepConnection', 2);
	            this._emitWarning(event.data.message);
	        };

	        proto._onMimeTypeUnsupported = function () {
	            this._setState(this.STATE.PLAYBACK_ERROR);
	            this._emitError(errorCodes.MEDIA.NOT_SUPPORTED, 'The received audio/video is not supported');
	            this.pause(this.state);
	        };

	        proto._onMediaError = function (e) {
	            this._setState(this.STATE.PLAYBACK_ERROR);
	            this._emitError(errorCodes.PLAYER.PLAYBACK_ERROR, e.data);
	            this.pause(this.state);
	        };

	        proto._onMediaSuspended = function () {
	            this._setState(this.STATE.PLAYBACK_SUSPENDED);
	            this._emitError(errorCodes.PLAYER.PLAYBACK_SUSPENDED, 'Playback suspended by external reason.');
	            this.pause(this.state);
	        };

	        proto._emit = function (name, event) {
	            var evt = {};
	            if (event && event.name && event.data) {
	                evt = event;
	            }
	            else if (event) {
	                evt.data = event;
	                evt.name = name || 'unknown';
	            }
	            else {
	                evt.data = {};
	                evt.name = name || 'unknown';
	            }
	            evt.player = this._playerDivId;
	            evt.id = this.id;
	            evt.version = this.version;
	            evt.state = this.state;
	            if (name === 'Error' && evt.data.code && evt.data.message) {
	                this._debug('error ' + evt.data.code + ' ' + evt.data.message, 1);
	            }
	            this.emit(evt.name, evt);
	        };

	        proto._emitError = function (code, message) {
	            this._emit(events.ERROR, {
	                'code'    : code,
	                'message' : message
	            });
	        };

	        proto._emitWarning = function (message) {
	            this._emit(events.WARNING, { 'message': message });
	        };

	        proto._getPauseReason = function (triggered) {
	            var reason = '';
	            if (!triggered) {
	                reason = pauseReason.NORMAL;
	            }
	            else {
	                var networkReason =
	                    this.networkState !== this.NETWORK_STATE.OPEN &&
	                    this.networkState !== this.NETWORK_STATE.UNINITIALIZED;
	                switch (triggered) {
	                    case this.STATE.READY: {
	                        reason = pauseReason.SERVER_NOT_FOUND;
	                        break;
	                    }
	                    case this.STATE.LOADING: {
	                        if (networkReason) {
	                            reason = pauseReason.CONNECTION_CLOSE;
	                        }
	                        else {
	                            reason = pauseReason.STREAM_NOT_FOUND;
	                        }
	                        break;
	                    }
	                    case this.STATE.BUFFERING: {
	                        if (networkReason) {
	                            reason = pauseReason.CONNECTION_CLOSE;
	                        }
	                        else {
	                            reason = pauseReason.BUFFER;
	                        }
	                        break;
	                    }
	                    case this.STATE.UNKNOWN: {
	                        if (networkReason) {
	                            reason = pauseReason.CONNECTION_CLOSE;
	                        }
	                        else {
	                            reason = pauseReason.UNKNOWN;
	                        }
	                        break;
	                    }
	                    case this.STATE.PLAYING: {
	                        if (networkReason) {
	                            reason = pauseReason.CONNECTION_CLOSE;
	                        }
	                        else {
	                            reason = pauseReason.NORMAL;
	                        }
	                        break;
	                    }
	                    case this.STATE.PLAYBACK_NOT_STARTED: {
	                        reason = pauseReason.INTERACTION_REQUIRED;
	                        break;
	                    }
	                    case this.STATE.PLAYBACK_SUSPENDED: {
	                        reason = pauseReason.PLAYBACK_SUSPENDED;
	                        break;
	                    }
	                    case this.STATE.PLAYBACK_ERROR: {
	                        reason = pauseReason.PLAYBACK_ERROR;
	                        break;
	                    }
	                    case this.STATE.RECONNECTION_IMMINENT: {
	                        reason = pauseReason.RECONNECTION_IMMINENT;
	                        break;
	                    }
	                    case this.STATE.CONNECTION_ERROR: {
	                        reason = pauseReason.CONNECTION_CLOSE;
	                        break;
	                    }
	                    default: {
	                        reason = pauseReason.NORMAL;
	                        break;
	                    }
	                }
	            }
	            return reason;
	        };

	        proto._triggerPause = function () {
	            if (this.state === this.STATE.PAUSED) {
	                __debug('nanoplayer (' + this._playerDivId + '): trigger pause but already in state paused');
	                return;
	            }
	            __debug(
	                'nanoplayer (' +
	                    this._playerDivId +
	                    '): trigger pause with reason "' +
	                    this._pauseReason +
	                    '", state "' +
	                    this._getState() +
	                    '", networkstate "' +
	                    this._getNetworkState() +
	                    '"',
	                3
	            );
	            this._setState(this.STATE.PAUSED);
	            this._emit(events.PAUSE, { 'reason': this._pauseReason });

	            //TODO: quick and dirty fix for the play while in PAUSING state, refactor asap
	            if (this._resumeOnPause) {
	                this._resumeOnPause = false;
	                this.play();
	            }
	        };

	        proto.pause = function () {
	            var triggered = arguments.length ? arguments[0] : 0;
	            __debug('nanoplayer (' + this._playerDivId + '): pause in state ' + this.state, 2);
	            if (this.state < this.STATE.READY) {
	                this._emitError(
	                    errorCodes.PLAYER.NOT_PLAYING,
	                    'Could not pause because player was not in playing state before.'
	                );
	            }
	            else if (this.state !== this.STATE.PAUSED && this.state !== this.STATE.PAUSING) {
	                this._pauseReason = this._getPauseReason(triggered);
	                this._setState(this.STATE.PAUSING);
	                this._playing = false;
	                this._resumeOnPause = false;

	                this._componentEmitter.emit(apiEvents.PAUSE);

	                //TODO: move to logic
	                this._componentEmitter.emit(controlEvents.PAUSE);
	                this._triggerPause();
	            }
	        };

	        proto.mute = function () {
	            this._componentEmitter.emit(controlEvents.MUTE);
	        };

	        proto.unmute = function () {
	            this._componentEmitter.emit(controlEvents.UNMUTE);
	        };

	        proto.setVolume = function (volume) {
	            this._componentEmitter.emit(controlEvents.SET_VOLUME, { 'volume': volume });
	        };

	        proto._parseUrl = function (rtmpUrl) {
	            var data = {
	                    'url'        : '',
	                    'streamname' : ''
	                },
	                pos = rtmpUrl.lastIndexOf('/');
	            var url = rtmpUrl.substr(0, pos);
	            var stream = rtmpUrl.substr(pos, rtmpUrl - pos);
	            data.url = url;
	            data.streamname = stream;
	            return data;
	        };

	        proto._getState = function () {
	            return objectUtils.findPropertyByValue(this.STATE, this.state);
	        };

	        proto._getNetworkState = function () {
	            return objectUtils.findPropertyByValue(this.NETWORK_STATE, this.networkState);
	        };

	        proto._onMediaPlaying = function () {
	            var state = this.state;
	            this._setState(playerState.PLAYING);
	            this._emit(state === playerState.BUFFERING ? events.STOP_BUFFERING : events.PLAY);
	            this._debug('state is PLAYING');
	        };

	        proto._onMediaBuffering = function () {
	            this._setState(playerState.BUFFERING);
	            this._emit(events.START_BUFFERING);
	        };

	        proto._onLoadingTimeout = function () {
	            this._emitError(errorCodes.STREAM.NOT_FOUND, 'The requested stream can not be found.');
	            this.pause(this.state);
	        };

	        proto._onBufferingTimeout = function () {
	            this._emitError(errorCodes.STREAM.MEDIA_NOT_AVAILABLE, 'No media available');
	            this.pause(this.state);
	        };

	        proto.STATE = playerState;
	        proto.NETWORK_STATE = networkState;
	        proto.PAUSE_REASON = pauseReason;

	        return H5Live;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'PLAYER': {
	            'NO_RTMP_URL_SET'       : 1001,
	            'NO_SERVER_SET'         : 1002,
	            'NOT_CONFIGURED'        : 1003,
	            'NOT_PLAYING'           : 1004,
	            'INTERACTION_REQUIRED'  : 1005,
	            'BUFFER_CONFIG_INVALID' : 1006,
	            'PLAYBACK_SUSPENDED'    : 1007,
	            'PLAYBACK_ERROR'        : 1008
	        },
	        'STREAM': {
	            'NOT_FOUND'                 : 2001,
	            'MEDIA_NOT_AVAILABLE'       : 2002,
	            'METADATA_STILL_PROCESSING' : 2014,
	            'METADATA_NO_START_INDEX'   : 2013,
	            'METADATA_INVALID_JSON'     : 2012,
	            'METADATA_WRONG_INDEX'      : 2011
	        },
	        'MEDIA': {
	            'ABORTED'        : 3001,
	            'DOWNLOAD_ERROR' : 3002,
	            'DECODE_ERROR'   : 3003,
	            'NOT_SUPPORTED'  : 3004
	        },
	        'NETWORK': {
	            'COULD_NOT_ESTABLISH_CONNECTION' : 4001,
	            'CONNECTION_ERROR'               : 4002,
	            'MAX_RECONNECTS_REACHED'         : 4003,
	            'RECONNECTION_CONFIG_INVALID'    : 4004
	        }
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	    Auto-generated on build, do not modify!

	    General info file for builds.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){
	    return { CORE: '3.10.0' };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var Debug = (function () {
	        var debugLevel = setDebugLevel();
	        var _HTTPParams = undefined;
	        setInterval(function () {
	            debugLevel = setDebugLevel();
	        }, 5000);

	        var log = function (m, l) {
	            try {
	                if (debugLevel >= l) {
	                    console.debug(_getTime() + ': ' + m);
	                }
	            }
	            catch (e) {}
	        };

	        function setDebugLevel () {
	            var paramLevel = !isNaN(getHTTPParam('debug')) ? +getHTTPParam('debug') : 0;
	            var cookieLevel = +getCookieValue('nanoDebug');
	            return Math.max(paramLevel, cookieLevel);
	        }

	        function getCookieValue (cookie) {
	            return document.cookie.indexOf(cookie + '=') !== -1
	                ? document.cookie.split(cookie + '=')[1].split(';')[0]
	                : null;
	        }

	        function getHTTPParam (paramKey) {
	            // if params dont exist, create/read them
	            if (!_HTTPParams) {
	                _HTTPParams = [];
	                var strGET = document.location.search.substr(1, document.location.search.length);
	                if (strGET === '' && document.location.href.indexOf('?') !== -1) {
	                    var pos = document.location.href.indexOf('?') + 1;
	                    strGET = document.location.href.slice(pos);
	                }
	                if (strGET !== '') {
	                    var gArr = strGET.split('&');
	                    for (var i = 0; i < gArr.length; ++i) {
	                        var v = '';
	                        var vArr = gArr[i].split('=');
	                        var k = vArr[0];
	                        if (vArr.length > 1) {
	                            v = vArr[1];
	                        }
	                        _HTTPParams[decodeURIComponent(k)] = decodeURIComponent(v);
	                    }
	                }
	            }
	            // return requested param, if exists
	            try {
	                return _HTTPParams[paramKey];
	            }
	            catch (e) {
	                return undefined;
	            }
	        }

	        function _getTime () {
	            return new Date().toISOString();
	        }

	        return {
	            'log'          : log,
	            'getHTTPParam' : getHTTPParam
	        };
	    })();

	    return Debug;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function merge (source, target) {
	        var key;
	        for (key in source) {
	            if (source.hasOwnProperty(key) && target.hasOwnProperty(key)) {
	                if (typeof source[key] === 'object' && !Object.keys(target[key]).length) {
	                    extend(source[key], target[key]);
	                }
	                else if (typeof source[key] === 'object') {
	                    merge(source[key], target[key]);
	                }
	                else {
	                    target[key] = source[key];
	                }
	            }
	        }
	    }

	    function extend (source, target) {
	        var key;
	        for (key in source) {
	            if (source.hasOwnProperty(key)) {
	                !target[key] && (target[key] = {});
	                if (typeof source[key] === 'object') {
	                    extend(source[key], target[key]);
	                }
	                else {
	                    target[key] = source[key];
	                }
	            }
	        }
	    }

	    function clean (source) {
	        var key;
	        for (key in source) {
	            if (
	                source.hasOwnProperty(key) &&
	                (typeof source[key] === 'undefined' || (typeof source[key] === 'string' && source[key].length === 0))
	            ) {
	                delete source[key];
	            }
	            if (source.hasOwnProperty(key) && source[key] instanceof Object) {
	                clean(source[key]);
	            }
	        }
	        for (key in source) {
	            if (
	                (source.hasOwnProperty(key) &&
	                    (typeof source[key] === 'undefined' ||
	                        (typeof source[key] === 'string' && source[key].length === 0))) ||
	                (typeof source[key] === 'object' &&
	                    typeof source[key] !== 'function' &&
	                    Object.keys(source[key]).length === 0)
	            ) {
	                delete source[key];
	            }
	        }
	    }

	    function check (source, target, level, noticed) {
	        var key,
	            deeper = (level = level || 0) && level > 0;
	        for (key in source) {
	            noticed = !!noticed && deeper ? noticed : '';
	            if (target.hasOwnProperty(key)) {
	                if (source[key] instanceof Object && target[key] instanceof Object) {
	                    level++;
	                    var error = check(source[key], target[key], level, (noticed += key + '.'));
	                    if (error !== null) {
	                        return error;
	                    }
	                }
	                else if (typeof source[key] !== target[key]) {
	                    return Error('The property "' + noticed + key + '" must be of type "' + target[key] + '"');
	                }
	                else {
	                    level = 0;
	                }
	            }
	            else {
	                return Error('The property "' + noticed + key + '" is not a valid config property');
	            }
	        }
	        return null;
	    }

	    return {
	        'merge'  : merge,
	        'clean'  : clean,
	        'check'  : check,
	        'extend' : extend
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var toString = Object.prototype.toString;
	    function deepCopy (obj) {
	        var rv;

	        switch (typeof obj) {
	            case 'object':
	                if (obj === null) {
	                    // null => null
	                    rv = null;
	                }
	                else {
	                    switch (toString.call(obj)) {
	                        case '[object Array]':
	                            // It's an array, create a new array with
	                            // deep copies of the entries
	                            rv = obj.map(deepCopy);
	                            break;
	                        case '[object Date]':
	                            // Clone the date
	                            rv = new Date(obj);
	                            break;
	                        case '[object RegExp]':
	                            // Clone the RegExp
	                            rv = new RegExp(obj);
	                            break;
	                        // ...probably a few others
	                        default:
	                            // Some other kind of object, deep-copy its
	                            // properties into a new object
	                            rv = Object.keys(obj).reduce(function (prev, key) {
	                                prev[key] = deepCopy(obj[key]);
	                                return prev;
	                            }, {});
	                            break;
	                    }
	                }
	                break;
	            default:
	                // It's a primitive, copy via assignment
	                rv = obj;
	                break;
	        }
	        return rv;
	    }

	    function findPropertyByValue (object, value) {
	        if (typeof object === 'object') {
	            for (var property in object) {
	                if (object[property] === value) {
	                    return property;
	                }
	            }
	        }
	        return false;
	    }

	    return {
	        'copy'                : deepCopy,
	        'findPropertyByValue' : findPropertyByValue
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20), __webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = function (configErrorMessages, techNames) {
	    function validateConfig (techName, config) {
	        var src = config.source.h5live;
	        if (!src.rtmp || !src.rtmp.url || !src.rtmp.streamname) {
	            return new Error(configErrorMessages.CONFIG_RTMP);
	        }
	        if ((!src.server || (!src.server.websocket && !src.server.hls)) && !src.token) {
	            return new Error(configErrorMessages.CONFIG_TOKEN);
	        }
	        if (techName === techNames.H5LIVE_WSS && src.server && !src.server.websocket) {
	            return new Error(configErrorMessages.CONFIG_WSS);
	        }
	        if (techName === techNames.H5LIVE_HLS) {
	            if (src.server && !src.server.hls) {
	                return new Error(configErrorMessages.CONFIG_HLS);
	            }
	            if (config.playback.metadata && !src.server.websocket) {
	                return new Error(configErrorMessages.CONFIG_METADATA);
	            }
	        }
	        return false;
	    }

	    function validatePlayerDivId (playerDivId) {
	        if (!(typeof playerDivId === 'string' || playerDivId instanceof String)) {
	            throw new Error('The param "playerDivId" must be of type "String"');
	        }
	        return true;
	    }

	    return {
	        'validateConfig'      : validateConfig,
	        'validatePlayerDivId' : validatePlayerDivId
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-12-01.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'CONFIG_RTMP':
	            'Configuration error. Could not create player, the rtmp configuration is missing or incomplete. Add an rtmp url and streamname to the configuration.',
	        'CONFIG_TOKEN':
	            'Configuration error. Could not create player, with this configuration an security token is required. Add an token to the configuration.',
	        'CONFIG_WSS'      : 'Configuration error. Could not create player, the websocket server configuration is missing.',
	        'CONFIG_HLS'      : 'Configuration error. Could not create player, the hls server configuration is missing.',
	        'CONFIG_METADATA' :
	            'Configuration error. Could not create player, the websocket server configuration for metadata is missing.'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-11-30.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'FLASH'      : 'flash',
	        'NATIVE'     : 'hls.native',
	        'H5LIVE_WSS' : 'h5live',
	        'H5LIVE_HLS' : 'h5live.hls'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11)], __WEBPACK_AMD_DEFINE_RESULT__ = function (browserInfo) {
	    var useHLS = browserInfo.os === 'iOS' && parseInt(browserInfo.osVersion.split('.')[0], 10) >= 10;

	    var isIEorEdge = browserInfo.browser === 'Microsoft Internet Explorer' || browserInfo.browser === 'Microsoft Edge';

	    var hasMediaSource =
	        browserInfo.os !== 'iOS' &&
	        !!window.MediaSource &&
	        window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');

	    var isChromeHigher57 = browserInfo.browser === 'Chrome' && parseInt(browserInfo.browserVersion, 10) > 57;

	    var isIOS11 = browserInfo.os === 'iOS' && parseInt(browserInfo.osVersion.split('.')[0], 10) >= 11;

	    var isFirefox = browserInfo.browser === 'Firefox';

	    var isSafari = browserInfo.browser === 'Safari';

	    return {
	        'useHLS'           : useHLS,
	        'isIEorEdge'       : isIEorEdge,
	        'isChromeHigher57' : isChromeHigher57,
	        'hasMediaSource'   : hasMediaSource,
	        'isIOS11'          : isIOS11,
	        'isFirefox'        : isFirefox,
	        'isSafari'         : isSafari
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'UNINITIALIZED' : 1,
	        'CONNECTING'    : 2,
	        'OPEN'          : 3,
	        'CLOSING'       : 4,
	        'CLOSED'        : 5
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * add/remove event listeners to/from an emitter-like reference.
	 *
	 * Created by derelict on 2016.12.11..
	 * Modified by Thomas Niederges on 2017.08.25
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(25)], __WEBPACK_AMD_DEFINE_RESULT__ = function (errors) {
	    'use strict';

	    /**
	     * 'add' type function names for different implementations of event emitters
	     * @type {string[]}
	     */
	    var ADD_FUNCTIONS = ['addEventListener', 'addListener', 'on'];

	    /**
	     * 'remove' type function names for different implementations of event emitters
	     * @type {string[]}
	     */
	    var REMOVE_FUNCTIONS = ['removeEventListener', 'removeListener', 'off'];

	    /**
	     * checks for all mandatory values in the config object, and throws error when something is
	     * missing or invalid.
	     *
	     * @param config {object}
	     */
	    function validateConfig (config) {
	        if (!config.target) {
	            throw new Error(errors.NO_TARGET);
	        }
	        if (!config.listeners || !config.listeners.length) {
	            throw new Error(errors.NO_LISTENERS);
	        }
	        if (!getFunction(config.target, ADD_FUNCTIONS) || !getFunction(config.target, REMOVE_FUNCTIONS)) {
	            throw new Error(errors.NOT_DISPATCHER);
	        }
	        for (var i = 0; i < config.listeners.length; ++i) {
	            if (
	                (config.listeners[i].type || typeof config.listeners[i].type === 'string') &&
	                config.listeners[i].type.length === 0
	            ) {
	                config.listeners.splice(i, 1);
	                i--;
	                continue;
	            }
	            if (!config.listeners[i].type) {
	                throw new Error(errors.MISSING_TYPE.replace('%index%', i));
	            }
	            if (typeof config.listeners[i].listener !== 'function') {
	                throw new Error(errors.MISSING_LISTENER.replace('%index%', i));
	            }
	        }
	    }

	    /**
	     * searches the target for a function name that matches one of the list items, and returns a
	     * reference to that function.
	     *
	     * @param target {object}
	     * @param list {string[]}
	     * @returns {function|null}
	     */
	    function getFunction (target, list) {
	        for (var i = 0; i < list.length; ++i) {
	            if (typeof target[list[i]] === 'function') {
	                return target[list[i]];
	            }
	        }
	        return null;
	    }

	    /**
	     * validates the config and adds/removes listeners based on the function list and the config.
	     *
	     * @param functions {string[]}
	     * @param config {object}
	     */
	    function manage (functions, config) {
	        validateConfig(config);
	        iterate(getFunction(config.target, functions), config.target, config.listeners);
	    }

	    /**
	     * iterates through the listeners, and calls the given function in the target's scope.
	     * @param f {function}
	     * @param target {object}
	     * @param listeners {object[]}
	     */
	    function iterate (f, target, listeners) {
	        for (var i = 0; i < listeners.length; ++i) {
	            f.call(target, listeners[i].type, listeners[i].listener);
	        }
	    }

	    /**
	     * return two curried references to the manage function that will add and remove listeners.
	     */
	    return {
	        'add'    : manage.bind(null, ADD_FUNCTIONS),
	        'remove' : manage.bind(null, REMOVE_FUNCTIONS)
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-12-13.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'NO_TARGET'        : 'No target in config',
	        'NO_LISTENERS'     : 'No listeners in config',
	        'NOT_DISPATCHER'   : 'Target is not an event dispatcher',
	        'MISSING_TYPE'     : 'Missing type in listener #%index%',
	        'MISSING_LISTENER' : 'Missing/invalid listener in listener #%index%'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-29.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        '1000' : 'Normal closure, meaning that the purpose for which the connection was established has been fulfilled.',
	        '1001' :
	            'An endpoint is "going away", such as a server going down or a browser having navigated away from a page.',
	        '1002' : 'An endpoint is terminating the connection due to a protocol error',
	        '1003' :
	            'An endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).',
	        '1004' : 'Reserved. The specific meaning might be defined in the future.',
	        '1005' : 'No status code was actually present.',
	        '1006' : 'Maybe no network, wrong url or server down.',
	        '1007' :
	            'An endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [http://tools.ietf.org/html/rfc3629] data within a text message).',
	        '1008':
	            'An endpoint is terminating the connection because it has received a message that "violates its policy". This reason is given either if there is no other sutible reason, or if there is a need to hide specific details about the policy.',
	        '1009':
	            'An endpoint is terminating the connection because it has received a message that is too big for it to process.',
	        '1011':
	            'A server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.',
	        '1015':
	            'The connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can\'t be verified).',
	        '4400' : 'Bad request. Maybe stream parameters are missing or malformed.',
	        '4403' : 'Access denied. The authentication token is missing or invalid.',
	        '4500' : 'The connection has been rejected due an internal server error.',
	        '4503' : 'The requested service is currently unavailable.',
	        '4900' : 'The security service has been rejected due an internal server error.',
	        '4901' : 'The security service denied access. The authentication token is invalid.',
	        '4903' :
	            'The security service denied access. The url is expired or a token parameter is missing (expires, token, or options).',
	        '4904': 'The security service can not be found.'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 11/6/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(24),
	        __webpack_require__(14),
	        __webpack_require__(8),
	        __webpack_require__(28),
	        __webpack_require__(29),
	        __webpack_require__(30),
	        __webpack_require__(31),
	        __webpack_require__(32)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        listenerManager,
	        facadeErrorCodes,
	        facadeEvents,
	        controlEvents,
	        mediaEvents,
	        logicEvents,
	        networkEvents,
	        logger
	    ) {
	        function create (componentEmitter, facadeEmitter) {
	            var l = logger.create('FacadePropagator');

	            var volume = 1.0;
	            var muted = false;
	            var stats;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : mediaEvents.VOLUME_CHANGE,                 'listener' : onVolumeChange },
	                { 'type' : mediaEvents.QUALITY_STATS,                 'listener' : onQualityStats },
	                { 'type' : mediaEvents.PLAY_STATS,                    'listener' : onPlayStats },
	                { 'type' : mediaEvents.SOURCE_ENDED,                  'listener' : onSourceEndedOrClosed },
	                { 'type' : mediaEvents.SOURCE_CLOSED,                 'listener' : onSourceEndedOrClosed },
	                { 'type' : logicEvents.META_DATA_RECEIVED,            'listener' : onMetaDataReceived }
	            ];

	            // prettier-ignore
	            var errorTranslation = [
	                { 'event': logicEvents.META_DATA_ERROR,               'code': null,                                                 'message': null,               'defer': true },
	                { 'event': logicEvents.MISSING_RTMP_ERROR,            'code': facadeErrorCodes.PLAYER.NO_RTMP_URL_SET,              'message': 'No rtmp url set.', 'defer': false },
	                { 'event': logicEvents.NO_SERVER_ERROR,               'code': facadeErrorCodes.PLAYER.NO_SERVER_SET,                'message': 'No server set.',   'defer': false },
	                { 'event': networkEvents.RECONNECTION_CONFIG_INVALID, 'code': facadeErrorCodes.NETWORK.RECONNECTION_CONFIG_INVALID, 'message': null,               'defer': true },
	                { 'event': mediaEvents.BUFFER_TWEAKS_ERROR,           'code': facadeErrorCodes.PLAYER.BUFFER_CONFIG_INVALID,        'message': null,               'defer': false }
	            ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : componentEmitter,
	                    'listeners' : listeners
	                });

	                errorTranslation.forEach(function (item) {
	                    componentEmitter.addListener(item.event, onErrorEvent);
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : componentEmitter,
	                    'listeners' : listeners
	                });

	                errorTranslation.forEach(function (item) {
	                    componentEmitter.removeListener(item.event, onErrorEvent);
	                });
	            }

	            function emit (name, event) {
	                var evt = {};
	                if (event && event.name && event.data) {
	                    evt = event;
	                }
	                else if (event) {
	                    evt.data = event;
	                    evt.name = name || 'unknown';
	                }
	                else {
	                    evt.data = {};
	                    evt.name = name || 'unknown';
	                }

	                //TODO: review the need for these values, and how to add them to the outgoing event
	                evt.player = facadeEmitter._playerDivId;
	                evt.state = facadeEmitter.state;

	                if (name === 'Error' && evt.data.code && evt.data.message) {
	                    l.debug('error ' + evt.data.code + ' ' + evt.data.message);
	                }
	                facadeEmitter.emit(evt.name, evt);
	            }

	            function onErrorEvent (e) {
	                var code;
	                var message;

	                errorTranslation.forEach(function (item) {
	                    if (item.event === e.name) {
	                        code = item.code ? item.code : e.data.code;
	                        message = item.message ? item.message : e.data.reason;

	                        if (item.defer) {
	                            setTimeout(emitError.bind(this, code, message), 0);
	                        }
	                        else {
	                            emitError(code, message);
	                        }
	                    }
	                });
	            }

	            function emitError (code, message) {
	                emit(facadeEvents.ERROR, {
	                    'code'    : code,
	                    'message' : message
	                });
	            }

	            function onPlayStats (e) {
	                var quality;

	                if (stats && stats.quality) {
	                    quality = stats.quality;
	                }

	                stats = e.data.stats;

	                if (quality && !stats.quality) {
	                    stats.quality = quality;
	                }

	                var s = 'stats error',
	                    clonedStats;

	                try {
	                    s = JSON.stringify(stats);
	                    clonedStats = JSON.parse(s);
	                    delete clonedStats.buffer.update;
	                    delete clonedStats.buffer.delay.before;
	                }
	                catch (e) {}

	                emit(facadeEvents.STATS, { 'stats': clonedStats });
	            }

	            function onQualityStats (e) {
	                if (!stats) {
	                    stats = {};
	                }
	                stats.quality = e.data;
	            }

	            function onSourceEndedOrClosed (e) {
	                l.debug(
	                    'mediaSource ' +
	                        (e.type === mediaEvents.SOURCE_ENDED ? 'ended' : 'closed') +
	                        ', readyState: ' +
	                        e.data.readyState
	                );
	                emit(facadeEvents.PLAYBACK_FINISHED);
	            }

	            function onVolumeChange (e) {
	                if (e.data.muted !== muted) {
	                    muted = e.data.muted;
	                    emit(muted ? facadeEvents.MUTE : facadeEvents.UNMUTE, { 'volume': volume });
	                }
	                else if (e.data.volume !== volume) {
	                    volume = e.data.volume;
	                    emit(facadeEvents.VOLUME_CHANGE, { 'volume': volume });
	                }
	            }

	            function onMetaDataReceived (e) {
	                setTimeout(emit.bind(this, facadeEvents.METADATA, e.data), 0);
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'control.';

	    return {
	        'BASE': eventBase,

	        'CONNECT'       : eventBase + 'connect',
	        'DISCONNECT'    : eventBase + 'disconnect',
	        'NETWORK_PLAY'  : eventBase + 'networkPlay',
	        'NETWORK_PAUSE' : eventBase + 'networkPause',
	        'PLAY'          : eventBase + 'play',
	        'PAUSE'         : eventBase + 'pause',
	        'MUTE'          : eventBase + 'mute',
	        'UNMUTE'        : eventBase + 'unmute',
	        'SET_VOLUME'    : eventBase + 'setVolume',
	        'SEEK'          : eventBase + 'seek',
	        'SET_RATE'      : eventBase + 'playbackRate',
	        'CONFIG'        : eventBase + 'config',
	        'CREATE_VIDEO'  : eventBase + 'createVideo',
	        'DESTROY_VIDEO' : eventBase + 'destroyVideo',
	        'VIDEO_SOURCE'  : eventBase + 'videoSource'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'media.';

	    return {
	        'BASE': eventBase,

	        'LOAD_START'            : eventBase + 'loadstart',
	        'PROGRESS'              : eventBase + 'progress',
	        'SUSPEND'               : eventBase + 'suspend',
	        'ABORT'                 : eventBase + 'abort',
	        'EMPTIED'               : eventBase + 'emptied',
	        'STALLED'               : eventBase + 'stalled',
	        'PLAY'                  : eventBase + 'play',
	        'PAUSE'                 : eventBase + 'pause',
	        'LOADED_META_DATA'      : eventBase + 'loadedmetadata',
	        'LOADED_DATA'           : eventBase + 'loadeddata',
	        'WAITING'               : eventBase + 'waiting',
	        'ERROR'                 : eventBase + 'error',
	        'PLAYING'               : eventBase + 'playing',
	        'CAN_PLAY'              : eventBase + 'canplay',
	        'CAN_PLAY_THROUGH'      : eventBase + 'canplaythrough',
	        'SEEKING'               : eventBase + 'seeking',
	        'SEEKED'                : eventBase + 'seeked',
	        'TIME_UPDATE'           : eventBase + 'timeupdate',
	        'ENDED'                 : eventBase + 'ended',
	        'RATE_CHANGE'           : eventBase + 'ratechange',
	        'DURATION_CHANGE'       : eventBase + 'durationchange',
	        'VOLUME_CHANGE'         : eventBase + 'volumechange',
	        'ELEMENT_CREATED'       : eventBase + 'elementCreated',
	        'QUALITY_STATS'         : eventBase + 'qualitystats',
	        'PLAY_STATS'            : eventBase + 'playStats',
	        'FRAME_DROP'            : eventBase + 'framedrop',
	        'SOURCE_OPEN'           : eventBase + 'sourceopen', //TODO: temporary, remove
	        'SOURCE_ENDED'          : eventBase + 'sourceended', //TODO: temporary, remove, use FINISHED instead
	        'SOURCE_CLOSED'         : eventBase + 'sourceclosed', //TODO: temporary, remove, use FINISHED instead
	        'PLAYBACK_ERROR'        : eventBase + 'playbackError',
	        'PLAYBACK_STARTED'      : eventBase + 'playbackStarted',
	        'PLAYBACK_SUSPENDED'    : eventBase + 'playbackSuspended',
	        'BUFFERING'             : eventBase + 'buffering',
	        'PLAY_START_SUCCESS'    : eventBase + 'playStartSuccess',
	        'PLAY_START_ERROR'      : eventBase + 'playStartError',
	        'BUFFER_TWEAKS_CREATED' : eventBase + 'bufferTweaksCreated',
	        'BUFFER_TWEAKS_ERROR'   : eventBase + 'bufferTweaksError'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'logic.';

	    return {
	        'BASE': eventBase,

	        'STATE_CHANGE'          : eventBase + 'stateChange',
	        'LOADING_TIMEOUT'       : eventBase + 'loadingTimeout',
	        'BUFFERING_TIMEOUT'     : eventBase + 'bufferingTimeout',
	        'STREAM_INFO'           : eventBase + 'streamInfo',
	        'SERVER_INFO'           : eventBase + 'serverInfo',
	        'STREAM_URL'            : eventBase + 'streamUrl',
	        'NO_KEEP_CONNECTION'    : eventBase + 'noKeepConnection',
	        'MIME_TYPE_UNSUPPORTED' : eventBase + 'mimeTypeUnsupported',
	        'META_DATA_RECEIVED'    : eventBase + 'metaDataReceived',
	        'META_DATA_ERROR'       : eventBase + 'metaDataError',
	        'NO_SERVER_ERROR'       : eventBase + 'noServerError',
	        'MISSING_RTMP_ERROR'    : eventBase + 'missingRtmpError'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'network.';

	    return {
	        'BASE': eventBase,

	        'CONNECTING'                  : eventBase + 'connecting',
	        'CONNECTED'                   : eventBase + 'connected',
	        'DISCONNECTED'                : eventBase + 'disconnected',
	        'RESUMING'                    : eventBase + 'resuming',
	        'RECONNECTION_IMMINENT'       : eventBase + 'reconnectionImminent',
	        'RECONNECTING'                : eventBase + 'reconnecting',
	        'RECONNECTION_CONFIG_INVALID' : eventBase + 'reconnectionConfigInvalid',
	        'CONNECTION_ERROR'            : eventBase + 'connectionError',
	        'INITIALIZATION_ERROR'        : eventBase + 'initializationError',
	        'MAX_RETRY_REACHED'           : eventBase + 'maxRetryReached',
	        'ERROR'                       : eventBase + 'error',
	        'DESTROYED'                   : eventBase + 'destroyed',
	        'META_DATA'                   : eventBase + 'metaData',
	        'SERVER_INFO'                 : eventBase + 'serverInfo',
	        'STREAM_INFO'                 : eventBase + 'streamInfo',
	        'STREAM_FRAGMENT'             : eventBase + 'streamFragment',
	        'RANDOM_ACCESS_POINT'         : eventBase + 'randomAccessPoint',
	        'RAW_PACKET'                  : eventBase + 'raw'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 8/21/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Debug) {
	    var ERROR = 0;
	    var WARNING = 1;
	    var INFO = 2;
	    var DEBUG = 3;
	    var DETAIL = 4;

	    function log (level, label, message) {
	        Debug.log('[' + label + '] ' + message, level);
	    }

	    function create (label) {
	        return {
	            'debug'  : log.bind(this, DEBUG, label),
	            'info'   : log.bind(this, INFO, label),
	            'warn'   : log.bind(this, WARNING, label),
	            'error'  : log.bind(this, ERROR, label),
	            'detail' : log.bind(this, DETAIL, label)
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/1/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(34),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(28),
	        __webpack_require__(29),
	        __webpack_require__(31)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (performance, conditions, listenerManager, controlEvents, mediaEvents, networkEvents) {
	        var MARK_BASE = 'nano';
	        var MARK_DELIMITER = '.';

	        var CONNECTING = 'connecting';
	        var CONNECTED = 'connected';
	        var FIRST_FRAGMENT = 'firstFragmentReceived';
	        var FIRST_FRAME = 'firstFrameRendered';
	        var PLAYABLE = 'playable';
	        var PLAYING = 'playing';

	        function create (emitter, playerId) {
	            var setMarks = [];

	            /* eslint-disable */
	            // prettier-ignore
	            var wssListeners = [
	                { 'type' : networkEvents.CONNECTING,        'listener' : onConnecting }, //CONNECTING
	                { 'type' : networkEvents.CONNECTED,         'listener' : onConnected }, //CONNECTED
	                { 'type' : networkEvents.STREAM_FRAGMENT,   'listener' : onStreamFragment }, //FIRST_FRAGMENT
	                { 'type' : mediaEvents.LOADED_DATA,         'listener' : onLoadedData }, //FIRST_FRAME
	                { 'type' : mediaEvents.CAN_PLAY_THROUGH,    'listener' : onPlayable }, //PLAYABLE
	                { 'type' : mediaEvents.PLAYING,             'listener' : onPlaying } //PLAYING
	            ];

	            // prettier-ignore
	            var hlsListeners = [
	                { 'type' : mediaEvents.LOAD_START,          'listener' : onConnecting }, //CONNECTING
	                { 'type' : mediaEvents.DURATION_CHANGE,     'listener' : onConnected }, //CONNECTED
	                { 'type' : mediaEvents.LOADED_META_DATA,    'listener' : onStreamFragment }, //FIRST_FRAGMENT
	                { 'type' : mediaEvents.LOADED_DATA,         'listener' : onLoadedData }, //FIRST_FRAME
	                { 'type' : mediaEvents.CAN_PLAY_THROUGH,    'listener' : onPlayable }, //PLAYABLE
	                { 'type' : mediaEvents.PLAYING,             'listener' : onPlaying } //PLAYING
	            ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : conditions.useHLS ? hlsListeners : wssListeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : conditions.useHLS ? hlsListeners : wssListeners
	                });
	            }

	            function setMark (label) {
	                var mark = [MARK_BASE, playerId, label].join(MARK_DELIMITER);
	                if (performance && typeof performance.mark === 'function' && setMarks.indexOf(mark) === -1) {
	                    performance.mark(mark);
	                    setMarks.push(mark);
	                }
	            }

	            function onConnecting () {
	                setMark(CONNECTING);
	            }

	            function onConnected () {
	                setMark(CONNECTED);
	            }

	            function onPlayable () {
	                setMark(PLAYABLE);
	            }

	            function onPlaying () {
	                setMark(PLAYING);
	            }

	            function onStreamFragment () {
	                setMark(FIRST_FRAGMENT);
	            }

	            function onLoadedData () {
	                setMark(FIRST_FRAME);
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * User Timing polyfill (http://www.w3.org/TR/user-timing/)
	 * @author RubaXa <trash@rubaxa.org>
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var startOffset = Date.now ? Date.now() : +new Date(),
	        performance = window.performance || {},
	        _entries = [],
	        _marksIndex = {},
	        _filterEntries = function (key, value) {
	            var i = 0,
	                n = _entries.length,
	                result = [];
	            for (; i < n; i++) {
	                if (_entries[i][key] === value) {
	                    result.push(_entries[i]);
	                }
	            }
	            return result;
	        },
	        _clearEntries = function (type, name) {
	            var i = _entries.length,
	                entry;
	            while (i--) {
	                entry = _entries[i];
	                if (entry.entryType === type && (name === void 0 || entry.name === name)) {
	                    _entries.splice(i, 1);
	                }
	            }
	        };

	    if (!performance.now) {
	        performance.now =
	            performance.webkitNow ||
	            performance.mozNow ||
	            performance.msNow ||
	            function () {
	                return (Date.now ? Date.now() : +new Date()) - startOffset;
	            };
	    }

	    if (!performance.mark) {
	        performance.mark =
	            performance.webkitMark ||
	            function (name) {
	                var mark = {
	                    'name'      : name,
	                    'entryType' : 'mark',
	                    'startTime' : performance.now(),
	                    'duration'  : 0
	                };
	                _entries.push(mark);
	                _marksIndex[name] = mark;
	            };
	    }

	    if (!performance.measure) {
	        performance.measure =
	            performance.webkitMeasure ||
	            function (name, startMark, endMark) {
	                startMark = _marksIndex[startMark].startTime;
	                endMark = _marksIndex[endMark].startTime;

	                _entries.push({
	                    'name'      : name,
	                    'entryType' : 'measure',
	                    'startTime' : startMark,
	                    'duration'  : endMark - startMark
	                });
	            };
	    }

	    if (!performance.getEntriesByType) {
	        performance.getEntriesByType =
	            performance.webkitGetEntriesByType ||
	            function (type) {
	                return _filterEntries('entryType', type);
	            };
	    }

	    if (!performance.getEntriesByName) {
	        performance.getEntriesByName =
	            performance.webkitGetEntriesByName ||
	            function (name) {
	                return _filterEntries('name', name);
	            };
	    }

	    if (!performance.clearMarks) {
	        performance.clearMarks =
	            performance.webkitClearMarks ||
	            function (name) {
	                _clearEntries('mark', name);
	            };
	    }

	    if (!performance.clearMeasures) {
	        performance.clearMeasures =
	            performance.webkitClearMeasures ||
	            function (name) {
	                _clearEntries('measure', name);
	            };
	    }

	    // exports
	    if (window.performance === undefined) {
	        window.performance = performance;
	    }
	    return window.performance;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(6),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(37),
	        __webpack_require__(38),
	        __webpack_require__(28),
	        __webpack_require__(30),
	        __webpack_require__(29),
	        __webpack_require__(31),
	        __webpack_require__(39),
	        __webpack_require__(36),
	        __webpack_require__(40),
	        __webpack_require__(41),
	        __webpack_require__(42),
	        __webpack_require__(43),
	        __webpack_require__(44),
	        __webpack_require__(46),
	        __webpack_require__(47),
	        __webpack_require__(48),
	        __webpack_require__(50),
	        __webpack_require__(51)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        EventEmitter,
	        conditions,
	        listenerManager,
	        eventTranslator,
	        apiEvents,
	        controlEvents,
	        logicEvents,
	        mediaEvents,
	        networkEvents,
	        bufferControlEvents,
	        connectionEvents,
	        logicManagerEvents,
	        timeoutEvents,
	        streamInfoEvents,
	        metaDataEvents,
	        connection,
	        wssLiveController,
	        hlsLiveController,
	        streamInfoCreator,
	        timeout,
	        metaData
	    ) {
	        'use strict';

	        function create (publicEmitter) {
	            var privateEmitter = new EventEmitter(),
	                l = logger.create('LogicManager'),
	                inwardTranslator,
	                outwardTranslator,
	                components = [],
	                /* eslint-disable */
	                // prettier-ignore
	                outwardEvents = [
	                    { 'from' : bufferControlEvents.SEEK,                    'to' : controlEvents.SEEK },
	                    { 'from' : bufferControlEvents.RATE,                    'to' : controlEvents.SET_RATE },
	                    { 'from' : connectionEvents.CONNECT,                    'to' : controlEvents.CONNECT },
	                    { 'from' : connectionEvents.DISCONNECT,                 'to' : controlEvents.DISCONNECT },
	                    { 'from' : connectionEvents.VIDEO_SOURCE,               'to' : controlEvents.VIDEO_SOURCE },
	                    { 'from' : connectionEvents.NETWORK_PLAY,               'to' : controlEvents.NETWORK_PLAY },
	                    { 'from' : connectionEvents.NO_SERVER_ERROR,            'to' : logicEvents.NO_SERVER_ERROR },
	                    { 'from' : connectionEvents.MISSING_RTMP_ERROR,         'to' : logicEvents.MISSING_RTMP_ERROR },
	                    { 'from' : connectionEvents.NO_KEEP_CONNECTION,         'to' : logicEvents.NO_KEEP_CONNECTION },
	                    { 'from' : connectionEvents.SERVER_INFO,                'to' : logicEvents.SERVER_INFO },
	                    { 'from' : connectionEvents.URL,                        'to' : logicEvents.STREAM_URL },
	                    { 'from' : timeoutEvents.LOADING_TIMEOUT,               'to' : logicEvents.LOADING_TIMEOUT },
	                    { 'from' : timeoutEvents.BUFFERING_TIMEOUT,             'to' : logicEvents.BUFFERING_TIMEOUT },
	                    { 'from' : streamInfoEvents.CREATED,                    'to' : logicEvents.STREAM_INFO },
	                    { 'from' : streamInfoEvents.MIME_TYPE_UNSUPPORTED,      'to' : logicEvents.MIME_TYPE_UNSUPPORTED },
	                    { 'from' : metaDataEvents.RECEIVED,                     'to' : logicEvents.META_DATA_RECEIVED },
	                    { 'from' : metaDataEvents.ERROR,                        'to' : logicEvents.META_DATA_ERROR }
	                ],
	                // prettier-ignore
	                inwardEvents = [
	                    { 'from' : apiEvents.PLAY,                              'to' : logicManagerEvents.API_PLAY },
	                    { 'from' : apiEvents.PAUSE,                             'to' : logicManagerEvents.API_PAUSE },
	                    { 'from' : mediaEvents.BUFFER_TWEAKS_CREATED,           'to' : logicManagerEvents.BUFFER_TWEAKS_CREATED },
	                    { 'from' : mediaEvents.PLAY_STATS,                      'to' : logicManagerEvents.PLAY_STATS },
	                    { 'from' : mediaEvents.PLAYBACK_STARTED,                'to' : logicManagerEvents.PLAYING },
	                    { 'from' : mediaEvents.BUFFERING,                       'to' : logicManagerEvents.BUFFERING },
	                    { 'from' : mediaEvents.CAN_PLAY,                        'to' : logicManagerEvents.CAN_PLAY },

	                    { 'from' : networkEvents.CONNECTING,                    'to' : logicManagerEvents.NETWORK_CONNECTING },
	                    { 'from' : networkEvents.CONNECTED,                     'to' : logicManagerEvents.NETWORK_CONNECTED },
	                    { 'from' : networkEvents.DISCONNECTED,                  'to' : logicManagerEvents.NETWORK_DISCONNECTED },
	                    { 'from' : networkEvents.DESTROYED,                     'to' : logicManagerEvents.NETWORK_DISCONNECTED },
	                    { 'from' : networkEvents.RECONNECTING,                  'to' : logicManagerEvents.NETWORK_RECONNECTING },
	                    { 'from' : networkEvents.RECONNECTION_IMMINENT,         'to' : logicManagerEvents.NETWORK_RECONNECTION_IMMINENT },
	                    { 'from' : networkEvents.INITIALIZATION_ERROR,          'to' : logicManagerEvents.NETWORK_INITIALIZATION_ERROR },
	                    { 'from' : networkEvents.ERROR,                         'to' : logicManagerEvents.NETWORK_ERROR },
	                    { 'from' : networkEvents.RANDOM_ACCESS_POINT,           'to' : logicManagerEvents.RANDOM_ACCESS_POINT },

	                    { 'from' : networkEvents.SERVER_INFO,                   'to' : logicManagerEvents.SERVER_INFO },
	                    { 'from' : networkEvents.STREAM_INFO,                   'to' : logicManagerEvents.STREAM_INFO },
	                    { 'from' : networkEvents.META_DATA,                     'to' : logicManagerEvents.META_DATA },
	                    { 'from' : logicEvents.STATE_CHANGE,                    'to' : logicManagerEvents.APPLICATION_STATE_CHANGE },
	                    { 'from' : logicEvents.STREAM_URL,                      'to' : logicManagerEvents.STREAM_URL },

	                    { 'from' : controlEvents.CONFIG,                        'to' : logicManagerEvents.CONFIG }
	                ],
	                // prettier-ignore
	                controlListeners = [
	                    { 'type' : logicManagerEvents.CONFIG,                   'listener' : onConfig }
	                ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');

	                inwardTranslator = eventTranslator.create(publicEmitter, privateEmitter, inwardEvents);
	                outwardTranslator = eventTranslator.create(privateEmitter, publicEmitter, outwardEvents);

	                listenerManager.add({
	                    'target'    : privateEmitter,
	                    'listeners' : controlListeners
	                });
	                components.push(connection.create(privateEmitter));
	            }

	            function destroy () {
	                inwardTranslator.destroy();
	                inwardTranslator = null;
	                outwardTranslator.destroy();
	                outwardTranslator = null;

	                while (components.length) {
	                    components.pop().destroy();
	                }

	                listenerManager.remove({
	                    'target'    : privateEmitter,
	                    'listeners' : controlListeners
	                });
	            }

	            function onConfig (e) {
	                components.push(
	                    conditions.useHLS
	                        ? hlsLiveController.create(privateEmitter)
	                        : wssLiveController.create(privateEmitter)
	                );
	                components.push(timeout.create(privateEmitter));
	                components.push(streamInfoCreator.create(privateEmitter));
	                if (e.data.config.playback.metadata) {
	                    components.push(metaData.create(privateEmitter));
	                }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }
	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'connection.';

	    return {
	        'BASE': eventBase,

	        'CONNECT'            : eventBase + 'connect',
	        'DISCONNECT'         : eventBase + 'disconnect',
	        'VIDEO_SOURCE'       : eventBase + 'videoSource',
	        'NETWORK_PLAY'       : eventBase + 'networkPlay',
	        'NO_SERVER_ERROR'    : eventBase + 'noServerError',
	        'MISSING_RTMP_ERROR' : eventBase + 'missingRtmpError',
	        'SERVER_INFO'        : eventBase + 'serverInfo',
	        'NO_KEEP_CONNECTION' : eventBase + 'noKeepConnection',
	        'URL'                : eventBase + 'url'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 7/18/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = function (listenerManager) {
	    function create (originEmitter, targetEmitter, eventList) {
	        var originListeners;
	        var events = {};

	        function init () {
	            originListeners = [];

	            eventList.forEach(function (item) {
	                originListeners.push({
	                    'type'     : item.from,
	                    'listener' : onOriginEvent
	                });

	                //create a lookup of all events, so we dont need to re-iterate the array on every dispatch
	                if (!events[item.from]) {
	                    events[item.from] = [];
	                }
	                events[item.from].push(item.to);
	            });

	            listenerManager.add({
	                'target'    : originEmitter,
	                'listeners' : originListeners
	            });
	        }

	        function destroy () {
	            listenerManager.remove({
	                'target'    : originEmitter,
	                'listeners' : originListeners
	            });
	            originListeners = null;
	            events = null;
	        }

	        function onOriginEvent (e) {
	            if (events[e.name]) {
	                events[e.name].forEach(function (translatedName) {
	                    var copy = {};
	                    for (var s in e)
	                        if (e.hasOwnProperty(s)) {
	                            copy[s] = e[s];
	                        }
	                    targetEmitter.emit(translatedName, copy);
	                });
	            }
	        }

	        init();

	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 10/26/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'api.';

	    return {
	        'PLAY'  : eventBase + 'play',
	        'PAUSE' : eventBase + 'pause'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'liveBufferControl.';

	    return {
	        'BASE': eventBase,

	        'SEEK' : eventBase + 'seek',
	        'RATE' : eventBase + 'rate'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'logicManager.';

	    return {
	        'BASE': eventBase,

	        'API_PLAY'  : eventBase + 'apiPlay',
	        'API_PAUSE' : eventBase + 'apiPause',

	        'NETWORK_CONNECTING'            : eventBase + 'networkConnecting',
	        'NETWORK_CONNECTED'             : eventBase + 'networkConnected',
	        'NETWORK_DISCONNECTED'          : eventBase + 'networkDisconnected',
	        'NETWORK_RECONNECTION_IMMINENT' : eventBase + 'networkReconnectionImminent',
	        'NETWORK_RECONNECTING'          : eventBase + 'networkReconnecting',
	        'NETWORK_CONNECTION_ERROR'      : eventBase + 'networkConnectionError',
	        'NETWORK_INITIALIZATION_ERROR'  : eventBase + 'networkInitializationError',
	        'NETWORK_MAX_RETRY_REACHED'     : eventBase + 'networkMaxRetryReached',
	        'NETWORK_ERROR'                 : eventBase + 'networkError',
	        'SERVER_INFO'                   : eventBase + 'serverInfo',
	        'STREAM_INFO'                   : eventBase + 'streamInfo',
	        'STREAM_FRAGMENT'               : eventBase + 'streamFragment',
	        'RANDOM_ACCESS_POINT'           : eventBase + 'randomAccessPoint',
	        'STREAM_URL'                    : eventBase + 'streamUrl',

	        'CONFIG'                   : eventBase + 'config',
	        'BUFFER_TWEAKS_CREATED'    : eventBase + 'tweaksCreated',
	        'PLAYING'                  : eventBase + 'playing',
	        'BUFFERING'                : eventBase + 'buffering',
	        'PLAY_STATS'               : eventBase + 'playStats',
	        'APPLICATION_STATE_CHANGE' : eventBase + 'applicationStateChange',
	        'CAN_PLAY'                 : eventBase + 'canPlay',
	        'META_DATA'                : eventBase + 'metaData'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 10/09/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'timeout.';

	    return {
	        'BASE': eventBase,

	        'LOADING_TIMEOUT'   : eventBase + 'loadingTimeout',
	        'BUFFERING_TIMEOUT' : eventBase + 'bufferingTimeout'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'streamInfo.';

	    return {
	        'BASE': eventBase,

	        'CREATED'               : eventBase + 'created',
	        'MIME_TYPE_UNSUPPORTED' : eventBase + 'mimetypeUnsupported'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'metaData.';

	    return {
	        'BASE': eventBase,

	        'RECEIVED' : eventBase + 'received',
	        'ERROR'    : eventBase + 'error'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(36),
	        __webpack_require__(40),
	        __webpack_require__(23),
	        __webpack_require__(45)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (logger, conditions, listenerManager, connectionEvents, logicManagerEvents, networkStates, mimeType) {
	        function create (emitter) {
	            var l = logger.create('Connection');

	            var connectionServer = {
	                'websocket'   : '',
	                'hls'         : '',
	                'progressive' : ''
	            };
	            var connectionConfig = {
	                'url'    : '',
	                'stream' : '',
	                'cid'    : '',
	                'pid'    : '',
	                'token'  : ''
	            };
	            var securityConfig = null;
	            var connectionFlags = [];

	            var networkState;

	            var playerId;

	            var reconnectionImminent = false;
	            var metaDataEnabled = false;
	            var keepConnection = false;
	            var playing = true;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : logicManagerEvents.NETWORK_CONNECTING,            'listener' : onNetworkStateChange },
	                { 'type' : logicManagerEvents.NETWORK_CONNECTED,             'listener' : onNetworkStateChange },
	                { 'type' : logicManagerEvents.NETWORK_DISCONNECTED,          'listener' : onNetworkStateChange },
	                { 'type' : logicManagerEvents.NETWORK_RECONNECTING,          'listener' : onNetworkStateChange },
	                { 'type' : logicManagerEvents.NETWORK_RECONNECTION_IMMINENT, 'listener' : onNetworkStateChange },
	                { 'type' : logicManagerEvents.NETWORK_INITIALIZATION_ERROR,  'listener' : onNetworkStateChange },
	                { 'type' : logicManagerEvents.NETWORK_ERROR,                 'listener' : onNetworkStateChange },

	                { 'type' : logicManagerEvents.SERVER_INFO,                   'listener' : onServerInfo },
	                { 'type' : logicManagerEvents.CONFIG,                        'listener' : onConfig },
	                { 'type' : logicManagerEvents.API_PLAY,                      'listener' : onApiPlay },
	                { 'type' : logicManagerEvents.API_PAUSE,                     'listener' : onApiPause }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onNetworkStateChange (e) {
	                l.debug(
	                    e.name +
	                        ': network state change from ' +
	                        getNetworkState(networkState) +
	                        ' to ' +
	                        getNetworkState(e.connectionState)
	                );
	                networkState = e.connectionState;
	            }

	            function onServerInfo (e) {
	                if (keepConnection) {
	                    var caps = e.data.onServerInfo.capabilities;
	                    var version = e.data.onServerInfo.serverVersion;
	                    var floatVersion = parseFloat(version);
	                    if (caps.indexOf('onPlay') === -1 && caps.indexOf('onPause') === -1) {
	                        keepConnection = false;
	                        emitter.emit(connectionEvents.NO_KEEP_CONNECTION, {
	                            'message':
	                                floatVersion < 1.8
	                                    ? 'The keepConnection feature is enabled by the players config, but is not supported by this server version (' +
	                                      version +
	                                      '). Use at least server version 1.8.0.0. The feature will be disabled.'
	                                    : 'The keepConnection feature is enabled by the players config, but is not enabled by this server (' +
	                                      version +
	                                      '). The feature will be disabled.'
	                        });
	                        if (!playing) {
	                            disconnect();
	                        }
	                    }
	                }
	                emitter.emit(connectionEvents.SERVER_INFO, e.data);
	            }

	            function onConfig (e) {
	                var config = e.data.config;

	                setConnectionConfig(config.source.h5live);
	                setConnectionServer(config.source.h5live.server);
	                setSecurityConfig(config.source.h5live.security);

	                playerId = config.id;

	                metaDataEnabled = config.playback.metadata;
	                keepConnection = config.playback.keepConnection;
	                playing = config.playback.autoplay;

	                if (keepConnection) {
	                    connect();
	                }
	            }

	            function onApiPlay () {
	                playing = true;

	                if (networkState === networkStates.OPEN) {
	                    l.debug('send network play');
	                    emitter.emit(connectionEvents.NETWORK_PLAY);
	                }
	                else if (!reconnectionImminent) {
	                    connect();
	                }
	                if (conditions.useHLS) {
	                    var src =
	                        getConnectionServer('hls') + getConnectionConfig() + getSecurityConfig() + getConnectionFlags();
	                    emitter.emit(connectionEvents.VIDEO_SOURCE, {
	                        'src'  : src,
	                        'type' : mimeType.HLS
	                    });
	                    emitter.emit(connectionEvents.URL, { 'url': src });
	                }
	            }

	            function onApiPause () {
	                playing = false;
	                if (!keepConnection) {
	                    disconnect();
	                }
	                if (conditions.useHLS) {
	                    emitter.emit(connectionEvents.VIDEO_SOURCE, {
	                        'src'  : '',
	                        'type' : mimeType.HLS
	                    });
	                }
	            }

	            function connect () {
	                if (
	                    networkState !== networkStates.OPEN &&
	                    (metaDataEnabled || !!securityConfig || !conditions.useHLS)
	                ) {
	                    if (!playing) {
	                        setConnectionFlag('paused');
	                    }
	                    else {
	                        removeConnectionFlag('paused');
	                    }
	                    if (metaDataEnabled && conditions.useHLS) {
	                        setConnectionFlag('metastreamonly');
	                    }
	                    else {
	                        removeConnectionFlag('metastreamonly');
	                    }
	                    if (!metaDataEnabled && !!securityConfig && conditions.useHLS) {
	                        setConnectionFlag('checkandclose');
	                    }
	                    else {
	                        removeConnectionFlag('checkandclose');
	                    }

	                    var queryString = getConnectionConfig() + getSecurityConfig() + getConnectionFlags();
	                    var connectionServer = getConnectionServer('websocket');
	                    var url = connectionServer + '/' + queryString;

	                    l.debug('connect to: ' + url, 1);
	                    emitter.emit(connectionEvents.CONNECT, { 'url': url });
	                    if (!conditions.useHLS) {
	                        emitter.emit(connectionEvents.URL, { 'url': url });
	                    }
	                }
	            }

	            function disconnect () {
	                l.debug('disconnecting');
	                emitter.emit(connectionEvents.DISCONNECT);
	            }

	            function setConnectionServer (server) {
	                if (typeof server === 'object') {
	                    var types = ['websocket', 'hls', 'progressive'];
	                    for (var i = 0; i < types.length; i++) {
	                        if (server[types[i]] && typeof server[types[i]] === 'string' && 0 !== server[types[i]].length) {
	                            if (!connectionServer) {
	                                connectionServer = {};
	                            }
	                            connectionServer[types[i]] = server[types[i]];
	                        }
	                    }
	                    l.debug('set connection server: ' + JSON.stringify(connectionServer), 3);
	                }

	                if (typeof connectionServer === 'undefined') {
	                    emitter.emit(connectionEvents.NO_SERVER_ERROR);
	                }
	            }

	            function getConnectionServer (type) {
	                if (typeof connectionServer[type] === 'string' && 0 !== connectionServer[type].length) {
	                    l.debug('get connection server from type "' + type + '": ' + connectionServer[type], 3);
	                    return connectionServer[type];
	                }
	                else {
	                    emitter.emit(connectionEvents.NO_SERVER_ERROR);
	                    return '';
	                }
	            }

	            function setConnectionConfig (config) {
	                l.debug('set connection config', 3);
	                var rtmp = config.rtmp;
	                var params = config.params;
	                var key;
	                if (
	                    (typeof rtmp !== 'object' ||
	                        (!rtmp.url || !rtmp.url.length) ||
	                        (!rtmp.streamname || !rtmp.streamname.length)) &&
	                    !params
	                ) {
	                    emitter.emit(connectionEvents.MISSING_RTMP_ERROR);
	                }
	                else {
	                    for (key in rtmp)
	                        if (rtmp.hasOwnProperty(key)) {
	                            var mappedKey = key.replace('name', '');
	                            if (connectionConfig.hasOwnProperty(mappedKey)) {
	                                connectionConfig[mappedKey] = rtmp[key];
	                                l.debug('set connection config rtmp: ' + mappedKey + ':' + connectionConfig[mappedKey]);
	                            }
	                        }
	                }
	                if (config.token) {
	                    if (connectionConfig.hasOwnProperty('token')) {
	                        connectionConfig.token = config.token;
	                        l.debug('set connection config token: ' + connectionConfig.token);
	                    }
	                }
	                if (typeof params === 'object') {
	                    for (key in params)
	                        if (params.hasOwnProperty(key)) {
	                            connectionConfig[key] = params[key];
	                            l.debug('set connection param: ' + key + ':' + connectionConfig[key]);
	                        }
	                }
	            }

	            function setSecurityConfig (config) {
	                securityConfig = null;
	                if (config) {
	                    securityConfig = {};
	                    l.debug('set security config', 3);
	                    for (var key in config) {
	                        if (config.hasOwnProperty(key) && config[key].length) {
	                            securityConfig[key] = config[key];
	                            l.debug('set security config ' + key + ': ' + securityConfig[key]);
	                        }
	                    }
	                }
	            }

	            function getConnectionConfig () {
	                var queryString = '?';
	                for (var key in connectionConfig) {
	                    if (connectionConfig.hasOwnProperty(key)) {
	                        if (key === 'cid') {
	                            connectionConfig[key] = Math.round(Math.random() * 1000000).toString();
	                        }
	                        if (key === 'pid' && !connectionConfig[key].length) {
	                            connectionConfig[key] = playerId;
	                        }
	                        if (connectionConfig[key].length) {
	                            queryString += key + '=' + encodeURIComponent(connectionConfig[key]) + '&';
	                        }
	                    }
	                }
	                if (queryString.lastIndexOf('&') === queryString.length - 1) {
	                    queryString = queryString.substr(0, queryString.length - 1);
	                }
	                return queryString;
	            }

	            function getSecurityConfig () {
	                var queryString = '&';
	                for (var key in securityConfig) {
	                    if (securityConfig.hasOwnProperty(key) && securityConfig[key].length) {
	                        queryString += key + '=' + encodeURIComponent(securityConfig[key]) + '&';
	                    }
	                }
	                if (queryString.lastIndexOf('&') === queryString.length - 1) {
	                    queryString = queryString.substr(0, queryString.length - 1);
	                }
	                return queryString;
	            }

	            function setConnectionFlag (flag) {
	                if (connectionFlags.indexOf(flag) === -1) {
	                    connectionFlags.push(flag);
	                }
	            }

	            function removeConnectionFlag (flag) {
	                connectionFlags = connectionFlags.filter(function (item) {
	                    return item !== flag;
	                });
	            }

	            function getConnectionFlags () {
	                var flags = '';
	                var key = '&flags=';
	                for (var i = 0, len = connectionFlags.length; i < len; i += 1) {
	                    flags += connectionFlags[i];
	                    if (i === len - 1) {
	                        flags = key + encodeURIComponent(flags);
	                    }
	                    else {
	                        flags += ',';
	                    }
	                }
	                return flags;
	            }

	            function getNetworkState (state) {
	                for (var key in networkStates)
	                    if (networkStates.hasOwnProperty(key)) {
	                        if (networkStates[key] === state) {
	                            return key;
	                        }
	                    }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-10-10.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'MP4'    : 'video/mp4',
	        'MP4_MS' : 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
	        'HLS'    : 'application/vnd.apple.mpegURL'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(39),
	        __webpack_require__(40),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (logger, conditions, listenerManager, bufferControlEvents, logicManagerEvents, playerStates) {
	        function create (emitter) {
	            var l = logger.create('WSSLiveController');

	            var playerState;
	            var tweaks = {};
	            var stats;

	            var currentTime = 0;
	            var rapList = [];

	            var bufferEndLast = 0;

	            var playbackRate = 1;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : logicManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange },
	                { 'type' : logicManagerEvents.BUFFER_TWEAKS_CREATED,        'listener' : onBufferTweaksCreated },
	                { 'type' : logicManagerEvents.RANDOM_ACCESS_POINT,          'listener' : onRandomAccessPoint }
	            ];

	            // prettier-ignore
	            var playStateListeners = [
	                { 'type' : logicManagerEvents.PLAY_STATS,                   'listener' : onPlayStats }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onBufferTweaksCreated (e) {
	                tweaks.buffer = e.data.tweaks.buffer;
	            }

	            function onRandomAccessPoint (e) {
	                rapList.push(e.data.onRandomAccessPoint.streamTime / 1000);
	                while (rapList.length > 10) {
	                    rapList.shift();
	                }
	            }

	            function onApplicationStateChange (e) {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : playStateListeners
	                });
	                playerState = e.data.state;
	                switch (playerState) {
	                    case playerStates.PLAYING:
	                        listenerManager.add({
	                            'target'    : emitter,
	                            'listeners' : playStateListeners
	                        });
	                }
	            }

	            function onPlayStats (e) {
	                stats = e.data.stats;
	                playbackRate = e.data.playbackRate;
	                currentTime = e.data.currentTime;

	                if (!e.data.buffered || !e.data.buffered.length) {
	                    //TODO: remove need for buffered values
	                    return;
	                }

	                bufferEndLast = stats.buffer.end > bufferEndLast + 0.1 ? stats.buffer.end : bufferEndLast;

	                if (tweaks.buffer.max < stats.buffer.delay.current && stats.buffer.end > tweaks.buffer.min) {
	                    l.debug(
	                        'tweaks.buffer.max (' +
	                            tweaks.buffer.max +
	                            ') < stats.buffer.delay.current (' +
	                            stats.buffer.delay.current +
	                            ') && stats.buffer.end (' +
	                            stats.buffer.end +
	                            ') > tweaks.buffer.min (' +
	                            tweaks.buffer.min +
	                            ')'
	                    );
	                    setSeek(tweaks.buffer.target);
	                }
	                else if (tweaks.buffer.limit < stats.buffer.delay.current) {
	                    conditions.isIEorEdge ? setSeek(tweaks.buffer.target) : setSpeed(1.1);
	                }
	                else if (tweaks.buffer.target > stats.buffer.delay.current) {
	                    setSpeed(1.0);
	                }
	            }

	            function setSpeed (value) {
	                if (playbackRate !== value) {
	                    l.debug('set rate to ' + value);
	                    emitter.emit(bufferControlEvents.RATE, { 'rate': value });
	                }
	            }

	            function setSeek (value) {
	                var seekTo = bufferEndLast - value;

	                if (conditions.isIEorEdge) {
	                    seekTo = getRandomAccessPoint(currentTime, seekTo);
	                    if (seekTo < 0) return;
	                }

	                setTime(seekTo);
	            }

	            function setTime (value) {
	                l.debug('seeking to ' + value);
	                emitter.emit(bufferControlEvents.SEEK, { 'position': value });
	            }

	            function getRandomAccessPoint (currentTime, seekPosition) {
	                for (var i = 0; i < rapList.length; ++i) {
	                    if (rapList[i] > currentTime && rapList[i] <= seekPosition) {
	                        return rapList[i];
	                    }
	                }
	                return -1;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(39),
	        __webpack_require__(40),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (logger, conditions, listenerManager, bufferControlEvents, logicManagerEvents, playerStates) {
	        function create (emitter) {
	            var l = logger.create('HLSLiveController');

	            var playerState;
	            var useAuto = true;
	            var tweaks = {
	                'buffer': {
	                    'max'    : 8.0,
	                    'min'    : 0.2,
	                    'start'  : 0.5,
	                    'target' : 1.2,
	                    'limit'  : 1.7
	                }
	            };
	            var stats;

	            var playbackRate = 1;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : logicManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange },
	                { 'type' : logicManagerEvents.BUFFER_TWEAKS_CREATED,        'listener' : onBufferTweaksCreated }
	            ];

	            // prettier-ignore
	            var playStateListeners = [
	                { 'type' : logicManagerEvents.PLAY_STATS,                   'listener' : onPlayStats }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onBufferTweaksCreated (e) {
	                for (var key in e.data.tweaks.buffer) {
	                    if (e.data.tweaks.buffer[key] !== tweaks.buffer[key]) {
	                        useAuto = false;
	                    }
	                }
	                if (!useAuto) {
	                    tweaks.buffer = e.data.tweaks.buffer;
	                }
	            }

	            function onApplicationStateChange (e) {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : playStateListeners
	                });
	                playerState = e.data.state;
	                switch (playerState) {
	                    case playerStates.PLAYING:
	                        listenerManager.add({
	                            'target'    : emitter,
	                            'listeners' : playStateListeners
	                        });
	                }
	            }

	            function onPlayStats (e) {
	                stats = e.data.stats;
	                playbackRate = e.data.playbackRate;

	                if (!e.data.buffered || !e.data.buffered.length) {
	                    //TODO: remove need for buffered values
	                    return;
	                }

	                if (!useAuto) {
	                    if (tweaks.buffer.limit < stats.buffer.delay.avg) {
	                        setSpeed(1.1);
	                    }
	                    else if (tweaks.buffer.start < stats.buffer.delay.avg <= tweaks.buffer.target) {
	                        setSpeed(1.0);
	                    }
	                    else if (tweaks.buffer.min >= stats.buffer.delay.avg) {
	                        setSpeed(0.9);
	                    }
	                }
	                else if (
	                    stats.buffer.update.avg > 0 &&
	                    stats.buffer.update.avg + tweaks.buffer.limit - 0.7 < stats.buffer.delay.avg
	                ) {
	                    setSpeed(1.1);
	                }
	                else if (
	                    stats.buffer.update.avg > 0 &&
	                    stats.buffer.update.avg + tweaks.buffer.min <
	                        stats.buffer.delay.avg <=
	                        stats.buffer.update.avg + tweaks.buffer.target - 0.7
	                ) {
	                    setSpeed(1.0);
	                }
	                else if (stats.buffer.update.avg >= 0 && stats.buffer.update.avg >= stats.buffer.delay.avg) {
	                    setSpeed(0.9);
	                }
	            }

	            function setSpeed (value) {
	                if (playbackRate !== value) {
	                    l.debug('set rate to: ' + value);
	                    emitter.emit(bufferControlEvents.RATE, { 'rate': value });
	                }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(40),
	        __webpack_require__(42),
	        __webpack_require__(9),
	        __webpack_require__(49),
	        __webpack_require__(45)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        listenerManager,
	        logicManagerEvents,
	        streamInfoEvents,
	        playerStates,
	        streamInfoProperties,
	        mimeTypes
	    ) {
	        function create (emitter) {
	            var l = logger.create('StreamInfo');

	            var playerState;

	            var streamInfo, streamUrl;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : logicManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange },
	                { 'type' : logicManagerEvents.STREAM_INFO,                  'listener' : onStreamInfo },
	                { 'type' : logicManagerEvents.STREAM_URL,                   'listener' : onStreamUrl },
	                { 'type' : logicManagerEvents.CAN_PLAY,                     'listener' : onCanPlay }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onApplicationStateChange (e) {
	                playerState = e.data.state;
	            }

	            function onStreamUrl (e) {
	                streamUrl = e.data.url;
	            }

	            function onStreamInfo (e) {
	                if (playerState === playerStates.READY) return;
	                streamInfo = e.data.onStreamInfo;
	                var mime = streamInfo && streamInfo.mimeType ? streamInfo.mimeType : mimeTypes.MP4_MS;
	                if (!window.MediaSource.isTypeSupported(mime)) {
	                    emitter.emit(streamInfoEvents.MIME_TYPE_UNSUPPORTED);
	                }
	                else {
	                    var info = {},
	                        excludes = [streamInfoProperties.PREROLL_DURATION, streamInfoProperties.MIME_TYPE];
	                    for (var key in streamInfoProperties)
	                        if (streamInfoProperties.hasOwnProperty(key)) {
	                            var prop = streamInfoProperties[key];
	                            if (
	                                streamInfoProperties.hasOwnProperty(key) &&
	                                streamInfo.hasOwnProperty(prop) &&
	                                excludes.indexOf(prop) === -1
	                            ) {
	                                info[prop] = streamInfo[prop];
	                            }
	                        }
	                    streamInfo = info;
	                    streamInfo.url = streamUrl;
	                    emitter.emit(streamInfoEvents.CREATED, { 'streamInfo': streamInfo });
	                }
	            }

	            function onCanPlay (e) {
	                if (conditions.useHLS && playerState === playerStates.LOADING) {
	                    streamInfo = {
	                        'haveAudio' : e.data.haveAudio,
	                        'haveVideo' : e.data.haveVideo,
	                        'audioInfo' : e.data.haveAudio
	                            ? {
	                                'bitsPerSample' : null,
	                                'channels'      : null,
	                                'sampleRate'    : null
	                            }
	                            : null,
	                        'videoInfo': e.data.haveVideo
	                            ? {
	                                'width'     : e.data.videoWidth,
	                                'height'    : e.data.videoHeight,
	                                'frameRate' : null
	                            }
	                            : null
	                    };
	                    streamInfo.url = streamUrl;
	                    emitter.emit(streamInfoEvents.CREATED, { 'streamInfo': streamInfo });
	                }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by thomas.niedergesaess on 4/3/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'HAVE_VIDEO'       : 'haveVideo',
	        'HAVE_AUDIO'       : 'haveAudio',
	        'VIDEO_INFO'       : 'videoInfo',
	        'AUDIO_INFO'       : 'audioInfo',
	        'PREROLL_DURATION' : 'prerollDuration',
	        'MIME_TYPE'        : 'mimeType'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(39),
	        __webpack_require__(40),
	        __webpack_require__(41),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        listenerManager,
	        bufferControlEvents,
	        logicManagerEvents,
	        timeoutEvents,
	        playerStates
	    ) {
	        var LOADING_TIMEOUT_DELAY = 20000;
	        var BUFFERING_TIMEOUT_DELAY = 20000;

	        function create (emitter) {
	            var l = logger.create('Timeout');

	            var playerState;

	            var loadingTimeout;
	            var bufferingTimeout;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : logicManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                clearTimeout(loadingTimeout);
	                clearTimeout(bufferingTimeout);

	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onApplicationStateChange (e) {
	                playerState = e.data.state;
	                switch (playerState) {
	                    case playerStates.READY:
	                    case playerStates.PLAYING:
	                    case playerStates.PAUSED:
	                        clearTimeout(loadingTimeout);
	                        clearTimeout(bufferingTimeout);
	                        break;
	                }

	                if (playerState === playerStates.BUFFERING) {
	                    setBufferingTimeout();
	                }
	                else {
	                    clearTimeout(bufferingTimeout);
	                }
	                if (playerState === playerStates.LOADING) {
	                    setLoadingTimeout(e.data.connectDelay);
	                }
	            }

	            function setBufferingTimeout () {
	                clearTimeout(bufferingTimeout);
	                bufferingTimeout = setTimeout(function () {
	                    emitter.emit(timeoutEvents.BUFFERING_TIMEOUT);
	                }, BUFFERING_TIMEOUT_DELAY);
	            }

	            function setLoadingTimeout (delay) {
	                clearTimeout(loadingTimeout);
	                loadingTimeout = setTimeout(function () {
	                    emitter.emit(timeoutEvents.LOADING_TIMEOUT);
	                }, LOADING_TIMEOUT_DELAY + delay);
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(14),
	        __webpack_require__(9),
	        __webpack_require__(40),
	        __webpack_require__(43)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (logger, conditions, listenerManager, errorCodes, playerStates, logicManagerEvents, metaDataEvents) {
	        function create (emitter) {
	            var l = logger.create('MetaData');

	            var playerState;
	            var metaDataAccepted, metaData, metaDataArray, metaDataTempArray, metaDataTimeOffset;

	            var currentTime;

	            /* eslint-disable */
	            // prettier-ignore
	            var stateListener = [
	                { 'type' : logicManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange }
	            ];
	            // prettier-ignore
	            var metaDataListeners = [
	                { 'type' : logicManagerEvents.META_DATA,                    'listener' : onMetaData },
	                { 'type' : logicManagerEvents.PLAY_STATS,                   'listener' : onPlayStats },
	                { 'type' : logicManagerEvents.NETWORK_CONNECTED,            'listener' : onConnected }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('init');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : stateListener
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : stateListener
	                });
	            }

	            function reset () {
	                (currentTime = 0.0),
	                (metaDataAccepted = true),
	                (metaData = {
	                    'handlerName' : '',
	                    'streamTime'  : 0,
	                    'message'     : []
	                }),
	                (metaDataArray = []),
	                (metaDataTempArray = []),
	                (metaDataTimeOffset = 0);
	            }

	            // listen only during necessary player states
	            function onApplicationStateChange (e) {
	                playerState = e.data.state;
	                switch (playerState) {
	                    case playerStates.LOADING:
	                        reset();
	                        listenerManager.add({
	                            'target'    : emitter,
	                            'listeners' : metaDataListeners
	                        });
	                        break;
	                    case playerStates.PAUSING:
	                        listenerManager.remove({
	                            'target'    : emitter,
	                            'listeners' : metaDataListeners
	                        });
	                        break;
	                    default:
	                        break;
	                }
	            }

	            function onMetaData (e) {
	                l.debug('onMetaData');
	                var obj = e.data[e.data.eventType];
	                if (obj.chunkIndex === 1) {
	                    if (typeof metaData.message.push === 'function' && metaData.message.length !== 0) {
	                        emitter.emit(metaDataEvents.ERROR, {
	                            'code'    : errorCodes.STREAM.METADATA_STILL_PROCESSING,
	                            'message' :
	                                'Received metadata with start index but currently process another. Discard old one.'
	                        });
	                    }
	                    metaDataAccepted = true;
	                    metaData = {
	                        'handlerName' : obj.handlerName,
	                        'streamTime'  : obj.streamTime,
	                        'message'     : []
	                    };
	                }
	                else if (metaData.message.length === 0 || typeof metaData.message.push !== 'function') {
	                    if (metaDataAccepted) {
	                        emitter.emit(metaDataEvents.ERROR, {
	                            'code'    : errorCodes.STREAM.METADATA_NO_START_INDEX,
	                            'message' : 'Received metadata but no start index. Discard.'
	                        });
	                        metaDataAccepted = false;
	                        metaData.message = [];
	                    }
	                    return;
	                }
	                else if (!metaDataAccepted) {
	                    return;
	                }
	                metaData.message.push(obj.message);
	                if (metaData.message.length !== obj.chunkIndex) {
	                    if (metaDataAccepted) {
	                        emitter.emit(metaDataEvents.ERROR, {
	                            'code'    : errorCodes.STREAM.METADATA_WRONG_INDEX,
	                            'message' : 'Received metadata with wrong index. Discard.'
	                        });
	                        metaDataAccepted = false;
	                        metaData.message = [];
	                    }
	                }
	                else if (obj.chunkCount - obj.chunkIndex === 0) {
	                    try {
	                        var meta = metaData.message.join('');
	                        var handlerName = metaData.handlerName;
	                        l.debug('handlerName=' + handlerName + ', metaData=' + meta);
	                        meta = JSON.parse(meta);
	                        metaData.message = meta;

	                        // copy metadata
	                        var metaDataComplete = {
	                            'handlerName' : metaData.handlerName,
	                            'streamTime'  : metaData.streamTime,
	                            'message'     : metaData.message
	                        };

	                        metaDataArray.push(metaDataComplete);
	                    }
	                    catch (e) {
	                        emitter.emit(metaDataEvents.ERROR, {
	                            'code'    : errorCodes.STREAM.METADATA_INVALID_JSON,
	                            'message' : 'Received metadata with invalid json string.'
	                        });
	                    }
	                }
	            }

	            function onPlayStats (e) {
	                currentTime = e.data.currentTime;
	                while (metaDataArray.length) {
	                    var md = metaDataArray.shift();
	                    var delay = conditions.useHLS && e.data.stats.buffer.delay.avg ? e.data.stats.buffer.delay.avg : 0;
	                    if (md.streamTime + metaDataTimeOffset + delay <= currentTime) {
	                        md.streamTime += metaDataTimeOffset + delay;
	                        emitter.emit(metaDataEvents.RECEIVED, md);
	                    }
	                    else {
	                        metaDataTempArray.push(md);
	                    }
	                }
	                while (metaDataTempArray.length) {
	                    metaDataArray.push(metaDataTempArray.shift());
	                }
	            }

	            function onConnected () {
	                metaDataTimeOffset = playerState === playerStates.PLAYING && conditions.useHLS ? currentTime : 0;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(6),
	        __webpack_require__(24),
	        __webpack_require__(28),
	        __webpack_require__(31),
	        __webpack_require__(37),
	        __webpack_require__(53),
	        __webpack_require__(54),
	        __webpack_require__(55),
	        __webpack_require__(56),
	        __webpack_require__(57)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        EventEmitter,
	        listenerManager,
	        controlEvents,
	        networkEvents,
	        eventTranslator,
	        networkManagerEvents,
	        messageHandlerEvents,
	        websocketEvents,
	        messageHandler,
	        webSocket
	    ) {
	        'use strict';

	        function create (publicEmitter) {
	            var privateEmitter = new EventEmitter(),
	                inwardTranslator,
	                outwardTranslator,
	                components = [],
	                /* eslint-disable */
	                // prettier-ignore
	                outwardEvents = [
	                    { 'from' : websocketEvents.CONNECTING,                  'to' : networkEvents.CONNECTING },
	                    { 'from' : websocketEvents.CONNECTED,                   'to' : networkEvents.CONNECTED },
	                    { 'from' : websocketEvents.RESUMING,                    'to' : networkEvents.RESUMING },
	                    { 'from' : websocketEvents.DESTROYED,                   'to' : networkEvents.DESTROYED },
	                    { 'from' : websocketEvents.RECONNECTING,                'to' : networkEvents.RECONNECTING },
	                    { 'from' : websocketEvents.RECONNECTION_IMMINENT,       'to' : networkEvents.RECONNECTION_IMMINENT },
	                    { 'from' : websocketEvents.RECONNECTION_CONFIG_INVALID, 'to' : networkEvents.RECONNECTION_CONFIG_INVALID },
	                    { 'from' : websocketEvents.DISCONNECTED,                'to' : networkEvents.DISCONNECTED },
	                    { 'from' : websocketEvents.INITIALIZATION_ERROR,        'to' : networkEvents.INITIALIZATION_ERROR },
	                    { 'from' : websocketEvents.ERROR,                       'to' : networkEvents.ERROR },

	                    { 'from' : messageHandlerEvents.META_DATA,              'to' : networkEvents.META_DATA },
	                    { 'from' : messageHandlerEvents.RANDOM_ACCESS_POINT,    'to' : networkEvents.RANDOM_ACCESS_POINT },
	                    { 'from' : messageHandlerEvents.SERVER_INFO,            'to' : networkEvents.SERVER_INFO },
	                    { 'from' : messageHandlerEvents.STREAM_INFO,            'to' : networkEvents.STREAM_INFO },
	                    { 'from' : messageHandlerEvents.RAW_PACKET,             'to' : networkEvents.RAW_PACKET },
	                    { 'from' : messageHandlerEvents.STREAM_FRAGMENT,        'to' : networkEvents.STREAM_FRAGMENT }
	                ],
	                // prettier-ignore
	                inwardEvents = [
	                    { 'from' : controlEvents.CONNECT,                       'to' : networkManagerEvents.CONNECT },
	                    { 'from' : controlEvents.DISCONNECT,                    'to' : networkManagerEvents.DISCONNECT },
	                    { 'from' : controlEvents.NETWORK_PLAY,                  'to' : networkManagerEvents.PLAY },
	                    { 'from' : controlEvents.PAUSE,                         'to' : networkManagerEvents.PAUSE },
	                    { 'from' : controlEvents.CONFIG,                        'to' : networkManagerEvents.CONFIG }
	                ];
	            /* eslint-disable */

	            function init() {
	                inwardTranslator = eventTranslator.create(publicEmitter, privateEmitter, inwardEvents);
	                outwardTranslator = eventTranslator.create(privateEmitter, publicEmitter, outwardEvents);

	                components.push(webSocket.create(privateEmitter));
	                components.push(messageHandler.create(privateEmitter));
	            }

	            function destroy() {
	                inwardTranslator.destroy();
	                inwardTranslator = null;
	                outwardTranslator.destroy();
	                outwardTranslator = null;

	                while (components.length) {
	                    components.pop().destroy();
	                }
	            }

	            init();

	            return {
	                destroy: destroy
	            };
	        }
	        return {
	            create: create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'networkmanager.';

	    return {
	        'BASE': eventBase,

	        'CONNECT'    : eventBase + 'connect',
	        'DISCONNECT' : eventBase + 'disconnect',
	        'PLAY'       : eventBase + 'play',
	        'PAUSE'      : eventBase + 'pause',
	        'CONFIG'     : eventBase + 'config'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'message.';

	    return {
	        'BASE': eventBase,

	        'META_DATA'           : eventBase + 'metaData',
	        'SERVER_INFO'         : eventBase + 'serverInfo',
	        'STREAM_INFO'         : eventBase + 'streamInfo',
	        'STREAM_FRAGMENT'     : eventBase + 'streamFragment',
	        'RANDOM_ACCESS_POINT' : eventBase + 'randomAccessPoint',
	        'RAW_PACKET'          : eventBase + 'raw'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'wss.';

	    return {
	        'BASE': eventBase,

	        'CONNECTING'                  : eventBase + 'connecting',
	        'CONNECTED'                   : eventBase + 'connected',
	        'DISCONNECTED'                : eventBase + 'disconnected',
	        'RESUMING'                    : eventBase + 'resuming',
	        'MESSAGE'                     : eventBase + 'message',
	        'RECONNECTION_IMMINENT'       : eventBase + 'reconnectionImminent',
	        'RECONNECTING'                : eventBase + 'reconnecting',
	        'RECONNECTION_CONFIG_INVALID' : eventBase + 'reconnectionConfigInvalid',
	        'CONNECTION_ERROR'            : eventBase + 'connectionError',
	        'INITIALIZATION_ERROR'        : eventBase + 'initializationError',
	        'DESTROYED'                   : eventBase + 'destroyed',
	        'ERROR'                       : eventBase + 'error',
	        'STATE_CHANGE'                : eventBase + 'stateChange'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(24),
	        __webpack_require__(54),
	        __webpack_require__(55)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (listenerManager, messageHandlerEvents, websocketEvents) {
	        'use strict';

	        function create (emitter) {
	            var buffers = [];
	            var bufferSize = 0;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : websocketEvents.MESSAGE,     'listener' : onWebsocketMessage }
	            ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onWebsocketMessage (event) {
	                if (!event) {
	                    return;
	                }
	                var data = event.data;
	                if (typeof data === 'string') {
	                    var parsedData = JSON.parse(data);
	                    if (parsedData && parsedData.eventType) {
	                        var name = parsedData.eventType.substr(2, parsedData.eventType.length - 2);
	                        var eventName = messageHandlerEvents.BASE + name[0].toLowerCase() + name.slice(1);

	                        if (eventName === messageHandlerEvents.STREAM_INFO) {
	                            reset();
	                        }
	                        emitter.emit(eventName, parsedData);
	                    }
	                }
	                else if (data instanceof ArrayBuffer && data.byteLength > 0) {
	                    var array = new Uint8Array(data);

	                    emitter.emit(messageHandlerEvents.RAW_PACKET);

	                    //TODO: parse incoming data, and dispatch before the next packet (dont wait for the next fragment to start)
	                    if (
	                        data.byteLength >= 8 &&
	                        0x6d === array[4] &&
	                        0x6f === array[5] &&
	                        0x6f === array[6] &&
	                        0x66 === array[7]
	                    ) {
	                        var outArray = new Uint8Array(bufferSize);
	                        var sizeWritten = 0;

	                        for (var i = 0; i < buffers.length; i++) {
	                            outArray.set(buffers[i], sizeWritten);
	                            sizeWritten += buffers[i].length;
	                        }
	                        reset();
	                        emitter.emit(messageHandlerEvents.STREAM_FRAGMENT, outArray);
	                    }

	                    buffers.push(array);
	                    bufferSize += data.byteLength;
	                }
	            }

	            function reset () {
	                while (buffers.length) {
	                    buffers.pop();
	                }
	                bufferSize = 0;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }
	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(18),
	        __webpack_require__(24),
	        __webpack_require__(23),
	        __webpack_require__(53),
	        __webpack_require__(55),
	        __webpack_require__(58),
	        __webpack_require__(59),
	        __webpack_require__(60)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        objectUtils,
	        listenerManager,
	        networkState,
	        networkManagerEvents,
	        websocketEvents,
	        configValidator,
	        delayCalculator,
	        urlParser
	    ) {
	        var l = logger.create('websocket');

	        function create (emitter) {
	            var recoverableCodes = [
	                1002, //An endpoint is terminating the connection due to a protocol error
	                1003, //An endpoint is terminating the connection because it has received a type of data it cannot accept
	                1005, //No status code was actually present
	                1006, //Maybe no network, wrong url or server down
	                1007, //An endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message
	                1008, //An endpoint is terminating the connection because it has received a message that "violates its policy"
	                1009, //An endpoint is terminating the connection because it has received a message that is too big for it to process.
	                1011, //A server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
	                1015, //The connection was closed due to a failure to perform a TLS handshake.
	                4500, //The connection has been rejected due an internal server error.
	                4503 //Service unavailable.
	            ];

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : networkManagerEvents.CONNECT,        'listener' : onConnect },
	                { 'type' : networkManagerEvents.DISCONNECT,     'listener' : onDisconnect },
	                { 'type' : networkManagerEvents.PLAY,           'listener' : onPlay },
	                { 'type' : networkManagerEvents.PAUSE,          'listener' : onPause },
	                { 'type' : networkManagerEvents.CONFIG,         'listener' : onConfig }
	            ];
	            /* eslint-enable */

	            var connection = null,
	                connectionState = networkState.UNINITIALIZED;
	            var connectionOpenTimeout = 0;
	            var connectionRetryTimeout;
	            var reconnectionInitTimeout;
	            var pingInterval = 0,
	                PING_INTERVAL_TIME = 50000,
	                usePing = false;

	            var waitForReconnect = false;

	            var reconnect = {
	                'minDelay'   : 2,
	                'maxDelay'   : 10,
	                'delaySteps' : 10,
	                'maxRetries' : 10,

	                // private
	                'delays'       : [],
	                'retryCount'   : 0,
	                'randomFactor' : 1.5
	            };

	            var connectData;

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                l.debug('destroy');
	                resetConnection();
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            //
	            // emitter listeners
	            //

	            function onConnect (e) {
	                //TODO: validate event structure in every listener, or find solution to enforce data structure

	                waitForReconnect = false;
	                clearTimeout(connectionRetryTimeout);
	                connectData = e.data;
	                connectData.count = reconnect.retryCount;
	                try {
	                    createConnection(connectData.url);
	                    emitter.emit(
	                        e.name ? websocketEvents.CONNECTING : websocketEvents.RECONNECTING,
	                        payload(connectData)
	                    );
	                }
	                catch (err) {
	                    emitter.emit(websocketEvents.INITIALIZATION_ERROR, payload(parseExeptionError(err)));
	                }
	            }

	            function onPlay () {
	                //TODO: validate event structure in every listener, or find solution to enforce data structure

	                try {
	                    connectData = urlParser.create(connectData, false);
	                    if (connection === null) {
	                        createConnection(connectData.url);
	                    }
	                    else {
	                        l.debug('sending play to server');
	                        sendCommand('onPlay');
	                        emitter.emit(websocketEvents.RESUMING, payload());
	                    }
	                }
	                catch (err) {
	                    emitter.emit(websocketEvents.ERROR, payload(parseExeptionError(err)));
	                }
	            }

	            function onPause () {
	                //TODO: validate event structure in every listener, or find solution to enforce data structure
	                try {
	                    if (connection !== null) {
	                        l.debug('sending pause to server');
	                        connectData = urlParser.create(connectData, true);
	                        sendCommand('onPause');
	                    }
	                }
	                catch (err) {
	                    emitter.emit(websocketEvents.ERROR, payload(parseExeptionError(err)));
	                }
	            }

	            function onPing () {
	                try {
	                    if (connection !== null && usePing) {
	                        l.debug('sending ping to server');
	                        sendCommand('onPing');
	                    }
	                }
	                catch (err) {
	                    emitter.emit(websocketEvents.ERROR, payload(parseExeptionError(err)));
	                }
	            }

	            function onConfig (e) {
	                //TODO: validate event structure in every listener, or find solution to enforce data structure
	                if (e.data.config.playback.reconnect) {
	                    var valid = configValidator.validate(e.data.config.playback.reconnect);
	                    if (!valid.success) {
	                        emitter.emit(websocketEvents.RECONNECTION_CONFIG_INVALID, payload({ 'reason': valid.reason }));
	                    }
	                    else {
	                        for (var key in e.data.config.playback.reconnect) {
	                            if (e.data.config.playback.reconnect.hasOwnProperty(key)) {
	                                reconnect[key] = e.data.config.playback.reconnect[key];
	                            }
	                        }
	                    }
	                }
	                // disable that for first, will be implemented in server
	                //usePing = e.data.config.playback.metadata && conditions.useHLS;
	            }

	            function onDisconnect () {
	                //TODO: validate event structure in every listener, or find solution to enforce data structure
	                //close connection by deleting
	                destroyConnection();
	            }

	            //
	            // connection listeners
	            //

	            function onConnectionOpen () {
	                setTimeout(function () {
	                    if (waitForReconnect || connection === null) {
	                        return;
	                    }
	                    clearTimeout(connectionOpenTimeout);
	                    if (usePing) {
	                        pingInterval = setInterval(onPing, PING_INTERVAL_TIME);
	                    }
	                    emitter.emit(websocketEvents.CONNECTED, payload({ 'count': reconnect.retryCount }));
	                    reconnect.retryCount = 0;
	                }, 200);
	            }

	            function onConnectionClose (e) {
	                clearTimeout(connectionOpenTimeout);
	                clearInterval(pingInterval);
	                var event = e;
	                if (conditions.isIEorEdge && e.code === 1005) {
	                    event = objectUtils.copy(e);
	                    event.code = parseInt(e.reason.split(' ')[1]); // e.g. 'Status: 4903 Security Error'
	                }
	                if (event.code === 4200) {
	                    destroyConnection('silent');
	                }
	                else {
	                    initReconnection(event, websocketEvents.DISCONNECTED, payload({ 'code': event.code }));
	                }
	            }

	            function onConnectionMessage (e) {
	                emitter.emit(websocketEvents.MESSAGE, payload(e.data));
	            }

	            function onConnectionError (e) {
	                clearTimeout(reconnectionInitTimeout);
	                reconnectionInitTimeout = setTimeout(function () {
	                    if (waitForReconnect || connection === null) {
	                        return;
	                    }
	                    clearTimeout(connectionOpenTimeout);
	                    initReconnection(e, websocketEvents.CONNECTION_ERROR, payload(e));
	                }, 200);
	            }

	            function onConnectionTimeout () {
	                if (waitForReconnect || connection === null) {
	                    return;
	                }
	                initReconnection(
	                    null,
	                    websocketEvents.INITIALIZATION_ERROR,
	                    payload({ 'message': 'Could not open connection. Timeout reached.' })
	                );
	            }

	            //
	            // private
	            //

	            function initReconnection (e, failureName, failureData) {
	                if (waitForReconnect) {
	                    return;
	                }
	                clearTimeout(connectionRetryTimeout);
	                connectionRetryTimeout = 0;

	                if (
	                    ((e && e.data && recoverableCodes.indexOf(e.data.code) !== -1) ||
	                        (failureData && failureData.data && recoverableCodes.indexOf(failureData.data.code) !== -1)) &&
	                    reconnect.retryCount < reconnect.maxRetries
	                ) {
	                    waitForReconnect = true;
	                    if (!reconnect.retryCount) {
	                        while (reconnect.delays.length) {
	                            reconnect.delays.pop();
	                        }
	                        reconnect.delays = delayCalculator.calculate(
	                            reconnect.minDelay,
	                            reconnect.maxDelay,
	                            reconnect.delaySteps,
	                            reconnect.maxRetries,
	                            reconnect.randomFactor
	                        );
	                    }
	                    var delay = reconnect.delays[reconnect.retryCount];
	                    reconnect.retryCount++;
	                    var data = connectData;
	                    data.count = reconnect.retryCount;
	                    connectionRetryTimeout = setTimeout(onConnect.bind(null, { 'data': data }), delay);
	                    var code = e && e.data && e.data.code ? e.data.code : e && e.code ? e.code : 0;
	                    if (code) {
	                        code =
	                            failureData && failureData.data && failureData.data.code
	                                ? failureData.data.code
	                                : failureData && failureData.code ? failureData.code : 0;
	                    }
	                    emitter.emit(websocketEvents.RECONNECTION_IMMINENT, {
	                        'delay' : delay,
	                        'count' : reconnect.retryCount,
	                        'code'  : code
	                    });
	                }
	                else {
	                    emitter.emit(failureName, failureData);
	                }
	            }

	            function createConnection (url) {
	                resetConnection();
	                connection = new WebSocket(url);
	                connection.binaryType = 'arraybuffer';
	                connection.onopen = onConnectionOpen;
	                connection.onclose = onConnectionClose;
	                connection.onmessage = onConnectionMessage;
	                connection.onerror = onConnectionError;
	                connectionOpenTimeout = setTimeout(onConnectionTimeout, 5000);
	            }

	            function destroyConnection (silent) {
	                resetConnection();
	                emitter.emit(websocketEvents.DESTROYED, payload(silent));
	            }

	            function resetConnection () {
	                clearTimeout(connectionOpenTimeout);
	                clearTimeout(connectionRetryTimeout);
	                clearTimeout(reconnectionInitTimeout);
	                clearInterval(pingInterval);

	                if (connection !== null) {
	                    connection.onopen = null;
	                    connection.onclose = null;
	                    connection.onmessage = null;
	                    connection.onerror = null;
	                    connection.close();
	                    connection = null;
	                }
	            }

	            function sendCommand (eventType) {
	                connection.send('{"eventType":"' + eventType + '", "' + eventType + '":{}}');
	            }

	            function parseExeptionError (err) {
	                return {
	                    'code'    : err.code,
	                    'name'    : err.name,
	                    'message' : err.message
	                };
	            }

	            function getState () {
	                if (connection !== null) {
	                    connectionState = connection.readyState + 2;
	                }
	                else {
	                    connectionState = networkState.UNINITIALIZED;
	                }
	                return connectionState;
	            }

	            function payload (data) {
	                return {
	                    'connectionState' : getState(),
	                    'data'            : data || undefined
	                };
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function validate (reconnect) {
	        var typed = ['minDelay', 'maxDelay', 'delaySteps', 'maxRetries'];

	        for (var i = 0; i < typed.length; ++i) {
	            if (!reconnect.hasOwnProperty(typed[i])) {
	                return {
	                    'success' : false,
	                    'reason'  :
	                        'The reconnect config is invalid, it must contain \'minDelay\', \'maxDelay\', \'delaySteps\', and \'maxRetries\'. Reset to default.'
	                };
	            }
	            if (typeof reconnect[typed[i]] !== 'number') {
	                return {
	                    'success' : false,
	                    'reason'  :
	                        'The reconnect config is invalid, the value \'' +
	                        typed[i] +
	                        '\' have to be a number. Reset to default.'
	                };
	            }
	        }

	        if (reconnect[typed[0]] > reconnect[typed[1]]) {
	            return {
	                'success' : false,
	                'reason'  :
	                    'The reconnect config is invalid, the value \'' +
	                    typed[0] +
	                    '\' have to be lower then \'' +
	                    typed[1] +
	                    '\'. Reset to default.'
	            };
	        }

	        if (reconnect[typed[0]] < 1) {
	            return {
	                'success' : false,
	                'reason'  :
	                    'The reconnect config is invalid, the value \'' +
	                    typed[0] +
	                    '\' have to be greater or equal then 1 sec. Reset to default.'
	            };
	        }

	        return { 'success': true };
	    }

	    return {
	        'validate': validate
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function calculate (minDelay, maxDelay, delaySteps, maxRetries, randomFactor) {
	        var delays = [];
	        var sqMin = Math.sqrt(minDelay);
	        var sqMax = Math.sqrt(maxDelay);

	        if (delaySteps > maxRetries) {
	            delaySteps = maxRetries;
	        }

	        var stepLength = (sqMax - sqMin) / (delaySteps - 1);

	        for (var i = 0; i < maxRetries; i += 1) {
	            var random = randomFactor * (Math.random() - 0.5);
	            var factor =
	                sqMin +
	                stepLength * Math.min(delaySteps - 1, i) +
	                (!i && sqMin - Math.abs(random) <= 0.5 ? Math.abs(random) + randomFactor * Math.random() : random);
	            var delay = Math.round(factor * factor * 1000);
	            delays.push(delay);
	        }

	        return delays;
	    }

	    return {
	        'calculate': calculate
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function create (data, paused) {
	        var array = data.url.split('&flags=');
	        if (array.length > 1) {
	            array[1] = decodeURIComponent(array[1]);
	        }
	        if (paused) {
	            if (array.length > 1 && array[1].indexOf('paused') === -1) {
	                data.url = array[0] + '&flags=' + encodeURIComponent('paused,' + array[1]);
	            }
	            else if (array.length === 1) {
	                data.url += '&flags=paused';
	            }
	        }
	        else if (array.length > 1 && array[1].indexOf('paused') !== -1) {
	            var flags = array[1].split(',');
	            if (flags.length === 1) {
	                data.url = data.url.replace('&flags=paused', '');
	            }
	            else {
	                data.url = array[0] + '&flags=';
	                for (var i = 0; i < flags.length; i += 1) {
	                    if (flags[i] !== 'paused') {
	                        data.url += encodeURIComponent(flags[i]);
	                        data.url += encodeURIComponent(flags.length > 2 && i < flags.length - 1 ? ',' : '');
	                    }
	                }
	            }
	        }
	        return data;
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(6),
	        __webpack_require__(11),
	        __webpack_require__(24),
	        __webpack_require__(37),
	        __webpack_require__(45),
	        __webpack_require__(28),
	        __webpack_require__(30),
	        __webpack_require__(29),
	        __webpack_require__(31),
	        __webpack_require__(63),
	        __webpack_require__(64),
	        __webpack_require__(65),
	        __webpack_require__(66),
	        __webpack_require__(67),
	        __webpack_require__(62),
	        __webpack_require__(68),
	        __webpack_require__(69),
	        __webpack_require__(70),
	        __webpack_require__(71),
	        __webpack_require__(72),
	        __webpack_require__(75),
	        __webpack_require__(78),
	        __webpack_require__(82),
	        __webpack_require__(83),
	        __webpack_require__(84),
	        __webpack_require__(85),
	        __webpack_require__(87),
	        __webpack_require__(88),
	        __webpack_require__(89),
	        __webpack_require__(90)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        EventEmitter,
	        browserInfo,
	        listenerManager,
	        eventTranslator,
	        mimeType,
	        controlEvents,
	        logicEvents,
	        mediaEvents,
	        networkEvents,
	        bufferControlEvents,
	        handlerEvents,
	        mediaControlEvents,
	        mediaElementProxyEvents,
	        mediaSourceManagerEvents,
	        mediaManagerEvents,
	        qualityHandlerEvents,
	        statsCollectorEvents,
	        bufferTweakerEvents,
	        bufferControl,
	        bufferTweaker,
	        mediaElementProxy,
	        mediaSourceManager,
	        fakeAudioContext,
	        gapHandler,
	        hlsJumpHandler,
	        pauseHandler,
	        qualityHandler,
	        statsCollector,
	        streamDump,
	        visibilityProxy
	    ) {
	        'use strict';

	        function create (publicEmitter) {
	            var privateEmitter = new EventEmitter(),
	                l = logger.create('MediaManager'),
	                inwardTranslator,
	                outwardTranslator,
	                components = [],
	                /* eslint-disable */
	                // prettier-ignore
	                listeners = [
	                    { 'type' : mediaControlEvents.VIDEO_SOURCE,             'listener' : onVideoSource }
	                ],
	                // prettier-ignore
	                outwardEvents = [
	                    { 'from' : mediaElementProxyEvents.LOAD_START,          'to' : mediaEvents.LOAD_START },
	                    { 'from' : mediaElementProxyEvents.PROGRESS,            'to' : mediaEvents.PROGRESS },
	                    { 'from' : mediaElementProxyEvents.SUSPEND,             'to' : mediaEvents.SUSPEND },
	                    { 'from' : mediaElementProxyEvents.ABORT,               'to' : mediaEvents.ABORT },
	                    { 'from' : mediaElementProxyEvents.EMPTIED,             'to' : mediaEvents.EMPTIED },
	                    { 'from' : mediaElementProxyEvents.STALLED,             'to' : mediaEvents.STALLED },
	                    { 'from' : mediaElementProxyEvents.PLAY,                'to' : mediaEvents.PLAY },
	                    { 'from' : mediaElementProxyEvents.PAUSE,               'to' : mediaEvents.PAUSE },
	                    { 'from' : mediaElementProxyEvents.LOADED_META_DATA,    'to' : mediaEvents.LOADED_META_DATA },
	                    { 'from' : mediaElementProxyEvents.LOADED_DATA,         'to' : mediaEvents.LOADED_DATA },
	                    { 'from' : mediaElementProxyEvents.WAITING,             'to' : mediaEvents.WAITING },
	                    { 'from' : mediaElementProxyEvents.ERROR,               'to' : mediaEvents.ERROR },
	                    { 'from' : mediaElementProxyEvents.PLAYING,             'to' : mediaEvents.PLAYING },
	                    { 'from' : mediaElementProxyEvents.CAN_PLAY,            'to' : mediaEvents.CAN_PLAY },
	                    { 'from' : mediaElementProxyEvents.CAN_PLAY_THROUGH,    'to' : mediaEvents.CAN_PLAY_THROUGH },
	                    { 'from' : mediaElementProxyEvents.SEEKING,             'to' : mediaEvents.SEEKING },
	                    { 'from' : mediaElementProxyEvents.SEEKED,              'to' : mediaEvents.SEEKED },
	                    { 'from' : mediaElementProxyEvents.TIME_UPDATE,         'to' : mediaEvents.TIME_UPDATE },
	                    { 'from' : mediaElementProxyEvents.ENDED,               'to' : mediaEvents.ENDED },
	                    { 'from' : mediaElementProxyEvents.RATE_CHANGE,         'to' : mediaEvents.RATE_CHANGE },
	                    { 'from' : mediaElementProxyEvents.DURATION_CHANGE,     'to' : mediaEvents.DURATION_CHANGE },
	                    { 'from' : mediaElementProxyEvents.VOLUME_CHANGE,       'to' : mediaEvents.VOLUME_CHANGE },

	                    { 'from' : mediaElementProxyEvents.ELEMENT_CREATED,     'to' : mediaEvents.ELEMENT_CREATED },
	                    { 'from' : mediaElementProxyEvents.PLAY_START_SUCCESS,  'to' : mediaEvents.PLAY_START_SUCCESS },
	                    { 'from' : mediaElementProxyEvents.PLAY_START_ERROR,    'to' : mediaEvents.PLAY_START_ERROR },

	                    { 'from' : handlerEvents.ERROR,                         'to' : mediaEvents.PLAYBACK_ERROR },
	                    { 'from' : handlerEvents.SUSPENDED,                     'to' : mediaEvents.PLAYBACK_SUSPENDED },

	                    { 'from' : qualityHandlerEvents.QUALITY_STATS,          'to' : mediaEvents.QUALITY_STATS },
	                    { 'from' : qualityHandlerEvents.FRAME_DROP,             'to' : mediaEvents.FRAME_DROP },

	                    { 'from' : statsCollectorEvents.PLAY_STATS,             'to' : mediaEvents.PLAY_STATS },

	                    { 'from' : mediaSourceManagerEvents.SOURCE_OPEN,        'to' : mediaEvents.SOURCE_OPEN },
	                    { 'from' : mediaSourceManagerEvents.SOURCE_ENDED,       'to' : mediaEvents.SOURCE_ENDED },
	                    { 'from' : mediaSourceManagerEvents.SOURCE_CLOSED,      'to' : mediaEvents.SOURCE_CLOSED },

	                    { 'from' : bufferControlEvents.PLAYBACK_STARTED,        'to' : mediaEvents.PLAYBACK_STARTED },
	                    { 'from' : bufferControlEvents.BUFFERING,               'to' : mediaEvents.BUFFERING },

	                    { 'from' : bufferTweakerEvents.BUFFER_TWEAKS_CREATED,   'to' : mediaEvents.BUFFER_TWEAKS_CREATED },
	                    { 'from' : bufferTweakerEvents.BUFFER_TWEAKS_ERROR,     'to' : mediaEvents.BUFFER_TWEAKS_ERROR }
	                ],
	                // prettier-ignore
	                inwardEvents = [
	                    { 'from' : controlEvents.CREATE_VIDEO,                  'to' : mediaControlEvents.CREATE_VIDEO },
	                    { 'from' : controlEvents.DESTROY_VIDEO,                 'to' : mediaControlEvents.DESTROY_VIDEO },
	                    { 'from' : controlEvents.VIDEO_SOURCE,                  'to' : mediaControlEvents.VIDEO_SOURCE },
	                    { 'from' : controlEvents.PLAY,                          'to' : mediaControlEvents.PLAY },
	                    { 'from' : controlEvents.PAUSE,                         'to' : mediaControlEvents.PAUSE },
	                    { 'from' : controlEvents.SEEK,                          'to' : mediaControlEvents.SEEK },
	                    { 'from' : controlEvents.MUTE,                          'to' : mediaControlEvents.MUTE },
	                    { 'from' : controlEvents.UNMUTE,                        'to' : mediaControlEvents.UNMUTE },
	                    { 'from' : controlEvents.SET_VOLUME,                    'to' : mediaControlEvents.SET_VOLUME },
	                    { 'from' : controlEvents.SET_RATE,                      'to' : mediaControlEvents.SET_RATE },

	                    { 'from' : controlEvents.CONFIG,                        'to' : mediaManagerEvents.CONFIG },

	                    { 'from' : networkEvents.SERVER_INFO,                   'to' : mediaManagerEvents.SERVER_INFO },
	                    { 'from' : networkEvents.STREAM_INFO,                   'to' : mediaManagerEvents.STREAM_INFO },
	                    { 'from' : networkEvents.STREAM_FRAGMENT,               'to' : mediaManagerEvents.STREAM_FRAGMENT },
	                    { 'from' : networkEvents.RANDOM_ACCESS_POINT,           'to' : mediaManagerEvents.RANDOM_ACCESS_POINT },

	                    { 'from' : logicEvents.STATE_CHANGE,                    'to' : mediaManagerEvents.APPLICATION_STATE_CHANGE }
	                ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : privateEmitter,
	                    'listeners' : listeners
	                });

	                inwardTranslator = eventTranslator.create(publicEmitter, privateEmitter, inwardEvents);
	                outwardTranslator = eventTranslator.create(privateEmitter, publicEmitter, outwardEvents);

	                components.push(bufferControl.create(privateEmitter));
	                components.push(bufferTweaker.create(privateEmitter));
	                components.push(mediaElementProxy.create(privateEmitter));
	                components.push(visibilityProxy.create(privateEmitter));

	                if (conditions.hasMediaSource) {
	                    components.push(mediaSourceManager.create(privateEmitter));
	                }
	            }

	            function onVideoSource (e) {
	                l.debug('creating media handlers');
	                components.push(pauseHandler.create(privateEmitter));
	                components.push(statsCollector.create(privateEmitter));

	                if (e.data.type === mimeType.MP4) {
	                    //wss
	                    components.push(gapHandler.create(privateEmitter));
	                    components.push(qualityHandler.create(privateEmitter));
	                    components.push(streamDump.create(privateEmitter));
	                }
	                else {
	                    //hls
	                    components.push(hlsJumpHandler.create(privateEmitter));
	                }

	                if (conditions.isChromeHigher57) {
	                    components.push(fakeAudioContext.create(privateEmitter));
	                }
	                listenerManager.remove({
	                    'target'    : privateEmitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                inwardTranslator.destroy();
	                inwardTranslator = null;
	                outwardTranslator.destroy();
	                outwardTranslator = null;

	                while (components.length) {
	                    components.pop().destroy();
	                }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }
	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaManager.';

	    return {
	        'BASE': eventBase,

	        'CONFIG'                   : eventBase + 'config',
	        'SERVER_INFO'              : eventBase + 'serverInfo',
	        'STREAM_INFO'              : eventBase + 'streamInfo',
	        'STREAM_FRAGMENT'          : eventBase + 'streamFragment',
	        'RANDOM_ACCESS_POINT'      : eventBase + 'randomAccessPoint',
	        'APPLICATION_STATE_CHANGE' : eventBase + 'applicationStateChange'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaControl.';

	    return {
	        'BASE': eventBase,

	        'PLAYBACK_STARTED' : eventBase + 'playbackStarted',
	        'BUFFERING'        : eventBase + 'buffering'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaHandler.';

	    return {
	        'BASE': eventBase,

	        'ERROR'     : eventBase + 'error',
	        'SUSPENDED' : eventBase + 'suspended'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaControl.';

	    return {
	        'BASE': eventBase,

	        'CREATE_VIDEO'  : eventBase + 'createVideo',
	        'DESTROY_VIDEO' : eventBase + 'destroyVideo',
	        'VIDEO_SOURCE'  : eventBase + 'videoSource',

	        'PLAY'  : eventBase + 'play',
	        'PAUSE' : eventBase + 'pause',

	        'SEEK'       : eventBase + 'seek',
	        'MUTE'       : eventBase + 'mute',
	        'UNMUTE'     : eventBase + 'unmute',
	        'SET_VOLUME' : eventBase + 'volume',
	        'SET_RATE'   : eventBase + 'playbackRate'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 4/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaElementProxy.';

	    return {
	        'BASE': eventBase,

	        'LOAD_START'         : eventBase + 'loadstart',
	        'PROGRESS'           : eventBase + 'progress',
	        'SUSPEND'            : eventBase + 'suspend',
	        'ABORT'              : eventBase + 'abort',
	        'EMPTIED'            : eventBase + 'emptied',
	        'STALLED'            : eventBase + 'stalled',
	        'PLAY'               : eventBase + 'play',
	        'PAUSE'              : eventBase + 'pause',
	        'LOADED_META_DATA'   : eventBase + 'loadedmetadata',
	        'LOADED_DATA'        : eventBase + 'loadeddata',
	        'WAITING'            : eventBase + 'waiting',
	        'ERROR'              : eventBase + 'error',
	        'PLAYING'            : eventBase + 'playing',
	        'CAN_PLAY'           : eventBase + 'canplay',
	        'CAN_PLAY_THROUGH'   : eventBase + 'canplaythrough',
	        'SEEKING'            : eventBase + 'seeking',
	        'SEEKED'             : eventBase + 'seeked',
	        'TIME_UPDATE'        : eventBase + 'timeupdate',
	        'ENDED'              : eventBase + 'ended',
	        'RATE_CHANGE'        : eventBase + 'ratechange',
	        'DURATION_CHANGE'    : eventBase + 'durationchange',
	        'VOLUME_CHANGE'      : eventBase + 'volumechange',
	        'QUALITY_UPDATE'     : eventBase + 'qualityupdate',
	        'ELEMENT_CREATED'    : eventBase + 'elementCreated', // custom
	        'PLAY_START_SUCCESS' : eventBase + 'playStartSuccess', // custom,
	        'PLAY_START_ERROR'   : eventBase + 'playStartError' // custom
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by Thomas Niederges on 8/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaSourceProxy.';

	    return {
	        'BASE': eventBase,

	        'SOURCE_OPEN'   : eventBase + 'sourceopen',
	        'SOURCE_ENDED'  : eventBase + 'sourceended',
	        'SOURCE_CLOSED' : eventBase + 'sourceclosed',
	        'SOURCE_READY'  : eventBase + 'sourceready'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'qualityHandler.';

	    return {
	        'BASE': eventBase,

	        'QUALITY_STATS' : eventBase + 'qualitystats',
	        'FRAME_DROP'    : eventBase + 'framedrop'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'statsCollector.';

	    return {
	        'BASE': eventBase,

	        'PLAY_STATS': eventBase + 'playStats'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'mediaControl.';

	    return {
	        'BASE': eventBase,

	        'BUFFER_TWEAKS_CREATED' : eventBase + 'tweaksCreated',
	        'BUFFER_TWEAKS_ERROR'   : eventBase + 'tweaksError'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(45),
	        __webpack_require__(24),
	        __webpack_require__(63),
	        __webpack_require__(70),
	        __webpack_require__(65),
	        __webpack_require__(66),
	        __webpack_require__(67),
	        __webpack_require__(62),
	        __webpack_require__(69),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        mimeType,
	        listenerManager,
	        bufferControlEvents,
	        bufferTweakerEvents,
	        mediaControlEvents,
	        mediaElementProxyEvents,
	        mediaSourceManagerEvents,
	        mediaManagerEvents,
	        statsCollectorEvents,
	        playerStates
	    ) {
	        function create (emitter) {
	            var l = logger.create('BufferControl');

	            var playerState;
	            var tweaks = {};

	            var started = false;
	            var buffering = true;
	            var hls = false,
	                waitForProgress = false;

	            var startTime = -1;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange },
	                { 'type' : mediaControlEvents.VIDEO_SOURCE,                 'listener' : onVideoSource },
	                { 'type' : mediaSourceManagerEvents.SOURCE_READY,           'listener' : onMediaSourceReady },
	                { 'type' : bufferTweakerEvents.BUFFER_TWEAKS_CREATED,       'listener' : onBufferTweaksCreated }
	            ];

	            // prettier-ignore
	            var mediaListeners = [
	                { 'type': mediaElementProxyEvents.CAN_PLAY_THROUGH,         'listener': onMediaElementCanPlayThrough },
	                { 'type': mediaElementProxyEvents.PROGRESS,                 'listener': onMediaElementProgress },
	                { 'type': mediaElementProxyEvents.WAITING,                  'listener': onMediaElementWaiting }
	            ];

	            // prettier-ignore
	            var controlListeners = [
	                { 'type' : mediaControlEvents.PLAY,                         'listener' : onPlay }
	            ];

	            // prettier-ignore
	            var playStateListeners = [
	                { 'type' : statsCollectorEvents.PLAY_STATS,                 'listener' : onPlayStats }
	            ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	                addControlListeners();
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	                if (hls) {
	                    listenerManager.remove({
	                        'target'    : emitter,
	                        'listeners' : mediaListeners
	                    });
	                }
	                removeControlListeners();
	            }

	            function addControlListeners () {
	                removeControlListeners();
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : controlListeners
	                });
	            }

	            function removeControlListeners () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : controlListeners
	                });
	            }

	            function addPlayStateListeners () {
	                removePlayStateListeners();
	                if (tweaks) {
	                    listenerManager.add({
	                        'target'    : emitter,
	                        'listeners' : playStateListeners
	                    });
	                }
	            }

	            function removePlayStateListeners () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : playStateListeners
	                });
	            }

	            function onMediaSourceReady () {
	                addPlayStateListeners();
	            }

	            function onBufferTweaksCreated (e) {
	                if (!hls && playerState === playerStates.PLAYING && tweaks.buffer.start < e.data.tweaks.buffer.start) {
	                    setTimeout(function () {
	                        buffering = true;
	                        emitter.emit(bufferControlEvents.BUFFERING);
	                        l.debug('new tweaks, pausing to raise buffer');
	                        emitter.emit(mediaControlEvents.PAUSE);
	                    }, 10);
	                }
	                tweaks.buffer = e.data.tweaks.buffer;
	            }

	            function onMediaElementCanPlayThrough () {
	                if (playerState === playerStates.LOADING) {
	                    emitter.emit(mediaControlEvents.PLAY);
	                    waitForProgress = true;
	                }
	            }

	            function onMediaElementProgress () {
	                if (
	                    playerState === playerStates.BUFFERING ||
	                    (playerState === playerStates.LOADING && waitForProgress)
	                ) {
	                    waitForProgress = false;
	                    buffering = false;
	                    emitter.emit(bufferControlEvents.PLAYBACK_STARTED);
	                }
	            }

	            function onMediaElementWaiting () {
	                if (playerState === playerStates.PLAYING) {
	                    buffering = true;
	                    emitter.emit(bufferControlEvents.BUFFERING);
	                }
	            }

	            function onVideoSource (e) {
	                hls = e.data.type === mimeType.HLS;
	                if (hls) {
	                    listenerManager.add({
	                        'target'    : emitter,
	                        'listeners' : mediaListeners
	                    });
	                }
	            }

	            function onApplicationStateChange (e) {
	                playerState = e.data.state;

	                switch (playerState) {
	                    case playerStates.LOADING:
	                        hls && addPlayStateListeners();
	                        break;
	                    case playerStates.PAUSED:
	                        removePlayStateListeners();
	                        break;
	                    case playerStates.PAUSING:
	                        removePlayStateListeners();
	                        l.warn('entering paused state');
	                        startTime = -1;
	                        started = false;
	                        buffering = true;
	                        break;
	                    default:
	                        break;
	                }
	            }

	            function emitMediaControlPlay () {
	                //need to remove listeners not to interfere with our own logic
	                removeControlListeners();
	                emitter.emit(mediaControlEvents.PLAY);
	                addControlListeners();
	            }

	            function onPlay () {
	                if (!hls && startTime === -1) {
	                    setTimeout(function () {
	                        l.debug('pausing to raise buffer');
	                        emitter.emit(mediaControlEvents.PAUSE);
	                    }, 10);
	                }
	            }

	            function onPlayStats (e) {
	                if (!e.data.buffered || !e.data.buffered.length) {
	                    //TODO: remove need for buffered values
	                    return;
	                }

	                var stats = e.data.stats;
	                var hasEnoughToStart = stats.buffer.delay.current > tweaks.buffer.start;
	                var hasEnoughToPlay = stats.buffer.delay.current > tweaks.buffer.min;
	                var bufferLength = stats.buffer.end - stats.buffer.start;

	                var currentTime = e.data.currentTime;
	                var buffered = e.data.buffered;
	                var hasRangeIndex = getRangeIndex(buffered, currentTime) !== -1;

	                /*
	                 *  in case the stream does not start at timestamp 0.0, we should seek into the first range.
	                 *  0.2 is a magic number, because Safari might not start the playback at the exact start of the range.
	                 */
	                if (!hls && !hasRangeIndex && !started && bufferLength > 0.45) {
	                    var len = buffered.length;
	                    var seekPosition = Math.min(buffered.start(len - 1) + 0.3, buffered.end(len - 1));
	                    l.warn(
	                        'seek to range: ' +
	                            buffered.start(len - 1) +
	                            ' < ' +
	                            seekPosition +
	                            ' > ' +
	                            buffered.end(len - 1)
	                    );
	                    emitter.emit(mediaControlEvents.SEEK, {
	                        'position': conditions.isIEorEdge ? 0 : seekPosition
	                    });

	                    //let's wait for the next event to update currentTime
	                    return;
	                }

	                /*
	                 *  in case the stream does not start and we have more than one buffered range
	                 */
	                if (
	                    !hls &&
	                    !started &&
	                    conditions.isFirefox &&
	                    buffered.length > 1 &&
	                    getRangeIndex(buffered, currentTime) !== buffered.length - 1 &&
	                    buffered.end(len - 1) - buffered.start(len - 1) > 0.3
	                ) {
	                    var len = buffered.length;
	                    var seekPosition = buffered.start(len - 1);
	                    l.warn('seek to startable range start: ' + buffered.start(len - 1));
	                    emitter.emit(mediaControlEvents.SEEK, {
	                        'position': seekPosition
	                    });

	                    //let's wait for the next event to update currentTime
	                    return;
	                }

	                if (hasEnoughToStart && startTime === -1 && hasRangeIndex) {
	                    startTime = currentTime;
	                    if (!hls && conditions.isSafari && startTime < 0.2) {
	                        startTime = 0.3;
	                        l.warn('initial safari stream startTime set to ' + startTime + ', seeking');
	                        emitter.emit(mediaControlEvents.SEEK, {
	                            'position': startTime
	                        });
	                        return;
	                    }
	                    l.debug('stream startTime set to ' + startTime);
	                }

	                if (!hls && buffering && hasEnoughToStart) {
	                    //only need to resume on wss, as we don't pause on hls
	                    l.debug('starting stream');
	                    emitMediaControlPlay();

	                    buffering = false;

	                    if (started) {
	                        emitter.emit(bufferControlEvents.PLAYBACK_STARTED);
	                    }
	                }

	                if (!buffering) {
	                    if (!started && startTime !== -1 && startTime < currentTime - 0.1) {
	                        started = true;
	                        emitter.emit(bufferControlEvents.PLAYBACK_STARTED);
	                    }
	                    if (currentTime > tweaks.buffer.start && !hasEnoughToPlay) {
	                        buffering = true;
	                        if (!hls) {
	                            l.debug('pausing to buffer');
	                            emitter.emit(mediaControlEvents.PAUSE);
	                        }
	                        emitter.emit(bufferControlEvents.BUFFERING);
	                    }
	                }
	            }

	            function getRangeIndex (buffered, time) {
	                for (var i = 0; buffered && i < buffered.length; ++i) {
	                    //dirty hacks everywhere...
	                    if (
	                        (buffered.start(i) <= time && buffered.end(i) >= time) ||
	                        (conditions.isIEorEdge &&
	                            time <= 0.3 &&
	                            buffered.start(i) <= 5 &&
	                            buffered.end(i) - buffered.start(i) > 0.2)
	                    ) {
	                        return i;
	                    }
	                }
	                return -1;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(18),
	        __webpack_require__(22),
	        __webpack_require__(73),
	        __webpack_require__(24),
	        __webpack_require__(63),
	        __webpack_require__(70),
	        __webpack_require__(68),
	        __webpack_require__(62),
	        __webpack_require__(69),
	        __webpack_require__(74)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        objectUtils,
	        conditions,
	        valueCollector,
	        listenerManager,
	        bufferControlEvents,
	        bufferTweakerEvents,
	        qualityHandlerEvents,
	        mediaManagerEvents,
	        statsCollectorEvents,
	        bufferConfigValidator
	    ) {
	        function create (emitter) {
	            var SURFACE_EDGE_START_THRESHOLD = 2;
	            var SURFACE_EDGE_LIMIT_DIFFERENCE = 1.5;

	            var l = logger.create('BufferTweaker');

	            var defaultBuffer = {
	                    'max'    : 8.0,
	                    'min'    : 0.2,
	                    'start'  : 0.5,
	                    'target' : 1.2,
	                    'limit'  : 1.7
	                },
	                tweaksBuffer = objectUtils.copy(defaultBuffer),
	                configBuffer = objectUtils.copy(defaultBuffer),
	                offsetThreshold = 0,
	                offsetStep = 0,
	                cooldownTime = 0,
	                streamStartTimestamp = -1,
	                cooldownInterval,
	                bufferCollector,
	                streamStarted = false,
	                gotConfig = false;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : mediaManagerEvents.STREAM_INFO,                  'listener' : onStreamInfo },
	                { 'type' : mediaManagerEvents.CONFIG,                       'listener' : onConfig },
	                { 'type' : qualityHandlerEvents.FRAME_DROP,                 'listener' : onFrameDrop }
	            ];
	            // prettier-ignore
	            var playingListeners = [
	                { 'type' : statsCollectorEvents.PLAY_STATS,                 'listener' : onStatsUpdate },
	                { 'type' : bufferControlEvents.BUFFERING,                   'listener' : onBufferControlBuffering }
	            ];
	            // prettier-ignore
	            var bufferingListeners = [
	                { 'type' : bufferControlEvents.PLAYBACK_STARTED,            'listener' : onBufferControlPlayStarted }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('initialize');
	                resetBufferCollector();

	                [listeners, conditions.useHLS ? null : bufferingListeners].forEach(function (config) {
	                    !!config &&
	                        listenerManager.add({
	                            'target'    : emitter,
	                            'listeners' : config
	                        });
	                });
	            }

	            function destroy () {
	                bufferCollector = null;

	                [listeners, playingListeners, bufferingListeners].forEach(function (config) {
	                    listenerManager.remove({
	                        'target'    : emitter,
	                        'listeners' : config
	                    });
	                });
	            }

	            function resetBufferCollector () {
	                bufferCollector = valueCollector.create(cooldownTime * 10); //buffer updated every 100 msecs
	            }

	            function setConditionalListeners (buffering) {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : buffering ? bufferingListeners : playingListeners
	                });
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : buffering ? playingListeners : bufferingListeners
	                });
	            }

	            function onStreamInfo (e) {
	                if (
	                    e.data.onStreamInfo.videoInfo &&
	                    e.data.onStreamInfo.haveVideo &&
	                    e.data.onStreamInfo.videoInfo.frameRate <= 30 &&
	                    conditions.isIEorEdge &&
	                    !gotConfig
	                ) {
	                    // to low buffer could cause framedrop/freezing
	                    // increase all buffer values around 25% (more stable)
	                    var factor = 1.0;
	                    // increase also by adding a value depend on the framerate (range between 0s and 5,47s)
	                    // the lower framerate the higher buffer
	                    tweaksBuffer = objectUtils.copy(defaultBuffer);
	                    raiseBuffer(Math.sqrt(30) - Math.sqrt(e.data.onStreamInfo.videoInfo.frameRate), factor);
	                    tweaksBuffer.start += (tweaksBuffer.target - tweaksBuffer.start) / 2;
	                    tweaksBuffer.min += (tweaksBuffer.start - tweaksBuffer.min) / 2;
	                    emitBufferTweaksCreated();
	                }
	            }

	            function onConfig (e) {
	                var valid;
	                if (e.data.config.tweaks) {
	                    if (e.data.config.tweaks.buffer) {
	                        valid = bufferConfigValidator.validateBuffer(e.data.config.tweaks.buffer);
	                        if (!valid.success) {
	                            emitter.emit(bufferTweakerEvents.BUFFER_TWEAKS_ERROR, { 'reason': valid.reason });
	                        }
	                        else {
	                            tweaksBuffer = objectUtils.copy(e.data.config.tweaks.buffer);
	                            configBuffer = objectUtils.copy(tweaksBuffer);
	                            gotConfig = true;
	                        }
	                    }
	                    if (e.data.config.tweaks.bufferDynamic && !conditions.useHLS) {
	                        valid = bufferConfigValidator.validateDynamic(e.data.config.tweaks.bufferDynamic);
	                        if (!valid.success) {
	                            emitter.emit(bufferTweakerEvents.BUFFER_TWEAKS_ERROR, { 'reason': valid.reason });
	                        }
	                        else {
	                            offsetThreshold = e.data.config.tweaks.bufferDynamic.offsetThreshold;
	                            offsetStep = e.data.config.tweaks.bufferDynamic.offsetStep;
	                            cooldownTime = e.data.config.tweaks.bufferDynamic.cooldownTime;
	                        }
	                    }
	                }
	                emitBufferTweaksCreated();
	            }

	            function onStatsUpdate (e) {
	                var buffer = e.data.stats.buffer.delay.current;
	                if (buffer) {
	                    bufferCollector.add(buffer);
	                }
	                if (!streamStarted && conditions.isIEorEdge && buffer > SURFACE_EDGE_START_THRESHOLD) {
	                    tweaksBuffer.target = buffer;
	                    tweaksBuffer.limit = tweaksBuffer.target + SURFACE_EDGE_LIMIT_DIFFERENCE;
	                    emitBufferTweaksCreated();
	                }
	                streamStarted = true;
	            }

	            function onBufferControlBuffering () {
	                setConditionalListeners(true);

	                var bufferTimeDiff = (new Date().getTime() - streamStartTimestamp) / 1000;

	                if (
	                    streamStartTimestamp !== -1 &&
	                    bufferTimeDiff < offsetThreshold &&
	                    tweaksBuffer.start < configBuffer.limit
	                ) {
	                    l.warn('buffering ' + bufferTimeDiff + ' seconds after stream started, raising buffer values');
	                    raiseBuffer(offsetStep);
	                    emitBufferTweaksCreated();
	                }

	                resetBufferCollector();
	                clearInterval(cooldownInterval);
	                cooldownInterval = 0;
	            }

	            function onBufferControlPlayStarted () {
	                setConditionalListeners(false);

	                streamStartTimestamp = new Date().getTime();
	                if (streamStarted && cooldownTime) {
	                    //should not set values on stream start because of buffer level fluctuation on cold start
	                    cooldownInterval = setInterval(function () {
	                        l.debug('stream running stable since ' + cooldownTime + ' sec');
	                        //l.debug('buffer min: ' + bufferCollector.minimum + ', max: ' + bufferCollector.maximum);
	                        if (tweaksBuffer.start > configBuffer.start) {
	                            l.debug(-offsetStep + ' sec cooldown');
	                            raiseBuffer(-offsetStep);
	                            emitBufferTweaksCreated();
	                        }
	                        else {
	                            l.debug('no cooldown');
	                            clearInterval(cooldownInterval);
	                            cooldownInterval = 0;
	                        }
	                    }, cooldownTime * 1000);
	                }
	            }

	            function onFrameDrop (e) {
	                if (conditions.isFirefox) {
	                    l.debug('frame drop');
	                    l.debug('' + JSON.stringify(e));
	                    l.debug('current buffer: ' + JSON.stringify(tweaksBuffer));
	                    l.debug('limit: ' + configBuffer.limit + ', start: ' + tweaksBuffer.start);
	                    if (tweaksBuffer.start < configBuffer.limit) {
	                        l.debug('start lower then limit -> tweaking');
	                        raiseBuffer(tweaksBuffer.target - tweaksBuffer.start);
	                        emitBufferTweaksCreated();
	                    }
	                    else {
	                        l.debug('start higher then limit -> tweaking denied');
	                    }
	                }
	            }

	            function raiseBuffer (offset, factor) {
	                factor = factor || 1;

	                ['start', 'target', 'limit'].forEach(function (key) {
	                    tweaksBuffer[key] *= factor;
	                    tweaksBuffer[key] += offset;
	                });
	            }

	            function emitBufferTweaksCreated () {
	                l.debug('new buffer: ' + JSON.stringify(tweaksBuffer));
	                emitter.emit(bufferTweakerEvents.BUFFER_TWEAKS_CREATED, {
	                    'tweaks': {
	                        'buffer': objectUtils.copy(tweaksBuffer)
	                    }
	                });
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function calculateArithmeticMean (array) {
	        return (
	            array.reduce(function (a, b) {
	                return a + b;
	            }, 0) / array.length
	        );
	    }
	    function calculateGeometricMean (array) {
	        return Math.pow(
	            array.reduce(function (a, b) {
	                if (!a) return b;
	                return b ? a * b : a;
	            }, 0),
	            1 / array.length
	        );
	    }

	    function calculateHarmonicMean (array) {
	        var invSum = array.reduce(function (a, b, i) {
	            if (!b) return a;
	            else if (!(i - 1)) return (a ? 1 / a : 0) + 1 / b;
	            else return a + 1 / b;
	        }, 0);

	        return invSum ? array.length / invSum : 0;
	    }

	    function create (maxCount) {
	        var values = [];
	        var exports = {};

	        function add (value) {
	            values.push(value);
	            while (values.length > maxCount) {
	                values.shift();
	            }

	            update();

	            return {
	                'minimum'    : exports.min,
	                'maximum'    : exports.max,
	                'arithmetic' : exports.arithmetic,
	                'geometric'  : exports.geometric,
	                'harmonic'   : exports.harmonic
	            };
	        }

	        function update () {
	            var sorted = JSON.parse(JSON.stringify(values)).sort(function (a, b) {
	                return a - b;
	            }, 0);

	            exports.arithmetic = calculateArithmeticMean(sorted);
	            exports.geometric = calculateGeometricMean(sorted);
	            exports.harmonic = calculateHarmonicMean(sorted);
	            exports.minimum = sorted[0];
	            exports.maximum = sorted[sorted.length - 1];
	        }

	        exports = {
	            'add': add,

	            'minimum' : 0,
	            'maximum' : 0,

	            'arithmetic' : 0,
	            'geometric'  : 0,
	            'harmonic'   : 0,

	            'values': values
	        };

	        return exports;
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function validateBuffer (buffer) {
	        var keys = ['min', 'start', 'target', 'limit', 'max'];
	        var missing = keys.filter(function (value) {
	            return !buffer.hasOwnProperty(value);
	        });
	        if (missing.length) {
	            return {
	                'success' : false,
	                'reason'  : 'The buffer config is invalid, it must contain ' + missing.join(', ') + '. Reset to default.'
	            };
	        }
	        for (var i in keys) {
	            if (typeof buffer[keys[i]] !== 'number') {
	                return {
	                    'success' : false,
	                    'reason'  :
	                        'The buffer config is invalid, the value \'' +
	                        keys[i] +
	                        '\' have to be a number. Reset to default.'
	                };
	            }
	            if (i > 0) {
	                if (buffer[keys[i - 1]] > buffer[keys[i]]) {
	                    return {
	                        'success' : false,
	                        'reason'  :
	                            'The buffer config is invalid, the value \'' +
	                            keys[i - 1] +
	                            '\' have to be lower then \'' +
	                            keys[i] +
	                            '\'. Reset to default.'
	                    };
	                }
	            }
	        }
	        return { 'success': true };
	    }

	    //TODO: lots of duplication, find ways to reduce code size
	    function validateDynamic (dynamic) {
	        var keys = ['offsetThreshold', 'offsetStep', 'cooldownTime'];
	        var missing = keys.filter(function (value) {
	            return !dynamic.hasOwnProperty(value);
	        });
	        if (missing.length) {
	            return {
	                'success' : false,
	                'reason'  :
	                    'The dynamic buffer config is invalid, it must contain ' +
	                    missing.join(', ') +
	                    '. Reset to default.'
	            };
	        }
	        keys.forEach(function (key) {
	            if (typeof dynamic[key] !== 'number' || dynamic[key] === 0) {
	                return {
	                    'success' : false,
	                    'reason'  :
	                        'The dynamic buffer config is invalid, the value \'' +
	                        key +
	                        '\' have to be a number. Reset to default.'
	                };
	            }
	        });
	        return { 'success': true };
	    }

	    return {
	        'validateBuffer'  : validateBuffer,
	        'validateDynamic' : validateDynamic
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(76),
	        __webpack_require__(24),
	        __webpack_require__(77),
	        __webpack_require__(65),
	        __webpack_require__(62),
	        __webpack_require__(66)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        mediaPlayPromise,
	        listenerManager,
	        mediaElementEvents,
	        mediaControlEvents,
	        mediaManagerEvents,
	        mediaElementProxyEvents
	    ) {
	        var TIME_UPDATE_DELAY = 100;
	        var QUALITY_UPDATE_DELAY = 1000;

	        function create (emitter) {
	            var l = logger.create('MediaElementProxy');

	            var video, container, source;
	            var external = false;
	            var externalStyle, externalContainer;

	            var muted = false;
	            var volume = 1;

	            var timeUpdateInterval;
	            var qualityUpdateInterval;

	            /* eslint-disable */
	            // prettier-ignore
	            var emitterListeners = [
	                { 'type' : mediaManagerEvents.CONFIG,           'listener' : onConfig },
	                { 'type' : mediaControlEvents.CREATE_VIDEO,     'listener' : onCreateVideo },
	                { 'type' : mediaControlEvents.DESTROY_VIDEO,    'listener' : onDestroyVideo },
	                { 'type' : mediaControlEvents.VIDEO_SOURCE,     'listener' : onVideoSource },
	                { 'type' : mediaControlEvents.PLAY,             'listener' : onPlay },
	                { 'type' : mediaControlEvents.PAUSE,            'listener' : onPause },
	                { 'type' : mediaControlEvents.SEEK,             'listener' : onSeek },
	                { 'type' : mediaControlEvents.MUTE,             'listener' : onMute },
	                { 'type' : mediaControlEvents.UNMUTE,           'listener' : onUnmute },
	                { 'type' : mediaControlEvents.SET_VOLUME,       'listener' : onSetVolume },
	                { 'type' : mediaControlEvents.SET_RATE,         'listener' : onSetRate }
	            ];

	            // prettier-ignore
	            var mediaListeners = [];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });

	                var ignore = [mediaElementEvents.TIME_UPDATE];

	                for (var key in mediaElementEvents) {
	                    if (mediaElementEvents.hasOwnProperty(key) && ignore.indexOf(mediaElementEvents[key]) === -1) {
	                        mediaListeners.push({
	                            'type'     : mediaElementEvents[key],
	                            'listener' : onMediaEvent
	                        });
	                    }
	                }
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	                onDestroyVideo();
	            }

	            function onConfig (e) {
	                if (e.data.config.playback) {
	                    muted = !!e.data.config.playback.muted;
	                }
	            }

	            function onCreateVideo (e) {
	                video = document.getElementById(e.data.elementId);
	                external = !!video;
	                l.debug('using ' + (external ? 'external ' : 'generated ') + 'video eleement');

	                container = e.data.container;

	                if (video) {
	                    externalContainer = video.parentElement;
	                    externalStyle = video.style.cssText;
	                    video.style.cssText = '';
	                }
	                else {
	                    video = document.createElement('video');
	                    video.id = e.data.elementId;
	                    video.autoplay = false;
	                    video.controls = false;
	                    video.setAttribute('playsinline', true);
	                    video.style.backgroundColor = 'transparent';
	                }

	                video.muted = muted;
	                video.volume = volume;

	                source = document.createElement('source');
	                video.appendChild(source);

	                if (conditions.isIOS11) {
	                    l.debug('iOS11 detected, using iframe hack');

	                    video.style.width = '100vw';
	                    video.style.height = '100vh';
	                    var iframe = document.createElement('iframe');
	                    iframe.frameBorder = 0;
	                    iframe.scrolling = 'no';
	                    iframe.style.cssText = 'width: 100%;height: 100%;position: absolute;display: block;top: 0;left: 0;';
	                    iframe.addEventListener('load', function (e) {
	                        e.target.contentDocument.body.style.height = '100%';
	                        e.target.contentDocument.body.style.width = '100%';
	                        e.target.contentDocument.body.style.overflow = 'hidden';
	                        e.target.contentDocument.body.style.position = 'absolute';
	                        e.target.contentDocument.body.style.margin = '0';
	                        e.target.contentDocument.body.style.padding = '0';
	                        if (!e.target.contentDocument.body.firstChild) {
	                            e.target.contentDocument.body.appendChild(video);
	                            listenerManager.remove({
	                                'target'    : video,
	                                'listeners' : mediaListeners
	                            });
	                            listenerManager.add({
	                                'target'    : video,
	                                'listeners' : mediaListeners
	                            });
	                        }
	                    });
	                    iframe.addEventListener('beforeunload', function (e) {
	                        if (e.target.contentDocument.body.firstChild) {
	                            e.target.contentDocument.body.removeChild(video);
	                        }
	                    });
	                    container.appendChild(iframe);
	                }
	                else {
	                    l.debug('appending video to container');
	                    container.appendChild(video);
	                    listenerManager.add({
	                        'target'    : video,
	                        'listeners' : mediaListeners
	                    });
	                }

	                emitter.emit(mediaElementProxyEvents.ELEMENT_CREATED);
	                emitter.emit(mediaElementProxyEvents.VOLUME_CHANGE, {
	                    'muted'  : video.muted,
	                    'volume' : video.volume
	                });
	            }

	            function onDestroyVideo () {
	                if (video) {
	                    listenerManager.remove({
	                        'target'    : video,
	                        'listeners' : mediaListeners
	                    });
	                    if (conditions.useHLS) {
	                        source.src = '';
	                        video.load();
	                    }

	                    while (container.firstChild) {
	                        container.removeChild(container.firstChild);
	                    }

	                    while (video.firstChild) {
	                        video.removeChild(video.firstChild);
	                    }

	                    if (external) {
	                        l.debug('releasing external video');
	                        video.style.cssText = externalStyle;
	                        externalStyle = null;
	                        externalContainer.appendChild(video);
	                    }

	                    clearInterval(timeUpdateInterval);
	                    clearInterval(qualityUpdateInterval);

	                    video = null;
	                }
	            }

	            function onVideoSource (e) {
	                if (video) {
	                    //TODO: store src and type to handle wrong event order?
	                    source.src = e.data.src;
	                    video.type = e.data.type;
	                    video.load();

	                    clearInterval(timeUpdateInterval);
	                    clearInterval(qualityUpdateInterval);

	                    //TODO: review setting src to '' for hls
	                    if (e.data.src && e.data.src.length) {
	                        timeUpdateInterval = setInterval(emitTimeUpdate, TIME_UPDATE_DELAY);
	                        if (typeof video.getVideoPlaybackQuality === 'function') {
	                            qualityUpdateInterval = setInterval(emitQualityUpdate, QUALITY_UPDATE_DELAY);
	                        }
	                    }
	                }
	            }

	            function onMute () {
	                l.debug('mute');

	                muted = true;

	                if (video) {
	                    video.muted = true;
	                }
	            }

	            function onUnmute () {
	                l.debug('unmute');

	                muted = false;

	                if (video) {
	                    video.muted = false;
	                }
	            }

	            function onPlay () {
	                l.debug('onPlay');

	                if (video) {
	                    mediaPlayPromise.play(video).then(
	                        function () {
	                            l.debug('play promise resolved');
	                            emitter.emit(mediaElementProxyEvents.PLAY_START_SUCCESS);
	                        },
	                        function (e) {
	                            l.debug('play promise rejected');
	                            emitter.emit(mediaElementProxyEvents.PLAY_START_ERROR, { 'error': e.error });
	                        }
	                    );
	                }
	            }

	            function onPause () {
	                l.debug('onPause');

	                if (video) {
	                    video.pause();
	                    onSetRate({ 'data': { 'rate': 1.0 } });
	                    if (conditions.isIOS11) {
	                        for (var i = 0; i < container.children.length; i += 1) {
	                            var el = container.children[i];
	                            if (el && el.tagName && el.tagName === 'IFRAME') {
	                                el.contentWindow.location.reload(true);
	                            }
	                        }
	                    }
	                }
	            }

	            function onSetVolume (e) {
	                volume = Math.min(1, Math.max(0, e.data.volume));

	                if (video && video.volume !== volume) {
	                    l.debug('set volume: ' + e.data.volume);
	                    video.volume = volume;
	                }
	            }

	            function onSetRate (e) {
	                if (video && video.playbackRate !== e.data.rate) {
	                    l.debug('set rate to: ' + e.data.rate);
	                    video.playbackRate = e.data.rate;
	                }
	            }

	            function onSeek (e) {
	                if (video) {
	                    l.debug('seek to: ' + e.data.position);
	                    video.currentTime = e.data.position;
	                }
	            }

	            function onMediaEvent (e) {
	                //TODO: not so lazy solution
	                var payload = getEventPayload();
	                switch (e.type) {
	                    case mediaElementEvents.ERROR:
	                        payload.code = video.error.code;
	                        break;
	                    case mediaElementEvents.VOLUME_CHANGE:
	                        payload.muted = video.muted;
	                        payload.volume = video.volume;
	                        break;
	                    case mediaElementEvents.CAN_PLAY:
	                        payload.haveVideo = typeof video.videoTracks !== 'undefined' && video.videoTracks.length > 0;
	                        payload.haveAudio = typeof video.audioTracks !== 'undefined' && video.audioTracks.length > 0;
	                        payload.videoWidth = video.videoWidth;
	                        payload.videoHeight = video.videoHeight;
	                        break;
	                }
	                l.detail(e.type);
	                emitter.emit('mediaElementProxy.' + e.type, payload);
	            }

	            function emitTimeUpdate () {
	                emitter.emit(mediaElementProxyEvents.TIME_UPDATE, getEventPayload());
	            }

	            function emitQualityUpdate () {
	                var payload = getEventPayload();
	                payload.quality = video.getVideoPlaybackQuality();
	                emitter.emit(mediaElementProxyEvents.QUALITY_UPDATE, payload);
	            }

	            function getEventPayload () {
	                return {
	                    'currentTime'  : video.currentTime,
	                    'buffered'     : video.buffered,
	                    'played'       : video.played,
	                    'playbackRate' : video.playbackRate
	                };
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by thomas.niedergesaess 21/09/17
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var errorName, errorMessage;
	    function play (mediaElement) {
	        return new Promise(function (resolve, reject) {
	            var promise = mediaElement.play();
	            if (promise instanceof Promise) {
	                promise.then(
	                    function () {
	                        resolve({ 'media': mediaElement });
	                    },
	                    function (error) {
	                        errorName = error && error.name ? error.name : 'Unknown';
	                        errorMessage = error && error.message ? error.message : 'Message not available.';
	                        reject({
	                            'media' : mediaElement,
	                            'error' : {
	                                'name'    : errorName,
	                                'message' : errorMessage
	                            }
	                        });
	                    }
	                );
	            }
	            else {
	                resolve({ 'media': mediaElement });
	            }
	        });
	    }

	    return {
	        'play': play
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = '';

	    return {
	        'BASE': eventBase,

	        'LOAD_START'       : eventBase + 'loadstart',
	        'PROGRESS'         : eventBase + 'progress',
	        'SUSPEND'          : eventBase + 'suspend',
	        'ABORT'            : eventBase + 'abort',
	        'EMPTIED'          : eventBase + 'emptied',
	        'STALLED'          : eventBase + 'stalled',
	        'PLAY'             : eventBase + 'play',
	        'PAUSE'            : eventBase + 'pause',
	        'LOADED_META_DATA' : eventBase + 'loadedmetadata',
	        'LOADED_DATA'      : eventBase + 'loadeddata',
	        'WAITING'          : eventBase + 'waiting',
	        'ERROR'            : eventBase + 'error',
	        'PLAYING'          : eventBase + 'playing',
	        'CAN_PLAY'         : eventBase + 'canplay',
	        'CAN_PLAY_THROUGH' : eventBase + 'canplaythrough',
	        'SEEKING'          : eventBase + 'seeking',
	        'SEEKED'           : eventBase + 'seeked',
	        'TIME_UPDATE'      : eventBase + 'timeupdate',
	        'ENDED'            : eventBase + 'ended',
	        'RATE_CHANGE'      : eventBase + 'ratechange',
	        'DURATION_CHANGE'  : eventBase + 'durationchange',
	        'VOLUME_CHANGE'    : eventBase + 'volumechange'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(24),
	        __webpack_require__(45),
	        __webpack_require__(79),
	        __webpack_require__(65),
	        __webpack_require__(66),
	        __webpack_require__(67),
	        __webpack_require__(80)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        listenerManager,
	        mimeType,
	        mediaSourceEvents,
	        mediaControlEvents,
	        mediaElementProxyEvents,
	        mediaSourceManagerEvents,
	        sourceBufferQueue
	    ) {
	        function create (emitter) {
	            var l = logger.create('MediaSourceProxy');

	            var mediaSource;

	            /* eslint-disable */
	            // prettier-ignore
	            var emitterListeners = [
	                { 'type' : mediaElementProxyEvents.ELEMENT_CREATED,     'listener' : onElementCreated }
	            ];

	            // prettier-ignore
	            var sourceListeners = [
	                { 'type' : mediaSourceEvents.SOURCE_OPEN,               'listener' : onSourceOpen },
	                { 'type' : mediaSourceEvents.SOURCE_ENDED,              'listener' : onSourceEnded },
	                { 'type' : mediaSourceEvents.SOURCE_CLOSED,             'listener' : onSourceClosed }
	            ];
	            /* eslint-enable */

	            var components = [];

	            function init () {
	                l.debug('create');

	                mediaSource = new window.MediaSource();

	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	                listenerManager.add({
	                    'target'    : mediaSource,
	                    'listeners' : sourceListeners
	                });

	                components.push(sourceBufferQueue.create(emitter, mediaSource));
	            }

	            function destroy () {
	                if (mediaSource) {
	                    while (components.length) {
	                        components.pop().destroy();
	                    }
	                    l.debug('destroy');
	                    listenerManager.remove({
	                        'target'    : mediaSource,
	                        'listeners' : sourceListeners
	                    });
	                    mediaSource = null;
	                }
	            }

	            function onElementCreated () {
	                emitter.emit(mediaControlEvents.VIDEO_SOURCE, {
	                    'src'  : window.URL.createObjectURL(mediaSource),
	                    'type' : mimeType.MP4
	                });
	            }

	            function onSourceOpen () {
	                emitter.emit(mediaSourceManagerEvents.SOURCE_OPEN, getEventPayload());
	            }

	            function onSourceEnded () {
	                emitter.emit(mediaSourceManagerEvents.SOURCE_ENDED, getEventPayload());
	            }

	            function onSourceClosed () {
	                emitter.emit(mediaSourceManagerEvents.SOURCE_CLOSED, getEventPayload());
	            }

	            function getEventPayload () {
	                return {
	                    'readyState': mediaSource.readyState
	                };
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by Thomas Niederges on 8/24/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = '';

	    return {
	        'BASE': eventBase,

	        'SOURCE_OPEN'   : eventBase + 'sourceopen',
	        'SOURCE_ENDED'  : eventBase + 'sourceended',
	        'SOURCE_CLOSED' : eventBase + 'sourceclosed'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-10-17.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(81),
	        __webpack_require__(79),
	        __webpack_require__(65),
	        __webpack_require__(66),
	        __webpack_require__(62),
	        __webpack_require__(67),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        conditions,
	        listenerManager,
	        sourceBufferEvents,
	        mediaSourceEvents,
	        mediaControlEvents,
	        mediaElementProxyEvents,
	        mediaManagerEvents,
	        mediaSourceManagerEvents,
	        playerStates
	    ) {
	        function create (emitter, mediaSource) {
	            var sourceBuffer;

	            var TRIM_FAR_THRESHOLD = 30;
	            var TRIM_NEAR_THRESHOLD = 20;
	            var APPENDED_BUFFERS_THRESHOLD = 300;

	            var appendedBuffersCount = 0;

	            var updating = false;
	            var commandQueue = [];

	            var APPEND = 'append';
	            var REMOVE = 'remove';

	            var appendEnabled = true;

	            var currentTime;

	            var streamInfo;

	            var msResetState = 0;

	            /* eslint-disable */
	            // prettier-ignore
	            var initListeners = [
	                { 'type' : mediaManagerEvents.STREAM_INFO,                  'listener' : onStreamInfo }
	            ];

	            // prettier-ignore
	            var runningListeners = [
	                { 'type' : mediaElementProxyEvents.TIME_UPDATE,             'listener' : onTimeUpdate },
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onStateChange },
	                { 'type' : mediaManagerEvents.STREAM_FRAGMENT,              'listener' : onStreamFragment }
	            ];

	            // prettier-ignore
	            var sourceBufferListeners = [
	                { 'type' : sourceBufferEvents.UPDATE_END,                   'listener' : onUpdateEnd }
	            ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : initListeners
	                });
	            }

	            function destroy () {
	                while (commandQueue.length) {
	                    commandQueue.pop();
	                }

	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : initListeners
	                });
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : runningListeners
	                });
	                if (sourceBuffer) {
	                    listenerManager.remove({
	                        'target'    : sourceBuffer,
	                        'listeners' : sourceBufferListeners
	                    });
	                }

	                sourceBuffer = null;
	            }

	            function onTimeUpdate (e) {
	                currentTime = e.data.currentTime;
	            }

	            function onStreamFragment (e) {
	                append(e.data);
	            }

	            function append (fragment) {
	                apply({
	                    'command'  : APPEND,
	                    'fragment' : fragment
	                });
	            }

	            function remove (from, to) {
	                apply({
	                    'command' : REMOVE,
	                    'from'    : from,
	                    'to'      : to
	                });
	            }

	            function apply (payload) {
	                if (!updating) {
	                    execute(payload);
	                }
	                else {
	                    payload.force ? commandQueue.unshift(payload) : commandQueue.push(payload);
	                }
	            }

	            function execute (payload) {
	                switch (payload.command) {
	                    case APPEND:
	                        if (appendEnabled) {
	                            updating = true;
	                            sourceBuffer.appendBuffer(payload.fragment);
	                            if (!appendedBuffersExceedsThreshold()) {
	                                appendedBuffersCount++;
	                            }
	                        }
	                        break;
	                    case REMOVE:
	                        if (sourceBuffer.buffered.length && sourceBuffer.buffered.end(sourceBuffer.length - 1) > 0) {
	                            updating = true;
	                            sourceBuffer.remove(payload.from, payload.to);
	                        }
	                        break;
	                }
	            }

	            function onUpdateEnd () {
	                updating = false;
	                if (msResetState) {
	                    msResetState = 0;
	                    emitter.emit(mediaSourceManagerEvents.SOURCE_READY);
	                }
	                if (commandQueue.length) {
	                    execute(commandQueue.shift());
	                }
	                else if (startExceedsThreshold() && appendedBuffersExceedsThreshold()) {
	                    //this is needed to avoid QuotaExceededError in some cases
	                    remove(sourceBuffer.buffered.start(0), currentTime - TRIM_NEAR_THRESHOLD);
	                }
	            }

	            function onStreamInfo (e) {
	                //TODO: move sourceBuffer creation to MediaSourceHandler
	                streamInfo = e.data.onStreamInfo;
	                var mime =
	                    streamInfo && streamInfo.mimeType
	                        ? streamInfo.mimeType
	                        : 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
	                if (mediaSource && mediaSource.readyState === 'open') {
	                    if (!sourceBuffer) {
	                        initializeMediasourceBuffer(mime);
	                    }
	                    else {
	                        appendEnabled = true;
	                        if (conditions.isIEorEdge && !isNaN(mediaSource.duration) && mediaSource.duration > 0.0) {
	                            updating = true;
	                            msResetState = 1;
	                            mediaSource.duration = 0.0;
	                        }
	                        else {
	                            emitter.emit(mediaSourceManagerEvents.SOURCE_READY);
	                        }
	                    }
	                }
	                else {
	                    mediaSource.addEventListener(mediaSourceEvents.SOURCE_OPEN, onMediaSourceOpen.bind(null, mime));
	                }
	            }

	            function onMediaSourceOpen (mime) {
	                mediaSource.removeEventListener(mediaSourceEvents.SOURCE_OPEN, onMediaSourceOpen);
	                initializeMediasourceBuffer(mime);
	            }

	            function initializeMediasourceBuffer (mime) {
	                sourceBuffer = mediaSource.addSourceBuffer(mime);
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : runningListeners
	                });
	                listenerManager.add({
	                    'target'    : sourceBuffer,
	                    'listeners' : sourceBufferListeners
	                });
	                appendEnabled = true;
	                emitter.emit(mediaSourceManagerEvents.SOURCE_READY);
	            }

	            function onStateChange (e) {
	                if (e.data.state === playerStates.PAUSED) {
	                    onPause();
	                }
	            }

	            function onPause () {
	                appendEnabled = false;
	                while (commandQueue.length) {
	                    commandQueue.pop();
	                }
	                remove(0, Infinity);
	                appendedBuffersCount = 0;
	            }

	            function startExceedsThreshold () {
	                return (
	                    sourceBuffer.buffered.length && sourceBuffer.buffered.start(0) < currentTime - TRIM_FAR_THRESHOLD
	                );
	            }

	            function appendedBuffersExceedsThreshold () {
	                return APPENDED_BUFFERS_THRESHOLD < appendedBuffersCount;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-10-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = '';

	    return {
	        'BASE': eventBase,

	        'ABORT'        : eventBase + 'abort',
	        'ERROR'        : eventBase + 'error',
	        'UPDATE'       : eventBase + 'update',
	        'UPDATE_START' : eventBase + 'updatestart',
	        'UPDATE_END'   : eventBase + 'updateend'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-08-24.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(24),
	        __webpack_require__(65),
	        __webpack_require__(62)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (logger, listenerManager, mediaControlEvents, mediaManagerEvents) {
	        function create (emitter) {
	            var l = logger.create('FakeAudioContext');
	            var fakeAudioContext;

	            /* eslint-disable */
	            // prettier-ignore
	            var emitterListeners = [
	                { 'type' : mediaManagerEvents.STREAM_INFO,  'listener' : createContext },
	                { 'type' : mediaControlEvents.PAUSE,        'listener' : destroyContext }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('initialize');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	            }

	            function destroy () {
	                destroyContext();
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	            }

	            function createContext (e) {
	                destroyContext();

	                if (!e.data.onStreamInfo.haveAudio) {
	                    window.AudioContext =
	                        window.AudioContext ||
	                        window.webkitAudioContext ||
	                        function () {
	                            return { 'close': function () {} };
	                        };
	                    fakeAudioContext = new AudioContext();
	                }
	            }

	            function destroyContext () {
	                if (fakeAudioContext && typeof fakeAudioContext.close === 'function') {
	                    fakeAudioContext.close();
	                    fakeAudioContext = null;
	                }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-03-06.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(65),
	        __webpack_require__(62),
	        __webpack_require__(66),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        conditions,
	        listenerManager,
	        mediaControlEvents,
	        mediaManagerEvents,
	        mediaElementProxyEvents,
	        playerStates
	    ) {
	        function create (emitter) {
	            var MAX_FREEZE_CYCLE_COUNT = 10;
	            var GAP_DETECT_THRESHOLD = 0.2;
	            var RANGE_MINIMUM_LENGTH = 0.5;

	            var l = logger.create('GapHandler');
	            var playerState;
	            var lastTimePosition;
	            var freezeCycleCount = 0;

	            /* eslint-disable */
	            // prettier-ignore
	            var emitterListeners = [
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onStateChange }
	            ];

	            // prettier-ignore
	            var playStateListeners = [
	                { 'type' : mediaElementProxyEvents.TIME_UPDATE,             'listener' : onTimeUpdate }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('initialize');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : playStateListeners
	                });
	            }

	            function onStateChange (e) {
	                playerState = e.data.state;

	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : playStateListeners
	                });

	                if (
	                    (conditions.isIEorEdge && playerState === playerStates.PLAYING) ||
	                    (!conditions.isIEorEdge && playerState !== playerStates.PAUSED)
	                ) {
	                    listenerManager.add({
	                        'target'    : emitter,
	                        'listeners' : playStateListeners
	                    });
	                }
	            }

	            function onTimeUpdate (e) {
	                var current = getCurrentRangeIndex(e.data.currentTime, e.data.buffered);
	                var next = getNextRangeIndex(e.data.currentTime, e.data.buffered);

	                if (lastTimePosition === e.data.currentTime) {
	                    freezeCycleCount++;
	                    if (freezeCycleCount < MAX_FREEZE_CYCLE_COUNT) {
	                        return;
	                    }

	                    if (
	                        next > current &&
	                        getRangeLength(e.data.buffered, next) > RANGE_MINIMUM_LENGTH &&
	                        isNearRangeEnd(e.data.currentTime, e.data.buffered)
	                    ) {
	                        var seekPosition = e.data.buffered.start(
	                            getNextRangeIndex(e.data.currentTime, e.data.buffered)
	                        );

	                        l.debug('recover gap, seek to ' + seekPosition, 3);

	                        emitter.emit(mediaControlEvents.SEEK, { 'position': seekPosition });
	                        emitter.emit(mediaControlEvents.PLAY);
	                    }
	                }

	                lastTimePosition = e.data.currentTime;
	                freezeCycleCount = 0;
	            }

	            function isNearRangeEnd (currentTime, buffered) {
	                return currentTime + GAP_DETECT_THRESHOLD >= buffered.end(getCurrentRangeIndex(currentTime, buffered));
	            }

	            function getCurrentRangeIndex (currentTime, buffered) {
	                var index = 0;
	                while (index < buffered.length - 1 && buffered.start(index + 1) <= currentTime) {
	                    index++;
	                }
	                return index;
	            }

	            function getNextRangeIndex (currentTime, buffered) {
	                var index = 0;
	                while (index < buffered.length - 1 && buffered.start(index) <= currentTime) {
	                    index++;
	                }
	                return index;
	            }

	            function getRangeLength (buffered, index) {
	                return index < buffered.length ? buffered.end(index) - buffered.start(index) : 0;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(18),
	        __webpack_require__(24),
	        __webpack_require__(64),
	        __webpack_require__(62),
	        __webpack_require__(69),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        objectUtils,
	        listenerManager,
	        handlerEvents,
	        mediaManagerEvents,
	        statsCollectorEvents,
	        playerStates
	    ) {
	        function create (emitter) {
	            var JUMP_THRESHOLD = 2;

	            var l = logger.create('HLSJumpHandler');
	            var stats;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange }
	            ];

	            // prettier-ignore
	            var playStateListeners = [
	                { 'type' : statsCollectorEvents.PLAY_STATS,                 'listener' : onPlayStats }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('initialize');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onApplicationStateChange (e) {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : playStateListeners
	                });
	                var playerState = e.data.state;
	                switch (playerState) {
	                    case playerStates.PAUSED:
	                    case playerStates.PAUSING:
	                        l.debug('entering paused state');
	                        stats = null;
	                        break;
	                    case playerStates.PLAYING:
	                        listenerManager.add({
	                            'target'    : emitter,
	                            'listeners' : playStateListeners
	                        });
	                        break;
	                    default:
	                        break;
	                }
	            }

	            function onPlayStats (e) {
	                if (
	                    stats &&
	                    typeof stats.currentTime !== 'undefined' &&
	                    e.data.stats.currentTime < stats.currentTime - JUMP_THRESHOLD
	                ) {
	                    var payload = {
	                        'currentTime': {
	                            'last'    : stats.currentTime,
	                            'current' : e.data.stats.currentTime
	                        }
	                    };
	                    emitter.emit(handlerEvents.ERROR, payload);
	                }
	                stats = objectUtils.copy(e.data.stats);
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(11),
	        __webpack_require__(32),
	        __webpack_require__(22),
	        __webpack_require__(24),
	        __webpack_require__(64),
	        __webpack_require__(65),
	        __webpack_require__(62),
	        __webpack_require__(66),
	        __webpack_require__(86),
	        __webpack_require__(9)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        browserInfo,
	        logger,
	        conditions,
	        listenerManager,
	        handlerEvents,
	        mediaControlEvents,
	        mediaManagerEvents,
	        mediaElementProxyEvents,
	        visibilityEvents,
	        playerStates
	    ) {
	        function create (emitter) {
	            var l = logger.create('PauseHandler');

	            var waitTimeout = 0,
	                hidden = false,
	                playerState;

	            /* eslint-disable */
	            // prettier-ignore
	            var listeners = [
	                { 'type' : mediaElementProxyEvents.PAUSE,                   'listener' : onMediaEvent },
	                { 'type' : mediaElementProxyEvents.WAITING,                 'listener' : onMediaEvent },
	                { 'type' : mediaElementProxyEvents.ENDED,                   'listener' : onMediaEvent },
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange },
	                { 'type' : visibilityEvents.HIDDEN,                         'listener' : onVisibilityChange },
	                { 'type' : visibilityEvents.VISIBLE,                        'listener' : onVisibilityChange }
	            ];
	            /* eslint-enable */

	            function init () {
	                l.debug('initialize');
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	            }

	            function onVisibilityChange (e) {
	                hidden = e.name === visibilityEvents.HIDDEN;
	                l.debug(hidden ? 'hidden' : 'visible');
	            }

	            function onMediaEvent (e) {
	                var delay = e.data.buffered.length ? e.data.buffered.end(0) - e.data.currentTime : 'n.a.';

	                if (
	                    ((conditions.useHLS && e.name === mediaElementProxyEvents.PAUSE) ||
	                        (hidden && browserInfo.mobile)) &&
	                    playerState === playerStates.PLAYING
	                ) {
	                    emitter.emit(handlerEvents.SUSPENDED);
	                }
	                else if (!waitTimeout) {
	                    waitTimeout = setTimeout(function () {
	                        if (playerState === playerStates.PLAYING) {
	                            l.debug('nanoplayer: recover unexpected pause type ' + e.name + ', delay = ' + delay, 3);
	                            emitter.emit(mediaControlEvents.PLAY);
	                        }
	                        waitTimeout = 0;
	                    }, 200);
	                }
	            }

	            function onApplicationStateChange (e) {
	                playerState = e.data.state;
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by user on 8/11/2017.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var eventBase = 'visibility.';

	    return {
	        'BASE': eventBase,

	        'HIDDEN'  : eventBase + 'hidden',
	        'VISIBLE' : eventBase + 'visible'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-03-06.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(32),
	        __webpack_require__(24),
	        __webpack_require__(9),
	        __webpack_require__(65),
	        __webpack_require__(62),
	        __webpack_require__(66),
	        __webpack_require__(68)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        logger,
	        listenerManager,
	        playerStates,
	        mediaControlEvents,
	        mediaManagerEvents,
	        mediaElementProxyEvents,
	        qualityHandlerEvents
	    ) {
	        function create (emitter) {
	            var l = logger.create('QualityHandler');

	            var CHECK_INTERVAL = 1000;
	            var CHECK_TIMEOUT = 10000;

	            var DROPPED_FRAMES_RATIO_THRESHOLD_HIGH = 0.2;
	            var DROPPED_FRAMES_SAMPLES_RANGE_HIGH = 5;
	            var DROPPED_FRAMES_SAMPLES_MATCH_ALLOWED_HIGH = 1;

	            var DROPPED_FRAMES_RATIO_THRESHOLD_MEDIUM = 0.1;
	            var DROPPED_FRAMES_SAMPLES_RANGE_MEDIUM = 10;
	            var DROPPED_FRAMES_SAMPLES_MATCH_ALLOWED_MEDIUM = 3;

	            var measuredQuality,
	                droppedFrames = [];
	            var haveVideo = false,
	                frameRate = 0;
	            var playerState;
	            var checkInterval = 0,
	                checkEnabled = true;

	            /* eslint-disable */
	            // prettier-ignore
	            var emitterListeners = [
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onStateChange },
	                { 'type' : mediaManagerEvents.STREAM_INFO,                  'listener' : onStreamInfo }
	            ];
	            // prettier-ignore
	            var mediaListeners = [
	                { 'type' : mediaElementProxyEvents.QUALITY_UPDATE,          'listener' : onQualityUpdate }
	            ];
	            /* eslint-enable */

	            function init () {
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : emitterListeners
	                });
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : mediaListeners
	                });
	            }

	            function reset () {
	                measuredQuality = {
	                    'droppedVideoFrames'          : 0,
	                    'droppedVideoFramesCurrent'   : 0,
	                    'corruptedVideoFrames'        : 0,
	                    'corruptedVideoFramesCurrent' : 0,
	                    'creationTime'                : 0,
	                    'totalVideoFrames'            : 0
	                };
	                while (droppedFrames.length) {
	                    droppedFrames.pop();
	                }
	                checkEnabled = true;
	            }

	            function onStateChange (e) {
	                playerState = e.data.state;
	                if (playerState === playerStates.PAUSED) {
	                    disable();
	                }
	                else if (!checkInterval && haveVideo && playerState === playerStates.PLAYING) {
	                    enable();
	                }
	            }

	            function onStreamInfo (e) {
	                haveVideo = e.data.onStreamInfo.haveVideo && (frameRate = e.data.onStreamInfo.videoInfo.frameRate);
	            }

	            function enable () {
	                disable();
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : mediaListeners
	                });
	                checkInterval = setInterval(check, CHECK_INTERVAL);
	            }

	            function disable () {
	                clearInterval(checkInterval);
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : mediaListeners
	                });
	                checkInterval = 0;
	                reset();
	            }

	            function onQualityUpdate (e) {
	                for (var key in e.data.quality)
	                    if (measuredQuality.hasOwnProperty(key)) {
	                        if (key === 'droppedVideoFrames') {
	                            measuredQuality.droppedVideoFramesCurrent =
	                                e.data.quality.droppedVideoFrames - measuredQuality.droppedVideoFrames;
	                            while (droppedFrames.length > DROPPED_FRAMES_SAMPLES_RANGE_MEDIUM - 1) {
	                                droppedFrames.shift();
	                            }
	                            droppedFrames.push({
	                                'count' : measuredQuality.droppedVideoFramesCurrent,
	                                'time'  : e.data.currentTime
	                            });
	                        }
	                        if (key === 'corruptedVideoFrames') {
	                            measuredQuality.corruptedVideoFramesCurrent =
	                                e.data.quality.corruptedVideoFrames - measuredQuality.corruptedVideoFrames;
	                        }
	                        measuredQuality[key] = e.data.quality[key];
	                    }
	                emitter.emit(qualityHandlerEvents.QUALITY_STATS, measuredQuality);
	            }

	            function check () {
	                if (playerState === playerStates.PLAYING && checkEnabled) {
	                    var dropping;
	                    var filtered;
	                    if (droppedFrames.length > DROPPED_FRAMES_SAMPLES_RANGE_HIGH - 1) {
	                        filtered = droppedFrames.filter(function (item, index) {
	                            return (
	                                droppedFrames.length - index <= DROPPED_FRAMES_SAMPLES_RANGE_HIGH &&
	                                item.count >= frameRate * DROPPED_FRAMES_RATIO_THRESHOLD_HIGH
	                            );
	                        });
	                        if (filtered.length > DROPPED_FRAMES_SAMPLES_MATCH_ALLOWED_HIGH) {
	                            droppedFrames.splice(0, droppedFrames.length - DROPPED_FRAMES_SAMPLES_RANGE_HIGH);
	                            dropping = {
	                                'type'      : 'high',
	                                'framerate' : frameRate,
	                                'samples'   : {
	                                    'all'     : droppedFrames,
	                                    'matched' : filtered,
	                                    'limit'   : Math.ceil(frameRate * DROPPED_FRAMES_RATIO_THRESHOLD_HIGH)
	                                }
	                            };
	                        }
	                    }
	                    if (!dropping && droppedFrames.length > DROPPED_FRAMES_SAMPLES_RANGE_MEDIUM - 1) {
	                        filtered = droppedFrames.filter(function (item) {
	                            return item.count >= frameRate * DROPPED_FRAMES_RATIO_THRESHOLD_MEDIUM;
	                        });
	                        if (filtered.length > DROPPED_FRAMES_SAMPLES_MATCH_ALLOWED_MEDIUM) {
	                            dropping = {
	                                'type'      : 'medium',
	                                'framerate' : frameRate,
	                                'samples'   : {
	                                    'all'     : droppedFrames,
	                                    'matched' : filtered,
	                                    'limit'   : Math.ceil(frameRate * DROPPED_FRAMES_RATIO_THRESHOLD_MEDIUM)
	                                }
	                            };
	                        }
	                    }
	                    if (dropping && checkEnabled) {
	                        checkEnabled = false;
	                        l.debug('frame drop detected with type \'' + dropping.type + '\'', 3);
	                        emitter.emit(qualityHandlerEvents.FRAME_DROP, dropping);
	                        setTimeout(function () {
	                            checkEnabled = true;
	                        }, CHECK_TIMEOUT);
	                    }
	                }
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-08-24.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(34),
	        __webpack_require__(24),
	        __webpack_require__(22),
	        __webpack_require__(73),
	        __webpack_require__(9),
	        __webpack_require__(62),
	        __webpack_require__(65),
	        __webpack_require__(66),
	        __webpack_require__(69)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        performance,
	        listenerManager,
	        conditions,
	        valueCollector,
	        playerStates,
	        mediaManagerEvents,
	        mediaControlEvents,
	        mediaElementProxyEvents,
	        statsCollectorEvents
	    ) {
	        function create (emitter) {
	            var stats;
	            var playerState;

	            var timeStamp = 0;
	            var haveVideo;

	            var bufferDelays, bufferUpdates, bitrates, framerates, fragmentCount, fragmentSizeSum;

	            /* eslint-disable */
	            // prettier-ignore
	            var controlListeners = [
	                { 'type' : mediaManagerEvents.APPLICATION_STATE_CHANGE,     'listener' : onApplicationStateChange }
	            ];
	            // prettier-ignore
	            var streamListeners = [
	                { 'type' : mediaManagerEvents.STREAM_FRAGMENT,              'listener' : onStreamFragment },
	                { 'type' : mediaManagerEvents.STREAM_INFO,                  'listener' : onStreamInfo }
	            ];
	            // prettier-ignore
	            var statsListeners = [
	                { 'type' : mediaElementProxyEvents.TIME_UPDATE,             'listener' : onMediaTimeUpdate }
	            ];
	            /* eslint-enable */

	            function init () {
	                resetStats();
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : controlListeners
	                });
	                listenerManager.add({
	                    'target'    : emitter,
	                    'listeners' : streamListeners
	                });
	            }

	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : streamListeners
	                });
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : controlListeners
	                });
	            }

	            function onApplicationStateChange (e) {
	                playerState = e.data.state;
	                switch (playerState) {
	                    case playerStates.PAUSED:
	                        listenerManager.remove({
	                            'target'    : emitter,
	                            'listeners' : statsListeners
	                        });
	                        break;
	                    case playerStates.PLAYING:
	                        break;
	                    case playerStates.LOADING:
	                        resetStats();
	                        conditions.useHLS &&
	                            listenerManager.add({
	                                'target'    : emitter,
	                                'listeners' : statsListeners
	                            });
	                        break;
	                }
	            }

	            function onStreamFragment (e) {
	                fragmentCount += 1;
	                fragmentSizeSum += e.data.byteLength;
	            }

	            function onStreamInfo (e) {
	                !conditions.useHLS &&
	                    listenerManager.add({
	                        'target'    : emitter,
	                        'listeners' : statsListeners
	                    });
	                haveVideo = e.data.onStreamInfo.haveVideo;
	            }

	            function onMediaTimeUpdate (e) {
	                var bufindex = e.data.buffered.length - 1;
	                var playindex = e.data.played.length - 1;

	                stats.currentTime = playerState === playerStates.LOADING ? 0 : e.data.currentTime;

	                if (playindex >= 0) {
	                    stats.playout.start = e.data.played.start(playindex);
	                    stats.playout.end = e.data.played.end(playindex);
	                }

	                if (bufindex >= 0) {
	                    if (
	                        !conditions.useHLS ||
	                        (conditions.useHLS &&
	                            (stats.buffer.end !== e.data.buffered.end(bufindex) ||
	                                e.data.buffered.end(bufindex) < stats.currentTime))
	                    ) {
	                        stats.buffer.update.current = e.data.buffered.end(bufindex) - stats.buffer.end;
	                        stats.buffer.delay.before = stats.buffer.end - stats.currentTime;

	                        stats.buffer.start = e.data.buffered.start(bufindex);
	                        stats.buffer.end = e.data.buffered.end(bufindex);

	                        stats.buffer.delay.current = stats.buffer.end - stats.currentTime;

	                        bufferDelays.add(stats.buffer.delay.current);
	                        transferValues(bufferDelays, stats.buffer.delay);

	                        bufferUpdates.add(stats.buffer.update.current);
	                        transferValues(bufferUpdates, stats.buffer.update);
	                    }
	                }
	                if (performance && !conditions.useHLS) {
	                    var now = Math.floor(performance.now() / 1000);
	                    if (timeStamp !== now) {
	                        timeStamp = now;
	                        stats.bitrate.current = fragmentSizeSum * 8;

	                        bitrates.add(stats.bitrate.current);
	                        transferValues(bitrates, stats.bitrate);

	                        if (haveVideo) {
	                            stats.framerate.current = fragmentCount;
	                            framerates.add(stats.framerate.current);
	                            transferValues(framerates, stats.framerate);
	                        }

	                        fragmentCount = 0;
	                        fragmentSizeSum = 0;
	                    }
	                }

	                emit(e);
	            }

	            function emit (e) {
	                emitter.emit(statsCollectorEvents.PLAY_STATS, {
	                    'stats'        : stats,
	                    'buffered'     : e ? e.data.buffered : null, //TODO: remove this
	                    'played'       : e ? e.data.played : null, //TODO: remove this
	                    'currentTime'  : e ? e.data.currentTime : 0, //TODO: remove this
	                    'playbackRate' : e ? e.data.playbackRate : 0 //TODO: remove this
	                });
	            }

	            function transferValues (collector, target) {
	                target.avg = collector.arithmetic;
	                target.min = collector.minimum;
	                target.max = collector.maximum;
	            }

	            function resetStats () {
	                stats = {
	                    'currentTime' : 0,
	                    'playout'     : {
	                        'start' : 0,
	                        'end'   : 0
	                    },
	                    'buffer': {
	                        'start' : 0,
	                        'end'   : 0,
	                        'delay' : {
	                            'before'  : 0,
	                            'current' : 0,
	                            'avg'     : 0,
	                            'min'     : 0,
	                            'max'     : 0
	                        },
	                        'update': {
	                            'current' : 0,
	                            'avg'     : 0,
	                            'min'     : 0,
	                            'max'     : 0
	                        }
	                    },
	                    'quality': {
	                        'droppedVideoFrames'          : 0,
	                        'droppedVideoFramesCurrent'   : 0,
	                        'corruptedVideoFrames'        : 0,
	                        'corruptedVideoFramesCurrent' : 0,
	                        'creationTime'                : 0,
	                        'totalVideoFrames'            : 0
	                    },
	                    'bitrate': {
	                        'current' : 0,
	                        'avg'     : 0,
	                        'min'     : 0,
	                        'max'     : 0
	                    },
	                    'framerate': {
	                        'current' : 0,
	                        'avg'     : 0,
	                        'min'     : 0,
	                        'max'     : 0
	                    }
	                };
	                bufferDelays = valueCollector.create(10);
	                bufferUpdates = valueCollector.create(10);
	                bitrates = valueCollector.create(10);
	                framerates = valueCollector.create(10);

	                fragmentCount = 0;
	                fragmentSizeSum = 0;

	                emit(null);
	            }

	            init();

	            return {
	                'destroy': destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-02-20.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(62)], __WEBPACK_AMD_DEFINE_RESULT__ = function (mediaManagerEvents) {
	    function create (emitter) {
	        function init () {
	            if (isEnabled()) emitter.addListener(mediaManagerEvents.STREAM_FRAGMENT, onStreamFragment);
	        }

	        function destroy () {
	            emitter.removeListener(mediaManagerEvents.STREAM_FRAGMENT, onStreamFragment);
	        }

	        function onStreamFragment (e) {
	            if (!window.fragments) window.fragments = [];

	            window.fragments.push(e.data);
	        }

	        function isEnabled () {
	            return !!getCookieValue('nanoDump');
	        }

	        //TODO: move cookie handling to separate module (also in Debug)?
	        function getCookieValue (cookie) {
	            return document.cookie.indexOf(cookie + '=') !== -1
	                ? document.cookie.split(cookie + '=')[1].split(';')[0]
	                : null;
	        }

	        init();

	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2017-11-08.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(32), __webpack_require__(86)], __WEBPACK_AMD_DEFINE_RESULT__ = function (logger, visibilityEvents) {
	    function create (emitter) {
	        var l = logger.create('VisibilityProxy');

	        var propertyName;
	        var eventName;

	        var hidden = false;

	        function init () {
	            l.debug('initialize');

	            if (typeof document.hidden !== 'undefined') {
	                propertyName = 'hidden';
	                eventName = 'visibilitychange';
	            }
	            else if (typeof document.msHidden !== 'undefined') {
	                propertyName = 'msHidden';
	                eventName = 'msvisibilitychange';
	            }
	            else if (typeof document.webkitHidden !== 'undefined') {
	                propertyName = 'webkitHidden';
	                eventName = 'webkitvisibilitychange';
	            }

	            document.addEventListener(eventName, onVisibilityChange);
	        }

	        function destroy () {
	            document.removeEventListener(eventName, onVisibilityChange);
	        }

	        function onVisibilityChange () {
	            hidden = document[propertyName];
	            l.debug(hidden ? 'hidden' : 'visible');
	            emitter.emit(hidden ? visibilityEvents.HIDDEN : visibilityEvents.VISIBLE);
	        }

	        init();

	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	// native.js

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(21), __webpack_require__(15), __webpack_require__(16), __webpack_require__(17), __webpack_require__(11)], __WEBPACK_AMD_DEFINE_RESULT__ = function (IPlayer, techNames, Version, Debug, configHandler, BrowserInfo) {
	        'use strict';

	        function NativePlayer (playerDivId) {
	            this.version = Version.CORE;

	            this.type = 'native';

	            this.config = {
	                'playback': {
	                    'autoplay' : true,
	                    'muted'    : false
	                },
	                'source': {
	                    'hls': undefined
	                }
	            };

	            this._playerDivId = playerDivId;
	        }

	        NativePlayer.isSupported = function () {
	            return BrowserInfo.os === 'iOS' || BrowserInfo.browser === 'Safari';
	        };

	        NativePlayer.supportedTechniques = [techNames.NATIVE];

	        var proto = (NativePlayer.prototype = Object.create(IPlayer.prototype));

	        proto.setup = function (config) {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                try {
	                    if (typeof config !== 'undefined') {
	                        configHandler.merge(config, self.config);
	                        configHandler.clean(self.config);

	                        window.location = self.config.source.hls;
	                        resolve(self.config);
	                    }
	                    else {
	                        reject(Error('No config passed'));
	                    }
	                }
	                catch (err) {
	                    reject(err);
	                }
	            });
	        };

	        proto.play = function () {};

	        proto.pause = function () {};

	        proto.mute = function () {};

	        proto.unmute = function () {};

	        proto.setVolume = function () {};

	        return NativePlayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	// flashplayer.js

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(5),
	        __webpack_require__(21),
	        __webpack_require__(20),
	        __webpack_require__(15),
	        __webpack_require__(93),
	        __webpack_require__(6),
	        __webpack_require__(16),
	        __webpack_require__(17),
	        __webpack_require__(7),
	        __webpack_require__(8),
	        __webpack_require__(94),
	        __webpack_require__(9),
	        __webpack_require__(4),
	        __webpack_require__(49)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        IPlayer,
	        techNames,
	        configErrorMessages,
	        Version,
	        FlashEmbed,
	        EventEmitter,
	        Debug,
	        configHandler,
	        emptyConfig,
	        events,
	        flashState,
	        playerState,
	        pauseReason,
	        streamInfoProperties
	    ) {
	        var __debug = Debug.log;

	        function FlashPlayer (playerDivId) {
	            this.version = Version.CORE;

	            this.type = 'flash';

	            this.config = emptyConfig.create();

	            this._volume = 1.0;

	            this._muted = false;

	            this._mediaElement = null;

	            this._mediaSource = null;

	            this._playing = false;

	            this._playerDivId = playerDivId;

	            this._playerDiv = document.getElementById(this._playerDivId);

	            this._mediaElementId = 'flash-' + playerDivId;

	            this.state = this.STATE.IDLE;

	            this._triggered = 0;

	            this._stats = {
	                'currentTime' : 0,
	                'playout'     : {
	                    'start' : 0,
	                    'end'   : 0
	                },
	                'buffer': {
	                    'start' : 0,
	                    'end'   : 0,
	                    'delay' : {
	                        'current' : 0,
	                        'avg'     : 0,
	                        'min'     : 0,
	                        'max'     : 0
	                    }
	                }
	            };

	            this._intervalEmitStats = 0;

	            this._streamInfo = null;
	        }

	        FlashPlayer.isSupported = function () {
	            return FlashEmbed.ua.pv[0] !== 0;
	        };

	        FlashPlayer.supportedTechniques = [techNames.FLASH];

	        var proto = (FlashPlayer.prototype = Object.create(IPlayer.prototype));

	        /*/////////////////////////////////////////

	    Public API

	    /////////////////////////////////////////*/

	        proto.setup = function (config) {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                try {
	                    if (FlashEmbed.ua.pv === [0, 0, 0]) {
	                        reject(Error('No flash available'));
	                    }
	                    else if (typeof config !== 'undefined') {
	                        self._baseSetup(config).then(resolve, reject);
	                    }
	                    else {
	                        reject(Error('No config passed'));
	                    }
	                }
	                catch (err) {
	                    reject(err);
	                }
	            });
	        };

	        proto.play = function () {
	            this._setMediaElement();
	            this._mediaElement.Start();
	        };

	        proto.pause = function () {
	            this._triggered = arguments.length;
	            clearTimeout(this._bufferTimeout);
	            this._setMediaElement();
	            this._mediaElement.Stop();
	        };

	        proto.mute = function () {
	            this._setMediaElement();
	            this._muted = true;
	            this._mediaElement.SetVolume(0);
	            this._emit(events.MUTE);
	        };

	        proto.unmute = function () {
	            this._setMediaElement();
	            this._muted = false;
	            this._mediaElement.SetVolume(this._volume);
	            this._emit(events.UNMUTE);
	        };

	        proto.setVolume = function (volume) {
	            if (volume < 0) {
	                volume = 0;
	            }
	            if (volume > 1) {
	                volume = 1;
	            }
	            this._setMediaElement();
	            this._volume = volume;
	            if (!this._muted) {
	                this._mediaElement.SetVolume(this._volume);
	            }
	            this._emit(events.VOLUME_CHANGE, { 'volume': volume });
	        };

	        proto.destroy = function () {
	            this.removeAllListeners();
	            if (this._mediaElement) {
	                this.pause();
	                document.getElementById(this._playerDivId).removeChild(this._mediaElement);
	                this._mediaElement = null;
	            }
	            clearTimeout(this._bufferTimeout);
	        };

	        proto._baseSetup = function (config) {
	            configHandler.merge(config, this.config);
	            configHandler.clean(this.config);
	            var src = this.config.source.h5live.rtmp;
	            var params = this.config.source.h5live.params;
	            if ((!src || !src.url || !src.streamname) && (!params || !params.url || !params.stream)) {
	                return this._setupError(configErrorMessages.CONFIG_RTMP);
	            }
	            else {
	                this._emitter = new EventEmitter();
	                this._setListeners(this.config.events, this);
	                this._metaDataEnabled = this.config.playback.metadata;
	                this._setupVideoElement();
	                return this._setupFinish();
	            }
	        };

	        proto._setupError = function (error) {
	            return new Promise(function (resolve, reject) {
	                reject(error);
	            });
	        };

	        proto._setupVideoElement = function () {
	            var flashPath = 'nano.player.swf';
	            if (typeof this.config.playback.flashplayer !== 'undefined') {
	                flashPath = this.config.playback.flashplayer;
	            }
	            var placeholder = document.createElement('div');
	            placeholder.setAttribute('id', 'flashReplace');
	            this._playerDiv.appendChild(placeholder);
	            var swfVersionStr = '9.0.0';
	            var flashvars = {};
	            var params = {};
	            params.quality = 'high';
	            params.bgcolor = '#000000';
	            params.allowscriptaccess = 'always';
	            params.allowfullscreen = 'true';
	            params.allowfullscreeninteractive = 'true';
	            params.wmode = 'transparent';
	            var attributes = {};
	            attributes.id = this._mediaElementId;
	            attributes.name = this._mediaElementId;
	            attributes.align = 'middle';
	            attributes.wmode = 'transparent';
	            FlashEmbed.embedSWF(
	                flashPath,
	                'flashReplace',
	                '100%',
	                '100%',
	                swfVersionStr,
	                null,
	                flashvars,
	                params,
	                attributes
	            );
	        };

	        proto._setupFinish = function () {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                var embedInterval = 0,
	                    counts = 0;
	                function init () {
	                    counts++;
	                    if (embedInterval) {
	                        self._mediaElement = document.getElementById(self._mediaElementId);
	                        if (self._mediaElement && self._mediaElement.Start) {
	                            clearInterval(embedInterval);
	                            try {
	                                window._flashPlayers[self._mediaElementId] = self;
	                                self._setName();
	                                self._mediaElement.TraceExternalFunctions();
	                                self._setNetStream(false);
	                                self._setConnectionConfig(self.config.source.h5live);
	                                self._setPlayerConfig(self._playerDiv.offsetWidth, self._playerDiv.offsetHeight);
	                                if (self.config.playback.muted) {
	                                    self.mute();
	                                }
	                                self.config.type = self.type;
	                                self._setState(self.STATE.READY);
	                                self._emit(events.READY, { 'config': self.config });
	                                if (self.config.playback.autoplay) {
	                                    self.play();
	                                }
	                                resolve(self.config);
	                            }
	                            catch (err) {
	                                reject(err);
	                            }
	                        }
	                    }
	                    if (counts > 100) {
	                        clearInterval(embedInterval);
	                        reject(
	                            Error(
	                                'Could not find and embed the player.swf. Please check the path to the player in the config param "playback.flashplayer" or copy to base directory.'
	                            )
	                        );
	                    }
	                }
	                embedInterval = setInterval(init, 100);
	            });
	        };

	        proto._setListeners = function (events, target) {
	            for (var key in events) {
	                if (events.hasOwnProperty(key) && typeof events[key] === 'function') {
	                    var event = key.replace('on', '');
	                    var handler = events[key];
	                    target.on(event, handler);
	                }
	            }
	        };

	        proto._setState = function (state) {
	            this.state = state;
	            __debug('nanoplayer (' + this._playerDivId + '): set state "' + this._getState() + '"', 3);
	            //keep as legacy until removable
	            this._emit(events.STATE_CHANGE);
	        };

	        proto._getState = function () {
	            for (var key in this.STATE) {
	                if (this.STATE[key] === this.state) {
	                    return key;
	                }
	            }
	        };

	        proto._emit = function (name, data) {
	            var evt = {};
	            evt.name = name || 'unknown';
	            evt.state = this.state;
	            evt.data = data || {};
	            evt.player = this._playerDivId;
	            if (!evt.data.currentTarget) {
	                evt.data.currentTarget = this._mediaElement;
	            }
	            if (name === 'Error' && evt.data.code && evt.data.message) {
	                __debug('nanoplayer (' + this._playerDivId + '): error ' + evt.data.code + ' ' + evt.data.message, 1);
	                return this._emitError(evt.data.code, evt.data.message);
	            }
	            this.emit(evt.name, evt);
	        };

	        proto._emitError = function (code, message) {
	            this._emit(events.ERROR, {
	                'code'    : code,
	                'message' : message
	            });
	        };

	        proto._setConnectionConfig = function (config) {
	            this._setMediaElement();
	            var rtmp = config.rtmp,
	                params = config.params;
	            var url = params && params.url ? params.url : rtmp && rtmp.url ? rtmp.url : null;
	            var stream = params && params.stream ? params.stream : rtmp && rtmp.streamname ? rtmp.streamname : null;
	            if (url && stream) {
	                this.config.url = url + '/' + stream;
	                this._mediaElement.SetServerUrl(url);
	                this._mediaElement.SetStreamName(stream);
	            }
	            else {
	                this.config.url = '';
	            }
	        };

	        proto._setPlayerConfig = function (width, height) {
	            this._setMediaElement();
	            this._mediaElement.SetVideoDisplayResolution(width + ',' + height);
	            this._mediaElement.SetResize('false');
	            this._mediaElement.SetOnlyThisResolution(width + ',' + height);
	        };

	        proto._setNetStream = function (enable) {
	            this._setMediaElement();
	            this._mediaElement.UseNetstream(enable ? 1 : 0);
	        };

	        proto._setMediaElement = function () {
	            var el = document.getElementById(this._mediaElementId);
	            this._mediaElement = el;
	        };

	        proto._getPauseReason = function (triggered) {
	            var reason = '';
	            if (!triggered) {
	                reason = pauseReason.NORMAL;
	            }
	            else {
	                switch (this.state) {
	                    case this.STATE.READY: {
	                        reason = pauseReason.SERVER_NOT_FOUND;
	                        break;
	                    }
	                    case this.STATE.LOADING: {
	                        reason = pauseReason.STREAM_NOT_FOUND;
	                        break;
	                    }
	                    case this.STATE.BUFFERING: {
	                        reason = pauseReason.BUFFER;
	                        break;
	                    }
	                    case this.STATE.UNKNOWN: {
	                        reason = pauseReason.UNKNOWN;
	                        break;
	                    }
	                    case this.STATE.PLAYING: {
	                        reason = pauseReason.NORMAL;
	                        break;
	                    }
	                    default: {
	                        reason = pauseReason.NORMAL;
	                        break;
	                    }
	                }
	            }
	            return reason;
	        };

	        proto._startIntervals = function () {
	            var self = this;
	            this._stopIntervals();
	            this._onStats(true);
	            this._intervalEmitStats = setInterval(self._onStats.bind(self), 100);
	        };

	        proto._stopIntervals = function () {
	            var self = this;
	            if (self._intervalEmitStats) {
	                clearInterval(self._intervalEmitStats);
	                self._intervalEmitStats = 0;
	            }
	        };

	        proto._onStreamInfo = function (event) {
	            __debug('nanoplayer (' + this._playerDivId + '): onStreamInfo', 2);
	            this._streamInfo = event.onStreamInfo;
	            this._emit(events.STREAM_INFO, { 'streamInfo': this._parseStreamInfo() });
	        };

	        proto._parseStreamInfo = function () {
	            var info = {},
	                excludes = [streamInfoProperties.PREROLL_DURATION, streamInfoProperties.MIME_TYPE];
	            for (var key in streamInfoProperties) {
	                var prop = streamInfoProperties[key];
	                if (
	                    streamInfoProperties.hasOwnProperty(key) &&
	                    this._streamInfo.hasOwnProperty(prop) &&
	                    excludes.indexOf(prop) === -1
	                ) {
	                    info[prop] = this._streamInfo[prop];
	                }
	            }
	            return info;
	        };

	        proto._onStats = function (reset) {
	            var time = reset ? 0.0 : this._stats.currentTime + 0.1;
	            this._stats.currentTime = time;
	            var s = 'stats error';
	            try {
	                s = JSON.stringify(this._stats);
	            }
	            catch (e) {}
	            __debug('nanoplayer (' + this._playerDivId + '): stats - ' + s, 4);
	            this._emit(events.STATS, { 'stats': this._stats });
	        };

	        proto._onLoading = function () {
	            var self = this;
	            this._playing = true;
	            this._setState(this.STATE.LOADING);
	            this._emit(events.LOADING);
	            this._loadingTimout = setTimeout(function () {
	                clearTimeout(self._loadingTimout);
	                self._loadingTimout = 0;
	                if (self.state !== self.STATE.PLAYING) {
	                    self.pause();
	                }
	            }, 50000);
	        };

	        proto._onPlaying = function () {
	            var self = this;
	            this._setState(this.STATE.PLAYING);
	            this._startPlayingTimeout && clearTimeout(this._startPlayingTimeout);
	            this._startPlayingTimeout = setTimeout(function () {
	                clearTimeout(self._startPlayingTimeout);
	                self._startPlayingTimeout = 0;
	                if (self.state === self.STATE.PLAYING) {
	                    self._playing = true;
	                    self.setVolume(self._volume);
	                    !self._intervalEmitStats && self._emit(events.PLAY);
	                    !self._intervalEmitStats && self._startIntervals();
	                }
	            }, 1000);
	        };

	        proto._onStartBuffering = function () {
	            var self = this;
	            if (this.state === this.STATE.LOADING) return;
	            this._setState(self.STATE.BUFFERING);
	            this._startBufferTimeout && clearTimeout(this._startBufferTimeout);
	            this._startBufferTimeout = setTimeout(function () {
	                clearTimeout(self._startBufferTimeout);
	                self._startBufferTimeout = 0;
	                if (self.state === self.STATE.BUFFERING) {
	                    self._playing = false;
	                    self._emit(events.START_BUFFERING);
	                    self._bufferTimeout = setTimeout(function () {
	                        clearTimeout(self._bufferTimeout);
	                        if (self.state !== self.STATE.PLAYING) {
	                            self.pause();
	                        }
	                    }, 20000);
	                }
	            }, 2000);
	        };

	        proto._onStopBuffering = function () {
	            this._playing = true;
	            this._setState(this.STATE.PLAYING);
	            this._emit(events.STOP_BUFFERING);
	        };

	        proto._onPause = function () {
	            this._playing = false;
	            var reason = this._getPauseReason(this._triggered);
	            __debug(
	                'nanoplayer (' +
	                    this._playerDivId +
	                    '): trigger pause with reason "' +
	                    reason +
	                    '", state "' +
	                    this._getState() +
	                    '"',
	                3
	            );
	            this._setState(this.STATE.PAUSED);
	            this._stopIntervals();
	            this._emit(events.PAUSE, { 'reason': reason });
	        };

	        proto._emitMetaData = function (handlerName, metaData) {
	            if (!this._metaDataEnabled) {
	                return;
	            }
	            __debug('nanoplayer (' + this._playerDivId + '): onMetaData', 2);
	            try {
	                var meta = JSON.stringify(metaData);
	                __debug('nanoplayer (' + this._playerDivId + '): handlerName=' + handlerName + ', metaData=' + meta, 2);
	            }
	            catch (e) {}
	            var data = {
	                'handlerName' : handlerName,
	                'streamTime'  : 0,
	                // no chunks needed
	                // "chunkIndex": 1,
	                // "chunkCount": 1,
	                'message'     : metaData
	            };
	            this._emit(events.METADATA, data);
	        };

	        proto._onMetaData = function (metadata) {
	            if (metadata.width && metadata.height) {
	                this._onStreamInfo({
	                    'onStreamInfo': {
	                        'videoInfo': {
	                            'width'  : metadata.width,
	                            'height' : metadata.height
	                        }
	                    }
	                });
	            }
	            this._emitMetaData('MetaData', metadata);
	        };

	        proto._onCuePoint = function (metadata) {
	            this._emitMetaData('CuePoint', metadata);
	        };

	        proto._onVolumeChange = function () {
	            // not needed
	        };

	        proto._onResize = function () {
	            if (!this._streamInfo || !this._streamInfo.haveVideo) return;
	            this._setMediaElement();
	            var self = this;
	            var width = this._streamInfo.videoInfo.width;
	            var height = this._streamInfo.videoInfo.height;
	            var playerRes = this._mediaElement.GetCurrentSizeOfContainer();
	            var aspectPlayer = playerRes[0] / playerRes[1];
	            var aspectVideo = width / height;
	            if (aspectPlayer < aspectVideo) {
	                width = playerRes[0];
	                height = Math.round(width / aspectVideo);
	            }
	            else {
	                height = playerRes[1];
	                width = Math.round(height * aspectVideo);
	            }
	            this._mediaElement.SetResize('true');
	            this._mediaElement.SetVideoDisplayResolution(width + ',' + height);
	            this._mediaElement.SetResize('false');
	            this._mediaElement.SetOnlyThisResolution(width + ',' + height);
	            this._resizeTimeout && clearTimeout(this._resizeTimeout);
	            this._resizeTimeout = setTimeout(function () {
	                self._resizeTimeout = 0;
	                self._mediaElement.SetResize('true');
	                self._mediaElement.SetVideoDisplayResolution(width + ',' + height);
	                self._mediaElement.SetResize('false');
	                self._mediaElement.SetOnlyThisResolution(width + ',' + height);
	            }, 300);
	        };

	        proto._onDebug = function (event) {
	            var message =
	                typeof event === 'string'
	                    ? event
	                    : event.message ? event.message : event.data.message ? event.data.message : 'unknown';
	            __debug('nanoplayer (' + this._playerDivId + '): ' + message, 2);
	        };

	        proto._onFlashReady = function () {
	            this._onDebug('flash ready');
	        };

	        proto._onFlashState = function (info, mode) {
	            if (typeof info === 'undefined') return;
	            var state = '';
	            if (typeof info === 'string' || info instanceof String) {
	                state = info;
	                this._onDebug('onFlashCallState: ' + state + ' from ' + mode);
	            }
	            else {
	                this._onDebug('onFlashCallState: ' + mode);
	                for (var value in info) {
	                    if (info.hasOwnProperty(value)) {
	                        this._onDebug('onFlashCallState: ' + value + ' = ' + info[value]);
	                        if (value === 'state' || value === 'code') state = info[value];
	                    }
	                }
	            }
	            if (
	                state === this.FLASH_STATE.VIDEO_DISPLAY.LOADING ||
	                state === this.FLASH_STATE.NET_STREAM.PLAY.RESET ||
	                state === this.FLASH_STATE.NET_STREAM.PLAY.UNPUBLISH_NOTIFY ||
	                state === this.FLASH_STATE.NET_STREAM.PLAY.PUBLISH_NOTIFY
	            ) {
	                this._onLoading();
	            }
	            else if (
	                state === this.FLASH_STATE.VIDEO_DISPLAY.REWINDING ||
	                state === this.FLASH_STATE.VIDEO_DISPLAY.PLAYING ||
	                state === this.FLASH_STATE.NET_STREAM.PLAY.START
	            ) {
	                if (this._playing) {
	                    this._onPlaying();
	                }
	                else {
	                    this._onStopBuffering();
	                }
	            }
	            else if (state === this.FLASH_STATE.VIDEO_DISPLAY.BUFFERING) {
	                this._onStartBuffering();
	            }
	            else if (
	                state === this.FLASH_STATE.VIDEO_DISPLAY.CONNECTION_ERROR ||
	                state === this.FLASH_STATE.VIDEO_DISPLAY.STOPPED ||
	                state === this.FLASH_STATE.VIDEO_DISPLAY.DISCONNECTED ||
	                state === this.FLASH_STATE.NET_STREAM.PLAY.STOP ||
	                state === this.FLASH_STATE.NET_STREAM.PLAY.STREAM_NOT_FOUND
	            ) {
	                this._onPause();
	            }
	            if (info.level === 'error') {
	                this._onDebug('onFlashCallState: ERROR - ' + state);
	            }
	            else {
	                this._onDebug('onFlashCallState: state=' + state);
	            }
	        };

	        proto._setName = function () {
	            this._setMediaElement();
	            this._mediaElement.SetName(this._mediaElementId);
	        };

	        proto.STATE = playerState;
	        proto.FLASH_STATE = flashState;
	        proto.PAUSE_REASON = pauseReason;

	        // FLASH CALLBACKS

	        window._flashPlayers = {};

	        window.onFlashCallExternalApplicationReady = function () {
	            return true;
	        };

	        window.onFlashCallInternalApplicationReady = function (name) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onFlashReady();
	        };

	        window.onFlashCallMyTrace = function (name, value) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onDebug(value);
	        };

	        window.onFlashCallAutoResizeContainer = function (name, value) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onResize(value);
	        };

	        window.onFlashCallVolumeChange = function (name, value) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onVolumeChange(value);
	        };

	        window.onFlashCallMetaDataReceived = function (name, metaData) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onMetaData(metaData);
	        };

	        window.onFlashCallCuePointReceived = function (name, cuePoint) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onCuePoint(cuePoint);
	        };

	        window.onFlashCallState = function (name, info, mode) {
	            window._flashPlayers[name] && window._flashPlayers[name]._onFlashState(info, mode);
	        };

	        return FlashPlayer;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	flashembed.js

	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    /**
	     * @license
	     * SWFObject v2.3.20130521 <http://github.com/swfobject/swfobject> is released under the MIT License <http://www.opensource.org/licenses/mit-license.php>
	     */

	    /* global ActiveXObject: false */

	    var swfobject = (function () {
	        var UNDEF = 'undefined',
	            OBJECT = 'object',
	            SHOCKWAVE_FLASH = 'Shockwave Flash',
	            SHOCKWAVE_FLASH_AX = 'ShockwaveFlash.ShockwaveFlash',
	            FLASH_MIME_TYPE = 'application/x-shockwave-flash',
	            EXPRESS_INSTALL_ID = 'SWFObjectExprInst',
	            ON_READY_STATE_CHANGE = 'onreadystatechange',
	            win = window,
	            doc = document,
	            nav = navigator,
	            plugin = false,
	            domLoadFnArr = [],
	            regObjArr = [],
	            objIdArr = [],
	            listenersArr = [],
	            storedFbContent,
	            storedFbContentId,
	            storedCallbackFn,
	            storedCallbackObj,
	            isDomLoaded = false,
	            isExpressInstallActive = false,
	            dynamicStylesheet,
	            dynamicStylesheetMedia,
	            autoHideShow = true,
	            encodeURIEnabled = false,
	            /* Centralized function for browser feature detection
	            - User agent string detection is only used when no good alternative is possible
	            - Is executed directly for optimal performance
	        */
	            ua = (function () {
	                var w3cdom =
	                        typeof doc.getElementById !== UNDEF &&
	                        typeof doc.getElementsByTagName !== UNDEF &&
	                        typeof doc.createElement !== UNDEF,
	                    u = nav.userAgent.toLowerCase(),
	                    p = nav.platform.toLowerCase(),
	                    windows = p ? /win/.test(p) : /win/.test(u),
	                    mac = p ? /mac/.test(p) : /mac/.test(u),
	                    webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, '$1')) : false, // returns either the webkit version or false if not webkit
	                    ie = nav.appName === 'Microsoft Internet Explorer',
	                    playerVersion = [0, 0, 0],
	                    d = null;
	                if (typeof nav.plugins !== UNDEF && typeof nav.plugins[SHOCKWAVE_FLASH] === OBJECT) {
	                    d = nav.plugins[SHOCKWAVE_FLASH].description;
	                    // nav.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
	                    if (
	                        d &&
	                        (typeof nav.mimeTypes !== UNDEF &&
	                            nav.mimeTypes[FLASH_MIME_TYPE] &&
	                            nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)
	                    ) {
	                        plugin = true;
	                        ie = false; // cascaded feature detection for Internet Explorer
	                        d = d.replace(/^.*\s+(\S+\s+\S+$)/, '$1');
	                        playerVersion[0] = toInt(d.replace(/^(.*)\..*$/, '$1'));
	                        playerVersion[1] = toInt(d.replace(/^.*\.(.*)\s.*$/, '$1'));
	                        playerVersion[2] = /[a-zA-Z]/.test(d) ? toInt(d.replace(/^.*[a-zA-Z]+(.*)$/, '$1')) : 0;
	                    }
	                }
	                else if (typeof win.ActiveXObject !== UNDEF) {
	                    try {
	                        var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
	                        if (a) {
	                            // a will return null when ActiveX is disabled
	                            d = a.GetVariable('$version');
	                            if (d) {
	                                ie = true; // cascaded feature detection for Internet Explorer
	                                d = d.split(' ')[1].split(',');
	                                playerVersion = [toInt(d[0]), toInt(d[1]), toInt(d[2])];
	                            }
	                        }
	                    }
	                    catch (e) {}
	                }
	                return {
	                    'w3'  : w3cdom,
	                    'pv'  : playerVersion,
	                    'wk'  : webkit,
	                    'ie'  : ie,
	                    'win' : windows,
	                    'mac' : mac
	                };
	            })(),
	            /* Cross-browser onDomLoad
	                - Will fire an event as soon as the DOM of a web page is loaded
	                - Internet Explorer workaround based on Diego Perini's solution: http://javascript.nwbox.com/IEContentLoaded/
	                - Regular onload serves as fallback
	            */

	            /* eslint-disable */
	            // prettier-ignore
	            onDomLoad = (function () {
	                if (!ua.w3) {
	                    return;
	                }
	                if (
	                    (typeof doc.readyState !== UNDEF &&
	                        (doc.readyState === 'complete' || doc.readyState === 'interactive')) ||
	                    (typeof doc.readyState === UNDEF && (doc.getElementsByTagName('body')[0] || doc.body))
	                ) {
	                    // function is fired after onload, e.g. when script is inserted dynamically
	                    callDomLoadFunctions();
	                }
	                if (!isDomLoaded) {
	                    if (typeof doc.addEventListener !== UNDEF) {
	                        doc.addEventListener('DOMContentLoaded', callDomLoadFunctions, false);
	                    }
	                    if (ua.ie) {
	                        doc.attachEvent(ON_READY_STATE_CHANGE, function detach () {
	                            if (doc.readyState === 'complete') {
	                                doc.detachEvent(ON_READY_STATE_CHANGE, detach);
	                                callDomLoadFunctions();
	                            }
	                        });
	                        if (win == top) {
	                            // if not inside an iframe
	                            (function checkDomLoadedIE () {
	                                if (isDomLoaded) {
	                                    return;
	                                }
	                                try {
	                                    doc.documentElement.doScroll('left');
	                                }
	                                catch (e) {
	                                    setTimeout(checkDomLoadedIE, 0);
	                                    return;
	                                }
	                                callDomLoadFunctions();
	                            })();
	                        }
	                    }
	                    if (ua.wk) {
	                        (function checkDomLoadedWK () {
	                            if (isDomLoaded) {
	                                return;
	                            }
	                            if (!/loaded|complete/.test(doc.readyState)) {
	                                setTimeout(checkDomLoadedWK, 0);
	                                return;
	                            }
	                            callDomLoadFunctions();
	                        })();
	                    }
	                }
	            })();
	        /* eslint-enable */

	        function callDomLoadFunctions () {
	            if (isDomLoaded || !document.getElementsByTagName('body')[0]) {
	                return;
	            }
	            try {
	                // test if we can really add/remove elements to/from the DOM; we don't want to fire it too early
	                var t,
	                    span = createElement('span');
	                span.style.display = 'none'; //hide the span in case someone has styled spans via CSS
	                t = doc.getElementsByTagName('body')[0].appendChild(span);
	                t.parentNode.removeChild(t);
	                t = null; //clear the variables
	                span = null;
	            }
	            catch (e) {
	                return;
	            }
	            isDomLoaded = true;
	            var dl = domLoadFnArr.length;
	            for (var i = 0; i < dl; i++) {
	                domLoadFnArr[i]();
	            }
	        }

	        function addDomLoadEvent (fn) {
	            if (isDomLoaded) {
	                fn();
	            }
	            else {
	                domLoadFnArr[domLoadFnArr.length] = fn; // Array.push() is only available in IE5.5+
	            }
	        }

	        /* Cross-browser onload
	            - Based on James Edwards' solution: http://brothercake.com/site/resources/scripts/onload/
	            - Will fire an event as soon as a web page including all of its assets are loaded
	         */
	        function addLoadEvent (fn) {
	            if (typeof win.addEventListener !== UNDEF) {
	                win.addEventListener('load', fn, false);
	            }
	            else if (typeof doc.addEventListener !== UNDEF) {
	                doc.addEventListener('load', fn, false);
	            }
	            else if (typeof win.attachEvent !== UNDEF) {
	                addListener(win, 'onload', fn);
	            }
	            else if (typeof win.onload === 'function') {
	                var fnOld = win.onload;
	                win.onload = function () {
	                    fnOld();
	                    fn();
	                };
	            }
	            else {
	                win.onload = fn;
	            }
	        }

	        /* Perform Flash Player and SWF version matching; static publishing only
	        */
	        function matchVersions () {
	            var rl = regObjArr.length;
	            if (rl > 0) {
	                for (var i = 0; i < rl; i++) {
	                    // for each registered object element
	                    var id = regObjArr[i].id;
	                    var cb = regObjArr[i].callbackFn;
	                    var cbObj = {
	                        'success' : false,
	                        'id'      : id
	                    };
	                    if (ua.pv[0] > 0) {
	                        var obj = getElementById(id);
	                        if (obj) {
	                            if (hasPlayerVersion(regObjArr[i].swfVersion) && !(ua.wk && ua.wk < 312)) {
	                                // Flash Player version >= published SWF version: Houston, we have a match!
	                                setVisibility(id, true);
	                                if (cb) {
	                                    cbObj.success = true;
	                                    cbObj.ref = getObjectById(id);
	                                    cbObj.id = id;
	                                    cb(cbObj);
	                                }
	                            }
	                            else if (regObjArr[i].expressInstall && canExpressInstall()) {
	                                // show the Adobe Express Install dialog if set by the web page author and if supported
	                                var att = {};
	                                att.data = regObjArr[i].expressInstall;
	                                att.width = obj.getAttribute('width') || '0';
	                                att.height = obj.getAttribute('height') || '0';
	                                if (obj.getAttribute('class')) {
	                                    att.styleclass = obj.getAttribute('class');
	                                }
	                                if (obj.getAttribute('align')) {
	                                    att.align = obj.getAttribute('align');
	                                }
	                                // parse HTML object param element's name-value pairs
	                                var par = {};
	                                var p = obj.getElementsByTagName('param');
	                                var pl = p.length;
	                                for (var j = 0; j < pl; j++) {
	                                    if (p[j].getAttribute('name').toLowerCase() !== 'movie') {
	                                        par[p[j].getAttribute('name')] = p[j].getAttribute('value');
	                                    }
	                                }
	                                showExpressInstall(att, par, id, cb);
	                            }
	                            else {
	                                // Flash Player and SWF version mismatch or an older Webkit engine that ignores the HTML object element's nested param elements: display fallback content instead of SWF
	                                displayFbContent(obj);
	                                if (cb) {
	                                    cb(cbObj);
	                                }
	                            }
	                        }
	                    }
	                    else {
	                        // if no Flash Player is installed or the fp version cannot be detected we let the HTML object element do its job (either show a SWF or fallback content)
	                        setVisibility(id, true);
	                        if (cb) {
	                            var o = getObjectById(id); // test whether there is an HTML object element or not
	                            if (o && typeof o.SetVariable !== UNDEF) {
	                                cbObj.success = true;
	                                cbObj.ref = o;
	                                cbObj.id = o.id;
	                            }
	                            cb(cbObj);
	                        }
	                    }
	                }
	            }
	        }

	        /* Main function
	            - Will preferably execute onDomLoad, otherwise onload (as a fallback)
	        */
	        domLoadFnArr[0] = function () {
	            if (plugin) {
	                matchVersions();
	            }
	        };

	        function getObjectById (objectIdStr) {
	            var r = null,
	                o = getElementById(objectIdStr);

	            if (o && o.nodeName.toUpperCase() === 'OBJECT') {
	                //If targeted object is valid Flash file
	                if (typeof o.SetVariable !== UNDEF) {
	                    r = o;
	                }
	                else {
	                    //If SetVariable is not working on targeted object but a nested object is
	                    //available, assume classic nested object markup. Return nested object.

	                    //If SetVariable is not working on targeted object and there is no nested object,
	                    //return the original object anyway. This is probably new simplified markup.

	                    r = o.getElementsByTagName(OBJECT)[0] || o;
	                }
	            }

	            return r;
	        }

	        /* Requirements for Adobe Express Install
	            - only one instance can be active at a time
	            - fp 6.0.65 or higher
	            - Win/Mac OS only
	            - no Webkit engines older than version 312
	        */
	        function canExpressInstall () {
	            return (
	                !isExpressInstallActive && hasPlayerVersion('6.0.65') && (ua.win || ua.mac) && !(ua.wk && ua.wk < 312)
	            );
	        }

	        /* Show the Adobe Express Install dialog
	            - Reference: http://www.adobe.com/cfusion/knowledgebase/index.cfm?id=6a253b75
	        */
	        function showExpressInstall (att, par, replaceElemIdStr, callbackFn) {
	            var obj = getElementById(replaceElemIdStr);

	            //Ensure that replaceElemIdStr is really a string and not an element
	            replaceElemIdStr = getId(replaceElemIdStr);

	            isExpressInstallActive = true;
	            storedCallbackFn = callbackFn || null;
	            storedCallbackObj = {
	                'success' : false,
	                'id'      : replaceElemIdStr
	            };

	            if (obj) {
	                if (obj.nodeName.toUpperCase() === 'OBJECT') {
	                    // static publishing
	                    storedFbContent = abstractFbContent(obj);
	                    storedFbContentId = null;
	                }
	                else {
	                    // dynamic publishing
	                    storedFbContent = obj;
	                    storedFbContentId = replaceElemIdStr;
	                }
	                att.id = EXPRESS_INSTALL_ID;
	                if (typeof att.width === UNDEF || (!/%$/.test(att.width) && toInt(att.width) < 310)) {
	                    att.width = '310';
	                }
	                if (typeof att.height === UNDEF || (!/%$/.test(att.height) && toInt(att.height) < 137)) {
	                    att.height = '137';
	                }
	                var pt = ua.ie ? 'ActiveX' : 'PlugIn',
	                    fv =
	                        'MMredirectURL=' +
	                        encodeURIComponent(win.location.toString().replace(/&/g, '%26')) +
	                        '&MMplayerType=' +
	                        pt +
	                        '&MMdoctitle=' +
	                        encodeURIComponent(doc.title.slice(0, 47) + ' - Flash Player Installation');
	                if (typeof par.flashvars !== UNDEF) {
	                    par.flashvars += '&' + fv;
	                }
	                else {
	                    par.flashvars = fv;
	                }
	                // IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
	                // because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
	                if (ua.ie && obj.readyState !== 4) {
	                    var newObj = createElement('div');
	                    replaceElemIdStr += 'SWFObjectNew';
	                    newObj.setAttribute('id', replaceElemIdStr);
	                    obj.parentNode.insertBefore(newObj, obj); // insert placeholder div that will be replaced by the object element that loads expressinstall.swf
	                    obj.style.display = 'none';
	                    removeSWF(obj); //removeSWF accepts elements now
	                }
	                createSWF(att, par, replaceElemIdStr);
	            }
	        }

	        /* Functions to abstract and display fallback content
	        */
	        function displayFbContent (obj) {
	            if (ua.ie && obj.readyState !== 4) {
	                // IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
	                // because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
	                obj.style.display = 'none';
	                var el = createElement('div');
	                obj.parentNode.insertBefore(el, obj); // insert placeholder div that will be replaced by the fallback content
	                el.parentNode.replaceChild(abstractFbContent(obj), el);
	                removeSWF(obj); //removeSWF accepts elements now
	            }
	            else {
	                obj.parentNode.replaceChild(abstractFbContent(obj), obj);
	            }
	        }

	        function abstractFbContent (obj) {
	            var ac = createElement('div');
	            if (ua.win && ua.ie) {
	                ac.innerHTML = obj.innerHTML;
	            }
	            else {
	                var nestedObj = obj.getElementsByTagName(OBJECT)[0];
	                if (nestedObj) {
	                    var c = nestedObj.childNodes;
	                    if (c) {
	                        var cl = c.length;
	                        for (var i = 0; i < cl; i++) {
	                            if (!(c[i].nodeType === 1 && c[i].nodeName === 'PARAM') && !(c[i].nodeType === 8)) {
	                                ac.appendChild(c[i].cloneNode(true));
	                            }
	                        }
	                    }
	                }
	            }
	            return ac;
	        }

	        function createIeObject (url, paramStr) {
	            var div = createElement('div');
	            div.innerHTML =
	                '<object classid=\'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\'><param name=\'movie\' value=\'' +
	                url +
	                '\'>' +
	                paramStr +
	                '</object>';
	            return div.firstChild;
	        }

	        /* Cross-browser dynamic SWF creation
	        */
	        function createSWF (attObj, parObj, id) {
	            var r,
	                el = getElementById(id);
	            id = getId(id); // ensure id is truly an ID and not an element

	            if (ua.wk && ua.wk < 312) {
	                return r;
	            }

	            if (el) {
	                var o = ua.ie ? createElement('div') : createElement(OBJECT),
	                    attr,
	                    attrLower,
	                    param;

	                if (typeof attObj.id === UNDEF) {
	                    // if no 'id' is defined for the object element, it will inherit the 'id' from the fallback content
	                    attObj.id = id;
	                }

	                //Add params
	                for (param in parObj) {
	                    //filter out prototype additions from other potential libraries and IE specific param element
	                    if (parObj.hasOwnProperty(param) && param.toLowerCase() !== 'movie') {
	                        createObjParam(o, param, parObj[param]);
	                    }
	                }

	                //Create IE object, complete with param nodes
	                if (ua.ie) {
	                    o = createIeObject(attObj.data, o.innerHTML);
	                }

	                //Add attributes to object
	                for (attr in attObj) {
	                    if (attObj.hasOwnProperty(attr)) {
	                        // filter out prototype additions from other potential libraries
	                        attrLower = attr.toLowerCase();

	                        // 'class' is an ECMA4 reserved keyword
	                        if (attrLower === 'styleclass') {
	                            o.setAttribute('class', attObj[attr]);
	                        }
	                        else if (attrLower !== 'classid' && attrLower !== 'data') {
	                            o.setAttribute(attr, attObj[attr]);
	                        }
	                    }
	                }

	                if (ua.ie) {
	                    objIdArr[objIdArr.length] = attObj.id; // stored to fix object 'leaks' on unload (dynamic publishing only)
	                }
	                else {
	                    o.setAttribute('type', FLASH_MIME_TYPE);
	                    o.setAttribute('data', attObj.data);
	                }

	                el.parentNode.replaceChild(o, el);
	                r = o;
	            }

	            return r;
	        }

	        function createObjParam (el, pName, pValue) {
	            var p = createElement('param');
	            p.setAttribute('name', pName);
	            p.setAttribute('value', pValue);
	            el.appendChild(p);
	        }

	        /* Cross-browser SWF removal
	            - Especially needed to safely and completely remove a SWF in Internet Explorer
	        */
	        function removeSWF (id) {
	            var obj = getElementById(id);
	            if (obj && obj.nodeName.toUpperCase() === 'OBJECT') {
	                if (ua.ie) {
	                    obj.style.display = 'none';
	                    (function removeSWFInIE () {
	                        if (obj.readyState === 4) {
	                            //This step prevents memory leaks in Internet Explorer
	                            for (var i in obj) {
	                                if (typeof obj[i] === 'function') {
	                                    obj[i] = null;
	                                }
	                            }
	                            obj.parentNode.removeChild(obj);
	                        }
	                        else {
	                            setTimeout(removeSWFInIE, 10);
	                        }
	                    })();
	                }
	                else {
	                    obj.parentNode.removeChild(obj);
	                }
	            }
	        }

	        function isElement (id) {
	            return id && id.nodeType && id.nodeType === 1;
	        }

	        function getId (thing) {
	            return isElement(thing) ? thing.id : thing;
	        }

	        /* Functions to optimize JavaScript compression
	        */
	        function getElementById (id) {
	            //Allow users to pass an element OR an element's ID
	            if (isElement(id)) {
	                return id;
	            }

	            var el = null;
	            try {
	                el = doc.getElementById(id);
	            }
	            catch (e) {}
	            return el;
	        }

	        function createElement (el) {
	            return doc.createElement(el);
	        }

	        //To aid compression; replaces 14 instances of pareseInt with radix
	        function toInt (str) {
	            return parseInt(str, 10);
	        }

	        /* Updated attachEvent function for Internet Explorer
	            - Stores attachEvent information in an Array, so on unload the detachEvent functions can be called to avoid memory leaks
	        */
	        function addListener (target, eventType, fn) {
	            target.attachEvent(eventType, fn);
	            listenersArr[listenersArr.length] = [target, eventType, fn];
	        }

	        /* Flash Player and SWF content version matching
	        */
	        function hasPlayerVersion (rv) {
	            rv += ''; //Coerce number to string, if needed.
	            var pv = ua.pv,
	                v = rv.split('.');
	            v[0] = toInt(v[0]);
	            v[1] = toInt(v[1]) || 0; // supports short notation, e.g. "9" instead of "9.0.0"
	            v[2] = toInt(v[2]) || 0;
	            return !!(
	                pv[0] > v[0] ||
	                (pv[0] === v[0] && pv[1] > v[1]) ||
	                (pv[0] === v[0] && pv[1] === v[1] && pv[2] >= v[2])
	            );
	        }

	        /* Cross-browser dynamic CSS creation
	            - Based on Bobby van der Sluis' solution: http://www.bobbyvandersluis.com/articles/dynamicCSS.php
	        */
	        function createCSS (sel, decl, media, newStyle) {
	            var h = doc.getElementsByTagName('head')[0];
	            if (!h) {
	                return;
	            } // to also support badly authored HTML pages that lack a head element
	            var m = typeof media === 'string' ? media : 'screen';
	            if (newStyle) {
	                dynamicStylesheet = null;
	                dynamicStylesheetMedia = null;
	            }
	            if (!dynamicStylesheet || dynamicStylesheetMedia !== m) {
	                // create dynamic stylesheet + get a global reference to it
	                var s = createElement('style');
	                s.setAttribute('type', 'text/css');
	                s.setAttribute('media', m);
	                dynamicStylesheet = h.appendChild(s);
	                if (ua.ie && typeof doc.styleSheets !== UNDEF && doc.styleSheets.length > 0) {
	                    dynamicStylesheet = doc.styleSheets[doc.styleSheets.length - 1];
	                }
	                dynamicStylesheetMedia = m;
	            }
	            // add style rule
	            if (dynamicStylesheet) {
	                if (typeof dynamicStylesheet.addRule !== UNDEF) {
	                    dynamicStylesheet.addRule(sel, decl);
	                }
	                else if (typeof doc.createTextNode !== UNDEF) {
	                    dynamicStylesheet.appendChild(doc.createTextNode(sel + ' {' + decl + '}'));
	                }
	            }
	        }

	        function setVisibility (id, isVisible) {
	            if (!autoHideShow) {
	                return;
	            }
	            var v = isVisible ? 'visible' : 'hidden',
	                el = getElementById(id);
	            if (isDomLoaded && el) {
	                el.style.visibility = v;
	            }
	            else if (typeof id === 'string') {
	                createCSS('#' + id, 'visibility:' + v);
	            }
	        }

	        /* Filter to avoid XSS attacks
	        */
	        function urlEncodeIfNecessary (s) {
	            var regex = /[\\"<>.;]/;
	            var hasBadChars = regex.exec(s) !== null;
	            return hasBadChars && typeof encodeURIComponent !== UNDEF ? encodeURIComponent(s) : s;
	        }

	        /* Release memory to avoid memory leaks caused by closures, fix hanging audio/video threads and force open sockets/NetConnections to disconnect (Internet Explorer only)
	        */
	        (function () {
	            if (ua.ie) {
	                window.attachEvent('onunload', function () {
	                    // remove listeners to avoid memory leaks
	                    var ll = listenersArr.length;
	                    for (var i = 0; i < ll; i++) {
	                        listenersArr[i][0].detachEvent(listenersArr[i][1], listenersArr[i][2]);
	                    }
	                    // cleanup dynamically embedded objects to fix audio/video threads and force open sockets and NetConnections to disconnect
	                    var il = objIdArr.length;
	                    for (var j = 0; j < il; j++) {
	                        removeSWF(objIdArr[j]);
	                    }
	                    // cleanup library's main closures to avoid memory leaks
	                    for (var k in ua) {
	                        ua[k] = null;
	                    }
	                    ua = null;
	                    for (var l in swfobject) {
	                        swfobject[l] = null;
	                    }
	                    swfobject = null;
	                });
	            }
	        })();

	        return {
	            /* Public API
	                - Reference: http://code.google.com/p/swfobject/wiki/documentation
	            */
	            'registerObject': function (objectIdStr, swfVersionStr, xiSwfUrlStr, callbackFn) {
	                if (ua.w3 && objectIdStr && swfVersionStr) {
	                    var regObj = {};
	                    regObj.id = objectIdStr;
	                    regObj.swfVersion = swfVersionStr;
	                    regObj.expressInstall = xiSwfUrlStr;
	                    regObj.callbackFn = callbackFn;
	                    regObjArr[regObjArr.length] = regObj;
	                    setVisibility(objectIdStr, false);
	                }
	                else if (callbackFn) {
	                    callbackFn({
	                        'success' : false,
	                        'id'      : objectIdStr
	                    });
	                }
	            },

	            'getObjectById': function (objectIdStr) {
	                if (ua.w3) {
	                    return getObjectById(objectIdStr);
	                }
	            },

	            'embedSWF': function (
	                swfUrlStr,
	                replaceElemIdStr,
	                widthStr,
	                heightStr,
	                swfVersionStr,
	                xiSwfUrlStr,
	                flashvarsObj,
	                parObj,
	                attObj,
	                callbackFn
	            ) {
	                var id = getId(replaceElemIdStr),
	                    callbackObj = {
	                        'success' : false,
	                        'id'      : id
	                    };

	                if (
	                    ua.w3 &&
	                    !(ua.wk && ua.wk < 312) &&
	                    swfUrlStr &&
	                    replaceElemIdStr &&
	                    widthStr &&
	                    heightStr &&
	                    swfVersionStr
	                ) {
	                    setVisibility(id, false);
	                    addDomLoadEvent(function () {
	                        widthStr += ''; // auto-convert to string
	                        heightStr += '';
	                        var att = {};
	                        if (attObj && typeof attObj === OBJECT) {
	                            for (var i in attObj) {
	                                // copy object to avoid the use of references, because web authors often reuse attObj for multiple SWFs
	                                att[i] = attObj[i];
	                            }
	                        }
	                        att.data = swfUrlStr;
	                        att.width = widthStr;
	                        att.height = heightStr;
	                        var par = {};
	                        if (parObj && typeof parObj === OBJECT) {
	                            for (var j in parObj) {
	                                // copy object to avoid the use of references, because web authors often reuse parObj for multiple SWFs
	                                par[j] = parObj[j];
	                            }
	                        }
	                        if (flashvarsObj && typeof flashvarsObj === OBJECT) {
	                            for (var k in flashvarsObj) {
	                                // copy object to avoid the use of references, because web authors often reuse flashvarsObj for multiple SWFs
	                                if (flashvarsObj.hasOwnProperty(k)) {
	                                    var key = encodeURIEnabled ? encodeURIComponent(k) : k,
	                                        value = encodeURIEnabled
	                                            ? encodeURIComponent(flashvarsObj[k])
	                                            : flashvarsObj[k];

	                                    if (typeof par.flashvars !== UNDEF) {
	                                        par.flashvars += '&' + key + '=' + value;
	                                    }
	                                    else {
	                                        par.flashvars = key + '=' + value;
	                                    }
	                                }
	                            }
	                        }
	                        if (hasPlayerVersion(swfVersionStr)) {
	                            // create SWF
	                            var obj = createSWF(att, par, replaceElemIdStr);
	                            if (att.id === id) {
	                                setVisibility(id, true);
	                            }
	                            callbackObj.success = true;
	                            callbackObj.ref = obj;
	                            callbackObj.id = obj.id;
	                        }
	                        else if (xiSwfUrlStr && canExpressInstall()) {
	                            // show Adobe Express Install
	                            att.data = xiSwfUrlStr;
	                            showExpressInstall(att, par, replaceElemIdStr, callbackFn);
	                            return;
	                        }
	                        else {
	                            // show fallback content
	                            setVisibility(id, true);
	                        }
	                        if (callbackFn) {
	                            callbackFn(callbackObj);
	                        }
	                    });
	                }
	                else if (callbackFn) {
	                    callbackFn(callbackObj);
	                }
	            },

	            'switchOffAutoHideShow': function () {
	                autoHideShow = false;
	            },

	            'enableUriEncoding': function (bool) {
	                encodeURIEnabled = typeof bool === UNDEF ? true : bool;
	            },

	            'ua': ua,

	            'getFlashPlayerVersion': function () {
	                return {
	                    'major'   : ua.pv[0],
	                    'minor'   : ua.pv[1],
	                    'release' : ua.pv[2]
	                };
	            },

	            'hasFlashPlayerVersion': hasPlayerVersion,

	            'createSWF': function (attObj, parObj, replaceElemIdStr) {
	                if (ua.w3) {
	                    return createSWF(attObj, parObj, replaceElemIdStr);
	                }
	                else {
	                    return undefined;
	                }
	            },

	            'showExpressInstall': function (att, par, replaceElemIdStr, callbackFn) {
	                if (ua.w3 && canExpressInstall()) {
	                    showExpressInstall(att, par, replaceElemIdStr, callbackFn);
	                }
	            },

	            'removeSWF': function (objElemIdStr) {
	                if (ua.w3) {
	                    removeSWF(objElemIdStr);
	                }
	            },

	            'createCSS': function (selStr, declStr, mediaStr, newStyleBoolean) {
	                if (ua.w3) {
	                    createCSS(selStr, declStr, mediaStr, newStyleBoolean);
	                }
	            },

	            'addDomLoadEvent': addDomLoadEvent,

	            'addLoadEvent': addLoadEvent,

	            'getQueryParamValue': function (param) {
	                var q = doc.location.search || doc.location.hash;
	                if (q) {
	                    if (/\?/.test(q)) {
	                        q = q.split('?')[1];
	                    } // strip question mark
	                    if (!param) {
	                        return urlEncodeIfNecessary(q);
	                    }
	                    var pairs = q.split('&');
	                    for (var i = 0; i < pairs.length; i++) {
	                        if (pairs[i].substring(0, pairs[i].indexOf('=')) === param) {
	                            return urlEncodeIfNecessary(pairs[i].substring(pairs[i].indexOf('=') + 1));
	                        }
	                    }
	                }
	                return '';
	            },

	            // For internal usage only
	            'expressInstallCallback': function () {
	                if (isExpressInstallActive) {
	                    var obj = getElementById(EXPRESS_INSTALL_ID);
	                    if (obj && storedFbContent) {
	                        obj.parentNode.replaceChild(storedFbContent, obj);
	                        if (storedFbContentId) {
	                            setVisibility(storedFbContentId, true);
	                            if (ua.ie) {
	                                storedFbContent.style.display = 'block';
	                            }
	                        }
	                        if (storedCallbackFn) {
	                            storedCallbackFn(storedCallbackObj);
	                        }
	                    }
	                    isExpressInstallActive = false;
	                }
	            },

	            'version': '2.3'
	        };
	    })();

	    return swfobject;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'VIDEO_DISPLAY': {
	            'CONNECTION_ERROR' : 'connectionError',
	            'LOADING'          : 'loading',
	            'PLAYING'          : 'playing',
	            'REWINDING'        : 'rewinding',
	            'BUFFERING'        : 'buffering',
	            'STOPPED'          : 'stopped',
	            'DISCONNECTED'     : 'disconnected'
	        },
	        'NET_STREAM': {
	            'PLAY': {
	                'RESET'            : 'NetStream.Play.Reset',
	                'UNPUBLISH_NOTIFY' : 'NetStream.Play.UnpublishNotify',
	                'PUBLISH_NOTIFY'   : 'NetStream.Play.PublishNotify',
	                'PLAY'             : 'NetStream.Play.Start',
	                'STOP'             : 'NetStream.Play.Stop',
	                'STREAM_NOT_FOUND' : 'NetStream.Play.StreamNotFound'
	            }
	        }
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-12-01.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return {
	        'FORCE_NOT_SUPPORTED'  : 'The forced tech "$tech$" is not supported by your browser.',
	        'SOURCE_NOT_SUPPORTED' :
	            'The players source configuration is malformed or missing, please check documentation for more information or contact us',
	        'CLIENT_NOT_SUPPORTED':
	            'This browser does not fully support HTML5 and H5Live.\
	            Supported are: Chrome >=54 (Windows, MacOSX, Android), Firefox >=48 (Windows, MacOSX, Android), Microsoft Edge (Windows), Microsoft Internet Explorer 11 (at least Windows 8), Safari (MacOSX & at least iOS 10).'
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-11-14.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function create (source, events, target) {
	        function init () {
	            for (var key in events) {
	                if (events.hasOwnProperty(key)) {
	                    source.on(events[key], onEvent);
	                }
	            }
	        }

	        function destroy () {
	            for (var key in events) {
	                if (events.hasOwnProperty(key)) {
	                    source.off(events[key], onEvent);
	                }
	            }
	        }

	        function onEvent (event) {
	            target.emit(event.name, event);
	        }

	        init();

	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    // Store setTimeout reference so promise-polyfill will be unaffected by
	    // other code modifying setTimeout (like sinon.useFakeTimers())
	    var setTimeoutFunc = setTimeout;

	    function noop () {}

	    // Polyfill for Function.prototype.bind
	    function bind (fn, thisArg) {
	        return function () {
	            fn.apply(thisArg, arguments);
	        };
	    }

	    function Promise (fn) {
	        if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	        if (typeof fn !== 'function') throw new TypeError('not a function');
	        this._state = 0;
	        this._handled = false;
	        this._value = undefined;
	        this._deferreds = [];

	        doResolve(fn, this);
	    }

	    function handle (self, deferred) {
	        while (self._state === 3) {
	            self = self._value;
	        }
	        if (self._state === 0) {
	            self._deferreds.push(deferred);
	            return;
	        }
	        self._handled = true;
	        Promise._immediateFn(function () {
	            var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	            if (cb === null) {
	                (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	                return;
	            }
	            var ret;
	            try {
	                ret = cb(self._value);
	            }
	            catch (e) {
	                reject(deferred.promise, e);
	                return;
	            }
	            resolve(deferred.promise, ret);
	        });
	    }

	    function resolve (self, newValue) {
	        try {
	            // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	            if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	            if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	                var then = newValue.then;
	                if (newValue instanceof Promise) {
	                    self._state = 3;
	                    self._value = newValue;
	                    finale(self);
	                    return;
	                }
	                else if (typeof then === 'function') {
	                    doResolve(bind(then, newValue), self);
	                    return;
	                }
	            }
	            self._state = 1;
	            self._value = newValue;
	            finale(self);
	        }
	        catch (e) {
	            reject(self, e);
	        }
	    }

	    function reject (self, newValue) {
	        self._state = 2;
	        self._value = newValue;
	        finale(self);
	    }

	    function finale (self) {
	        if (self._state === 2 && self._deferreds.length === 0) {
	            Promise._immediateFn(function () {
	                if (!self._handled) {
	                    Promise._unhandledRejectionFn(self._value);
	                }
	            });
	        }

	        for (var i = 0, len = self._deferreds.length; i < len; i++) {
	            handle(self, self._deferreds[i]);
	        }
	        self._deferreds = null;
	    }

	    function Handler (onFulfilled, onRejected, promise) {
	        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	        this.promise = promise;
	    }

	    /**
	     * Take a potentially misbehaving resolver function and make sure
	     * onFulfilled and onRejected are only called once.
	     *
	     * Makes no guarantees about asynchrony.
	     */
	    function doResolve (fn, self) {
	        var done = false;
	        try {
	            fn(
	                function (value) {
	                    if (done) return;
	                    done = true;
	                    resolve(self, value);
	                },
	                function (reason) {
	                    if (done) return;
	                    done = true;
	                    reject(self, reason);
	                }
	            );
	        }
	        catch (ex) {
	            if (done) return;
	            done = true;
	            reject(self, ex);
	        }
	    }

	    Promise.prototype.catch = function (onRejected) {
	        return this.then(null, onRejected);
	    };

	    Promise.prototype.then = function (onFulfilled, onRejected) {
	        var prom = new this.constructor(noop);

	        handle(this, new Handler(onFulfilled, onRejected, prom));
	        return prom;
	    };

	    Promise.all = function (arr) {
	        var args = Array.prototype.slice.call(arr);

	        return new Promise(function (resolve, reject) {
	            if (args.length === 0) return resolve([]);
	            var remaining = args.length;

	            function res (i, val) {
	                try {
	                    if (val && (typeof val === 'object' || typeof val === 'function')) {
	                        var then = val.then;
	                        if (typeof then === 'function') {
	                            then.call(
	                                val,
	                                function (val) {
	                                    res(i, val);
	                                },
	                                reject
	                            );
	                            return;
	                        }
	                    }
	                    args[i] = val;
	                    if (--remaining === 0) {
	                        resolve(args);
	                    }
	                }
	                catch (ex) {
	                    reject(ex);
	                }
	            }

	            for (var i = 0; i < args.length; i++) {
	                res(i, args[i]);
	            }
	        });
	    };

	    Promise.resolve = function (value) {
	        if (value && typeof value === 'object' && value.constructor === Promise) {
	            return value;
	        }

	        return new Promise(function (resolve) {
	            resolve(value);
	        });
	    };

	    Promise.reject = function (value) {
	        return new Promise(function (resolve, reject) {
	            reject(value);
	        });
	    };

	    Promise.race = function (values) {
	        return new Promise(function (resolve, reject) {
	            for (var i = 0, len = values.length; i < len; i++) {
	                values[i].then(resolve, reject);
	            }
	        });
	    };

	    // Use polyfill for setImmediate for performance gains
	    Promise._immediateFn =
	        (typeof window.setImmediate === 'function' &&
	            function (fn) {
	                window.setImmediate(fn);
	            }) ||
	        function (fn) {
	            setTimeoutFunc(fn, 0);
	        };

	    Promise._unhandledRejectionFn = function _unhandledRejectionFn (err) {
	        if (typeof console !== 'undefined' && console) {
	            console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	        }
	    };

	    /**
	     * Set the immediate function to execute callbacks
	     * @param fn {function} Function to execute
	     * @deprecated
	     */
	    Promise._setImmediateFn = function _setImmediateFn (fn) {
	        Promise._immediateFn = fn;
	    };

	    /**
	     * Change the function to execute on unhandled rejection
	     * @param {function} fn Function to execute on unhandled rejection
	     * @deprecated
	     */
	    Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn (fn) {
	        Promise._unhandledRejectionFn = fn;
	    };

	    if (window.Promise === undefined) {
	        window.Promise = Promise;
	    }

	    return window.Promise;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(11),
	        __webpack_require__(17),
	        __webpack_require__(16),
	        __webpack_require__(6),
	        __webpack_require__(22),
	        __webpack_require__(8),
	        __webpack_require__(100),
	        __webpack_require__(101),
	        __webpack_require__(102),
	        __webpack_require__(103),
	        __webpack_require__(104),
	        __webpack_require__(99),
	        __webpack_require__(105),
	        __webpack_require__(106),
	        __webpack_require__(107),
	        __webpack_require__(108),
	        __webpack_require__(109),
	        __webpack_require__(110),
	        __webpack_require__(112),
	        __webpack_require__(117),
	        __webpack_require__(119),
	        __webpack_require__(124)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        BrowserInfo,
	        configHandler,
	        Debug,
	        EventEmitter,
	        conditions,
	        events,
	        emptyConfig,
	        validConfig,
	        resizeListener,
	        playerStates,
	        domEvents,
	        viewEvents,
	        fullscreenEvents,
	        interactionEvents,
	        controlsEvents,
	        animations,
	        interaction,
	        style,
	        middleview,
	        scaling,
	        fullscreen,
	        controls
	    ) {
	        'use strict';

	        var __debug = Debug.log;

	        function ViewController () {
	            this.version = '';
	        }

	        var proto = (ViewController.prototype = Object.create(EventEmitter.prototype));

	        proto.setBaseValues = function (playerDivId) {
	            console.log('NanoView api version: ' + this.version);
	            this.config = emptyConfig.create();
	            this._playerDivId = playerDivId;
	            this._emitter = new EventEmitter();
	            this._muted = false;
	        };

	        proto.baseSetup = function (config) {
	            configHandler.merge(config, this.config);
	            configHandler.clean(this.config);
	            if (this.config.style.view) {
	                this.registerExternalEventHandler();
	                this._style = style.create(this._emitter, this._playerDivId, this.config.style);
	                if (!this.config.style.audioPlayer) {
	                    this._fullscreen = fullscreen.create(this._playerDivId, this._emitter);
	                    this._middleView = middleview.create(this._playerDivId);
	                    this._resizeListener = resizeListener.create(this._playerDivId, this._emitter);
	                }
	            }
	            if (this.config.style.controls) {
	                this._controls = controls.create(this._playerDivId, this._emitter, this.config.style.audioPlayer);
	            }
	        };

	        proto.postSetup = function (mediaElementId) {
	            this._mediaElementId = mediaElementId;
	            this._mediaElement = this.getMediaElement();
	            if (this.config.style.view) {
	                this._style.update(this._mediaElement);
	            }
	            if (this.config.style.interactive && !this.config.style.audioPlayer) {
	                this._interactive = interaction.create(this._playerDivId, this._mediaElement, this._emitter);
	                this._interactive.update(this.state);
	            }
	            else if (this.config.style.controls) {
	                this._controls.show();
	            }
	            this.registerInternalEventHandler();
	        };

	        proto.getMediaElement = function () {
	            var el = document.getElementById(this._mediaElementId);
	            if (el === null && conditions.isIOS11) {
	                var iframe = document.getElementById(this._playerDivId).querySelector('iframe');
	                el = iframe.contentDocument.body.firstChild;
	            }
	            return el;
	        };

	        proto.registerExternalEventHandler = function () {
	            for (var key in viewEvents) {
	                if (viewEvents.hasOwnProperty(key)) {
	                    this._emitter.on(viewEvents[key], this._emit.bind(this, viewEvents[key]));
	                }
	            }
	        };

	        proto.registerInternalEventHandler = function () {
	            if (this._interactive) {
	                this._emitter.on(
	                    interactionEvents.PLAYBUTTON_SINGLE_CLICK,
	                    function (e) {
	                        if (!(this.state === playerStates.READY || this.state === playerStates.PAUSED)) {
	                            this._emitter.emit(viewEvents.PAUSE);
	                        }
	                        else {
	                            this._emitter.emit(viewEvents.PLAY);
	                        }
	                    }.bind(this)
	                );
	                this._emitter.on(
	                    interactionEvents.PLAYER_SINGLE_CLICK,
	                    function (e) {
	                        this._controls && this._controls.appear();
	                    }.bind(this)
	                );
	            }
	            if (this._controls) {
	                var excludes = [controlsEvents.FULLSCREEN_ENTER, controlsEvents.FULLSCREEN_EXIT];
	                for (var key in controlsEvents) {
	                    if (controlsEvents.hasOwnProperty(key) && viewEvents.hasOwnProperty(key)) {
	                        if (excludes.indexOf(controlsEvents[key]) === -1) {
	                            this._emitter.on(
	                                controlsEvents[key],
	                                this._emitter.emit.bind(this._emitter, viewEvents[key])
	                            );
	                        }
	                        else if (this._fullscreen) {
	                            this._emitter.on(
	                                controlsEvents[key],
	                                function (e) {
	                                    this._fullscreen && this._fullscreen.change();
	                                }.bind(this)
	                            );
	                        }
	                    }
	                }
	            }
	            if (this._fullscreen) {
	                for (var key in fullscreenEvents) {
	                    if (fullscreenEvents.hasOwnProperty(key)) {
	                        this._emitter.on(
	                            fullscreenEvents[key],
	                            function (e) {
	                                this.handleFullscreen(e && e === fullscreenEvents.FULLSCREEN_ENTER);
	                            }
	                                .bind(this)
	                                .bind(this, fullscreenEvents[key])
	                        );
	                        this._emitter.on(
	                            fullscreenEvents[key],
	                            this._emitter.emit.bind(this._emitter, viewEvents[key])
	                        );
	                    }
	                }
	            }
	            if (this._resizeListener) {
	                this._emitter.on(viewEvents.PLAYER_RESIZE, this._onPlayerResize.bind(this));
	            }
	        };

	        proto.removeExternalEventHandler = function () {
	            for (var key in viewEvents) {
	                if (viewEvents.hasOwnProperty(key)) {
	                    this._emitter.removeAllListeners(viewEvents[key]);
	                }
	            }
	        };

	        proto.removeInternalEventHandler = function () {
	            if (this._interactive) {
	                this._emitter.removeAllListeners(interactionEvents.PLAYER_SINGLE_CLICK);
	                this._emitter.removeAllListeners(interactionEvents.PLAYBUTTON_SINGLE_CLICK);
	            }
	            if (this._controls) {
	                for (var key in controlsEvents) {
	                    if (controlsEvents.hasOwnProperty(key) && viewEvents.hasOwnProperty(key)) {
	                        this._emitter.removeAllListeners(controlsEvents[key]);
	                    }
	                }
	            }
	            if (this._fullscreen) {
	                for (var key in fullscreenEvents) {
	                    if (fullscreenEvents.hasOwnProperty(key)) {
	                        this._emitter.removeAllListeners(fullscreenEvents[key]);
	                    }
	                }
	            }
	            if (this._resizeListener) {
	                this._emitter.removeAllListeners(viewEvents.PLAYER_RESIZE);
	            }
	        };

	        /*/////////////////////////////////////////

	    Public API

	    /////////////////////////////////////////*/

	        proto.destroy = function () {
	            this.removeExternalEventHandler();
	            this.removeInternalEventHandler();
	            this._resizeListener && this._resizeListener.destroy();
	            this._style && this._style.destroy();
	            this._interactive && this._interactive.destroy();
	            this._scaling && this._scaling.destroy();
	            this._middleView && this._middleView.destroy();
	            this._controls && this._controls.destroy();
	            this._fullscreen && this._fullscreen.destroy();
	            this._emitter = null;
	        };

	        proto.update = function (event) {
	            this.state = event.state;
	            this._emitter.emit(events.STATE_CHANGE, event);
	            this.handleView(event.state);
	            this._interactive && this._interactive.update(event.state);
	        };

	        proto.handleView = function (state) {
	            this._viewTimeout && clearTimeout(this._viewTimeout);
	            switch (state) {
	                case playerStates.UNINITIALIZED:
	                    this._middleView && this._middleView.update(animations.ERROR);
	                    break;
	                case playerStates.IDLE:
	                    this._middleView && this._middleView.update(animations.NONE);
	                    break;
	                case playerStates.READY:
	                    this._middleView && this._middleView.update(animations.PLAYBUTTON);
	                    this._controls && this._controls.play();
	                    break;
	                case playerStates.LOADING:
	                    this._middleView && this._middleView.update(animations.LOADING);
	                    this._controls && this._controls.pause();
	                    break;
	                case playerStates.PLAYING:
	                    this.handleAudioOnly();
	                    this._controls && this._controls.pause();
	                    break;
	                case playerStates.PAUSED:
	                    this._middleView && this._middleView.update(animations.PLAYBUTTON);
	                    this._controls && this._controls.play();
	                    break;
	                case playerStates.BUFFERING:
	                    this._viewTimeout = setTimeout(
	                        function () {
	                            this._middleView && this._middleView.update(animations.LOADING);
	                            this._controls && this._controls.pause();
	                        }.bind(this),
	                        1000
	                    );
	                    break;
	                case playerStates.UNKNOWN:
	                    this._middleView && this._middleView.update(animations.NONE);
	                    break;
	                default:
	                    break;
	            }
	        };

	        proto.handleStreamInfo = function (event) {
	            this._emitter.emit(events.STREAM_INFO, event);
	            this.streamInfo = event.data.streamInfo;
	            if (this.streamInfo.haveVideo) {
	                this._scaling && this._scaling.update(this.config.style.scaling);
	                !this._scaling &&
	                    (this._scaling = scaling.create(
	                        this._playerDivId,
	                        this._mediaElement,
	                        this.streamInfo.videoInfo,
	                        this.config.style.scaling
	                    ));
	            }
	        };

	        proto.handleAudioOnly = function () {
	            if (
	                this.state === playerStates.PLAYING &&
	                this.config.style.displayAudioOnly &&
	                this.streamInfo &&
	                !this.streamInfo.haveVideo &&
	                this.streamInfo.haveAudio
	            ) {
	                this._middleView && this._middleView.update(animations.AUDIOONLY, this._muted);
	            }
	            else {
	                this._middleView && this._middleView.update(animations.NONE);
	            }
	        };

	        proto.handleMute = function (mute) {
	            this._controls && (mute ? this._controls.mute() : this._controls.unmute());
	            this._muted = mute;
	            this.handleAudioOnly();
	        };

	        proto.handleVolume = function (volume) {
	            this._controls && this._controls.volume(volume);
	        };

	        proto.handleFullscreen = function (enable) {
	            this._controls && this._controls.fullscreen(enable);
	        };

	        proto.handleStats = function (stats) {
	            this._controls && this._controls.time(stats.currentTime);
	        };

	        proto.handleMetaData = function (e) {
	            if (typeof e.data.message === 'object' && e.data.message.hasOwnProperty('nanoStreamStatus')) {
	                var rotation =
	                    typeof e.data.message.nanoStreamStatus === 'object' &&
	                    e.data.message.nanoStreamStatus.hasOwnProperty('VideoRotation')
	                        ? e.data.message.nanoStreamStatus.VideoRotation
	                        : 0;
	                this._scaling && this._scaling.update(this.config.style.scaling, rotation);
	            }
	        };

	        /*/////////////////////////////////////////

	    Private API

	    /////////////////////////////////////////*/

	        proto._emit = function (name, event) {
	            var evt = {};
	            if (event && event.name && event.data) {
	                evt = event;
	            }
	            else if (event) {
	                evt.data = event;
	                evt.name = name || 'unknown';
	            }
	            else {
	                evt.data = {};
	                evt.name = name || 'unknown';
	            }
	            evt.player = this._playerDivId;
	            evt.state = this.state;
	            this.emit(evt.name, evt);
	        };

	        proto._onPlayerResize = function (event) {
	            this.handleView(this.state);
	            this._scaling && this._scaling.update();
	            this._controls && this._controls.size();
	        };

	        ViewController.events = viewEvents;
	        ViewController.emptyConfig = emptyConfig;

	        return ViewController;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'PAUSE'            : 'ClickPause',
	        'PLAY'             : 'ClickPlay',
	        'FULLSCREEN_ENTER' : 'ClickFullscreenEnter',
	        'FULLSCREEN_EXIT'  : 'ClickFullscreenExit',
	        'PLAYER_RESIZE'    : 'PlayerResize',
	        'MUTE'             : 'ClickMute',
	        'UNMUTE'           : 'ClickUnmute',
	        'VOLUME_CHANGE'    : 'ClickVolumeChange'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function create () {
	        return {
	            'style': {
	                'width'            : undefined,
	                'height'           : undefined,
	                'aspectratio'      : undefined,
	                'controls'         : true,
	                'interactive'      : true,
	                'view'             : true,
	                'scaling'          : 'letterbox',
	                'keepFrame'        : true,
	                'displayAudioOnly' : true,
	                'audioPlayer'      : false
	            }
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	// validconfig.js

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function create () {
	        return {
	            'style': {
	                'width'            : 'string',
	                'height'           : 'string',
	                'aspectratio'      : 'string',
	                'controls'         : 'boolean',
	                'interactive'      : 'boolean',
	                'view'             : 'boolean',
	                'scaling'          : 'string',
	                'keepFrame'        : 'boolean',
	                'displayAudioOnly' : 'boolean',
	                'audioPlayer'      : 'boolean'
	            }
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(99)], __WEBPACK_AMD_DEFINE_RESULT__ = function (viewEvents) {
	    'use strict';

	    function create (playerDivId, emitter) {
	        var player = document.getElementById(playerDivId);
	        var width = player.clientWidth,
	            height = player.clientHeight,
	            interval = 0,
	            _emitter = emitter;
	        function progress () {
	            if (player && (player.clientWidth !== width || player.clientHeight !== height)) {
	                width = player.clientWidth;
	                height = player.clientHeight;
	                _emitter.emit(viewEvents.PLAYER_RESIZE, {
	                    'width'       : width,
	                    'height'      : height,
	                    'aspectratio' : width / height
	                });
	            }
	        }
	        function destroy () {
	            if (interval) {
	                clearInterval(interval);
	            }
	            interval = 0;
	            player = null;
	            return null;
	        }
	        interval = setInterval(progress, 100);
	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'UNINITIALIZED' : 1,
	        'IDLE'          : 2,
	        'READY'         : 3,
	        'LOADING'       : 4,
	        'PLAYING'       : 5,
	        'PAUSED'        : 6,
	        'BUFFERING'     : 7,
	        'UNKNOWN'       : 8
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'CLICK'        : 'click',
	        'DOUBLE_CLICK' : 'dblclick',
	        'TOUCH_START'  : 'touchstart',
	        'TOUCH_END'    : 'touchend',
	        'MOUSE_DOWN'   : 'mousedown',
	        'MOUSE_UP'     : 'mouseup',
	        'MOUSE_ENTER'  : 'mouseenter',
	        'MOUSE_LEAVE'  : 'mouseleave',
	        'MOUSE_MOVE'   : 'mousemove'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'FULLSCREEN_ENTER' : 'FullscreenEnter',
	        'FULLSCREEN_EXIT'  : 'FullscreenExit'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-28.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'PLAYER_SINGLE_CLICK'     : 'PlayerSingleClick',
	        'PLAYER_DOUBLE_CLICK'     : 'PlayerDoubleClick',
	        'PLAYBUTTON_SINGLE_CLICK' : 'PlaybuttonSingleClick'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'PLAY'             : 'ControlsPlay',
	        'PAUSE'            : 'ControlsPause',
	        'MUTE'             : 'ControlsMute',
	        'UNMUTE'           : 'ControlsUnmute',
	        'VOLUME_CHANGE'    : 'ControlsVolumeChange',
	        'FULLSCREEN_ENTER' : 'ControlsFullscreenEnter',
	        'FULLSCREEN_EXIT'  : 'ControlsFullscreenExit'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'NONE'       : 'none',
	        'LOADING'    : 'loading',
	        'PLAYBUTTON' : 'playbutton',
	        'ERROR'      : 'error',
	        'AUDIOONLY'  : 'audioonly'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(11),
	        __webpack_require__(106),
	        __webpack_require__(99),
	        __webpack_require__(104),
	        __webpack_require__(103)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (BrowserInfo, interactionEvents, viewEvents, domEvents, playerStates) {
	        'use strict';

	        function create (playerDivId, mediaElement, emitter) {
	            var player = document.getElementById(playerDivId),
	                playerState;
	            var clickHandlerFlags = {
	                'timeout'         : 0,
	                'touchInProgress' : false
	            };
	            function addListener () {
	                player.addEventListener(domEvents.CLICK, onClick);
	                mediaElement.addEventListener(domEvents.CLICK, onClick);
	                mediaElement.addEventListener('contextmenu', onContext);
	            }
	            function removeListener () {
	                player.removeEventListener(domEvents.CLICK, onClick);
	                mediaElement.removeEventListener(domEvents.CLICK, onClick);
	                mediaElement.removeEventListener('contextmenu', onContext);
	            }
	            function update (state) {
	                playerState = state;
	                if (playerState === playerStates.READY || playerState === playerStates.PAUSED) {
	                    var playButton = document.getElementById('playButton-' + playerDivId);
	                    if (playButton) {
	                        playButton.addEventListener(domEvents.CLICK, onClick);
	                    }
	                    removeListener();
	                    setTimeout(addListener, 200);
	                }
	            }
	            function onClick (e) {
	                e.preventDefault();
	                e.stopPropagation ? e.stopPropagation() : (e.cancelBubble = true);
	                if (e.target.id && e.target.id.indexOf('controls-') !== -1) return;
	                if (e.button && e.button !== 0) return;
	                if (clickHandlerFlags.touchInProgress) {
	                    return;
	                }
	                clickHandlerFlags.touchInProgress = true;
	                if (e.target.id && e.target.id.indexOf('playButton-') !== -1) {
	                    emitter.emit(interactionEvents.PLAYBUTTON_SINGLE_CLICK);
	                }
	                else {
	                    emitter.emit(interactionEvents.PLAYER_SINGLE_CLICK);
	                }
	                clickHandlerFlags.timeout = setTimeout(function () {
	                    clickHandlerFlags.touchInProgress = false;
	                    clearTimeout(clickHandlerFlags.timeout);
	                    clickHandlerFlags.timeout = 0;
	                }, 300);
	            }
	            function onContext (e) {
	                e.preventDefault();
	                return false;
	            }
	            function destroy () {
	                removeListener();
	                clickHandlerFlags.timeout && clearTimeout(clickHandlerFlags.timeout);
	                clickHandlerFlags.timeout = 0;
	                mediaElement = null;
	                player = null;
	                return null;
	            }
	            return {
	                'update'  : update,
	                'destroy' : destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(111), __webpack_require__(8), __webpack_require__(9), __webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = function (BrowserInfo, styleNormalize, events, playerStates, listenerManager) {
	        'use strict';

	        function create (emitter, playerDivId, style) {
	            var player, playerState, mediaElement;
	            var listeners = [
	                    {
	                        'type'     : events.STATE_CHANGE,
	                        'listener' : onStateChange
	                    },
	                    {
	                        'type'     : events.STREAM_INFO,
	                        'listener' : onStreamInfo
	                    }
	                ],
	                listenerAdded = false;
	            function add (style) {
	                player = document.getElementById(playerDivId);
	                var width, height;
	                var isPer, isPx;
	                var asp;
	                var dimensions = ['width', 'height'];
	                var direction = 0;
	                if (!(style.width === 'auto' || style.height === 'auto')) {
	                    if (style.audioPlayer) {
	                        if (style.width && style.height) {
	                            player.style.width = style.width;
	                            player.style.height = style.height;
	                        }
	                        else if (style.width) {
	                            player.style.width = style.width;
	                            player.style.height =
	                                Math.round(!BrowserInfo.mobile ? 100 / 12 : 100 / 6) / 100 * player.clientWidth + 'px';
	                        }
	                        else if (!player.clientWidth && !player.clientHeight) {
	                            player.style.width = '640px';
	                            player.style.height =
	                                Math.round(!BrowserInfo.mobile ? 100 / 12 : 100 / 6) / 100 * player.clientWidth + 'px';
	                        }
	                        else if (player.clientWidth) {
	                            player.style.height =
	                                Math.round(!BrowserInfo.mobile ? 100 / 12 : 100 / 6) / 100 * player.clientWidth + 'px';
	                        }
	                    }
	                    else if (style.width && style.height) {
	                        player.style.width = style.width;
	                        player.style.height = style.height;
	                    }
	                    else if ((style.width || style.height) && style.aspectratio) {
	                        direction = +!!style.height; // 0: width > height, 1: height > width
	                        isPer = style[dimensions[direction]].indexOf('%') !== -1;
	                        isPx = style[dimensions[direction]].indexOf('px') !== -1;
	                        player.style[dimensions[direction]] = style[dimensions[direction]];
	                        asp = style.aspectratio.split('/');
	                        asp[0] = parseInt(asp[0]);
	                        asp[1] = parseInt(asp[1]);
	                        if (isPer || isPx) {
	                            width = parseInt(style[dimensions[direction]].replace(isPer ? '%' : 'px', ''));
	                            height =
	                                Math.round(width * asp[+!direction] / asp[direction]).toString() + (isPer ? '%' : 'px');
	                            player.style[dimensions[+!direction]] = height;
	                        }
	                    }
	                    else if (
	                        ((!style.width && !style.height) ||
	                            (!style.width && !style.aspectratio) ||
	                            (!style.aspectratio && !style.height)) &&
	                        (!player.clientWidth || !player.clientHeight)
	                    ) {
	                        player.style.width = '640px';
	                        player.style.height = '360px';
	                    }
	                }
	                else if (!player.clientWidth && !player.clientHeight) {
	                    player.style.width = '640px';
	                    player.style.height = style.audioPlayer
	                        ? Math.round(!BrowserInfo.mobile ? 100 / 12 : 100 / 6) / 100 * player.clientWidth + 'px'
	                        : '360px';
	                }
	                else if (!player.clientWidth && style.width === 'auto') {
	                    if (style.aspectratio) {
	                        asp = style.aspectratio.split('/');
	                        asp[0] = parseInt(asp[0]);
	                        asp[1] = parseInt(asp[1]);
	                        player.style.width = Math.round(player.clientHeight * asp[0] / asp[1]).toString() + 'px';
	                    }
	                    else {
	                        player.style.width = Math.round(player.clientHeight * 16 / 9).toString() + 'px';
	                    }
	                }
	                else if (!player.clientHeight) {
	                    if (style.aspectratio && !style.audioPlayer) {
	                        asp = style.aspectratio.split('/');
	                        asp[0] = parseInt(asp[0]);
	                        asp[1] = parseInt(asp[1]);
	                        player.style.height = Math.round(player.clientWidth / asp[0] * asp[1]).toString() + 'px';
	                    }
	                    else {
	                        player.style.height = style.audioPlayer
	                            ? Math.round(!BrowserInfo.mobile ? 100 / 12 : 100 / 6) / 100 * player.clientWidth + 'px'
	                            : Math.round(player.clientWidth / 16 * 9).toString() + 'px';
	                    }
	                }
	                player.style.overflow = 'hidden';
	                player.style.position = 'relative';
	                player.style.backgroundColor = style.audioPlayer ? 'transparent' : 'black';
	            }
	            function update (element) {
	                mediaElement = element;
	                if (mediaElement) {
	                    !listenerAdded &&
	                        listenerManager.add({
	                            'target'    : emitter,
	                            'listeners' : listeners
	                        });
	                    mediaElement.style.width = '100%';
	                    mediaElement.style.height = '100%';
	                    mediaElement.style.position = 'absolute';
	                    mediaElement.style.left = '50%';
	                    mediaElement.style.top = '50%';
	                    mediaElement.style.marginRight = '-50%';
	                    mediaElement.style.backgroundColor = style.audioPlayer ? 'transparent' : 'black';
	                    styleNormalize.normalize(mediaElement, 'transform', 'translate(-50%, -50%)');
	                }
	            }
	            function destroy () {
	                listenerManager.remove({
	                    'target'    : emitter,
	                    'listeners' : listeners
	                });
	                player = null;
	                mediaElement = null;
	                return null;
	            }
	            function onStateChange (e) {
	                playerState = e.state;
	                if (style.audioPlayer) {
	                    mediaElement.style.visibility = 'hidden';
	                }
	                else if (playerState == playerStates.READY) {
	                    !style.keepFrame && (mediaElement.style.visibility = 'hidden');
	                }
	                else if (playerState == playerStates.PAUSED) {
	                    !style.keepFrame && (mediaElement.style.visibility = 'hidden');
	                }
	                else if (playerState == playerStates.PLAYING) {
	                    !style.keepFrame && (mediaElement.style.visibility = 'visible');
	                }
	            }
	            function onStreamInfo (e) {
	                if (style.audioPlayer) {
	                    mediaElement.style.visibility = 'hidden';
	                }
	            }
	            add(style);
	            return {
	                'update'  : update,
	                'destroy' : destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player Core
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function normalize (element, key, style) {
	        var keys = createKeys(key),
	            normalizedKey = '';
	        for (var k = 0; k < keys.length; k += 1) {
	            normalizedKey = keys[k];
	            if (normalizedKey in element.style) {
	                element.style[normalizedKey] = style;
	                break;
	            }
	        }
	    }
	    function createKeys (key) {
	        var len = key.length - 1,
	            upper = key.substr(0, 1).toUpperCase() + key.substr(1, len);
	        return ['webkit' + upper, 'moz' + upper, 'ms' + upper, key];
	    }
	    return {
	        'normalize': normalize
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(111),
	        __webpack_require__(108),
	        __webpack_require__(113),
	        __webpack_require__(114),
	        __webpack_require__(115),
	        __webpack_require__(116)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (styleNormalize, animations, loading, playbutton, error, audioonly) {
	        'use strict';

	        function create (playerDivId) {
	            var animation = {
	                'loading'    : loading,
	                'playbutton' : playbutton,
	                'error'      : error,
	                'audioonly'  : audioonly
	            };
	            var currentAnimation = null;
	            var player = document.getElementById(playerDivId);
	            var middleViewId = 'middleView-' + playerDivId;
	            var middleView = document.createElement('div');
	            function add () {
	                if (!document.getElementById(middleViewId)) {
	                    var dim = getViewDimension();
	                    middleView.id = middleViewId;
	                    middleView.style.width = dim.width + 'px';
	                    middleView.style.height = dim.height + 'px';
	                    middleView.style.position = 'absolute';
	                    middleView.style.left = '50%';
	                    middleView.style.top = '50%';
	                    middleView.style.marginRight = '-50%';
	                    styleNormalize.normalize(middleView, 'transform', 'translate(-50%, -50%)');
	                    middleView.style.zIndex = 1000;
	                    player.appendChild(middleView);
	                }
	            }
	            function remove () {
	                if (document.getElementById(middleViewId)) {
	                    player.removeChild(middleView);
	                }
	            }
	            function getViewDimension () {
	                var player = document.getElementById(playerDivId),
	                    factor = 0.2,
	                    dim = Math.round(Math.min(player.clientWidth, player.clientHeight) * factor);
	                return {
	                    'width'  : dim,
	                    'height' : dim
	                };
	            }
	            function update (what, value) {
	                if (currentAnimation && currentAnimation.destroy) {
	                    currentAnimation.destroy();
	                    currentAnimation = null;
	                }
	                if (what && what !== animations.NONE) {
	                    add();
	                    currentAnimation = animation[what].create(playerDivId, middleView, getViewDimension, value);
	                }
	                else {
	                    remove();
	                }
	            }
	            function destroy () {
	                if (currentAnimation && currentAnimation.destroy) {
	                    currentAnimation.destroy();
	                    currentAnimation = null;
	                }
	                remove();
	                middleView = null;
	                player = null;
	                return null;
	            }
	            return {
	                'update'  : update,
	                'destroy' : destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    function create (playerDivId, middleView, dimCheck) {
	        var canvas = document.createElement('canvas');
	        var loading = {
	            'id'        : 'loadingSign-' + playerDivId,
	            'interval'  : setInterval(progress, 100),
	            'ctx'       : canvas.getContext('2d'),
	            'pi'        : Math.PI,
	            'xCenter'   : undefined,
	            'yCenter'   : undefined,
	            'radius'    : undefined,
	            'startSize' : undefined,
	            'num'       : 5,
	            'posX'      : [],
	            'posY'      : [],
	            'angle'     : undefined,
	            'size'      : undefined,
	            'i'         : undefined
	        };
	        canvas.id = loading.id;
	        canvas.style.zIndex = 1001;
	        middleView.appendChild(canvas);
	        function progress () {
	            var dim = dimCheck();
	            (middleView.style.width = dim.width + 'px') && (canvas.width = middleView.clientWidth);
	            (middleView.style.height = dim.height + 'px') && (canvas.height = middleView.clientHeight);
	            loading.xCenter = canvas.width / 2;
	            loading.yCenter = canvas.height / 2;
	            loading.radius = canvas.width / 3;
	            loading.startSize = loading.radius / 3;
	            loading.num++;
	            loading.ctx.clearRect(0, 0, loading.xCenter * 2, loading.yCenter * 2);
	            for (loading.i = 0; loading.i < 9; loading.i++) {
	                loading.ctx.beginPath();
	                loading.ctx.fillStyle = 'rgba(255,255,255,' + 0.1 * loading.i + ')';
	                loading.angle = loading.pi * loading.i * 0.25;
	                loading.posX[loading.i] = loading.xCenter + loading.radius * Math.cos(loading.angle);
	                loading.posY[loading.i] = loading.yCenter + loading.radius * Math.sin(loading.angle);
	                loading.ctx.arc(
	                    loading.posX[(loading.i + loading.num) % 8],
	                    loading.posY[(loading.i + loading.num) % 8],
	                    loading.startSize / 9 * loading.i,
	                    0,
	                    loading.pi * 2,
	                    1
	                );
	                loading.ctx.fill();
	            }
	        }
	        function destroy () {
	            if (loading.interval) {
	                clearInterval(loading.interval);
	            }
	            loading.interval = 0;
	            loading.ctx && loading.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            middleView.removeChild(canvas);
	            canvas = null;
	            return null;
	        }
	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    function create (playerDivId, middleView, dimCheck) {
	        var canvas = document.createElement('canvas');
	        var playButton = {
	            'id'  : 'playButton-' + playerDivId,
	            'ctx' : canvas.getContext('2d')
	        };
	        canvas.id = playButton.id;
	        canvas.style.zIndex = 1001;
	        middleView.appendChild(canvas);
	        function progress () {
	            var dim = dimCheck();
	            (middleView.style.width = dim.width + 'px') && (canvas.width = middleView.clientWidth);
	            (middleView.style.height = dim.height + 'px') && (canvas.height = middleView.clientHeight);
	            var length = canvas.width;
	            playButton.ctx.beginPath();
	            playButton.ctx.fillStyle = 'transparent';
	            playButton.ctx.arc(length * 0.5, length * 0.5, length * 0.45, 0, 2 * Math.PI);
	            playButton.ctx.fill();
	            playButton.ctx.lineWidth = length * 0.05;
	            playButton.ctx.strokeStyle = 'rgba(255,255,255,0.7)';
	            playButton.ctx.stroke();
	            playButton.ctx.fillStyle = 'rgba(255,255,255,0.7)';
	            playButton.ctx.beginPath();
	            playButton.ctx.moveTo(length * 0.35, length * 0.25);
	            playButton.ctx.lineTo(length * 0.35, length * 0.75);
	            playButton.ctx.lineTo(length * 0.75, length * 0.5);
	            playButton.ctx.fill();
	        }
	        function destroy () {
	            playButton.ctx && playButton.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            middleView.removeChild(canvas);
	            canvas = null;
	            return null;
	        }
	        progress();
	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    function create (playerDivId, middleView, dimCheck) {
	        var canvas = document.createElement('canvas');
	        var error = {
	            'id'  : 'exclamationSign-' + playerDivId,
	            'ctx' : canvas.getContext('2d')
	        };
	        canvas.id = error.id;
	        canvas.style.zIndex = 1001;
	        middleView.appendChild(canvas);
	        function progress () {
	            var dim = dimCheck();
	            (middleView.style.width = dim.width + 'px') && (canvas.width = middleView.clientWidth);
	            (middleView.style.height = dim.height + 'px') && (canvas.height = middleView.clientHeight);

	            var length = canvas.width;
	            // Dimensions of the triangle
	            var width = length * 0.8;
	            var height = length * 0.7;
	            var padding = length * 0.1;
	            var primaryColor = '#ffc821';
	            var secondaryColor = '#faf100';
	            var tertiaryColor = '#dcaa09';
	            var lineWidth = length * 0.05;

	            // Create a triangluar path
	            error.ctx.beginPath();
	            error.ctx.moveTo(padding + width / 2, padding);
	            error.ctx.lineTo(padding + width, height + padding);
	            error.ctx.lineTo(padding, height + padding);
	            error.ctx.closePath();

	            // Create fill gradient
	            var gradient = error.ctx.createLinearGradient(0, 0, 0, height);
	            gradient.addColorStop(0, primaryColor);
	            gradient.addColorStop(1, secondaryColor);

	            // Stroke the outer outline
	            error.ctx.lineWidth = lineWidth * 2;
	            error.ctx.lineJoin = 'round';
	            error.ctx.strokeStyle = gradient;
	            error.ctx.stroke();

	            // Fill the path
	            error.ctx.fillStyle = gradient;
	            error.ctx.fill();

	            // Add a horizon reflection with a gradient to transparent
	            gradient = error.ctx.createLinearGradient(0, padding, 0, padding + height);
	            gradient.addColorStop(0, 'transparent');
	            gradient.addColorStop(0.5, 'transparent');
	            gradient.addColorStop(0.5, tertiaryColor);
	            gradient.addColorStop(1, secondaryColor);

	            error.ctx.fillStyle = gradient;
	            error.ctx.fill();

	            // Stroke the inner outline
	            error.ctx.lineWidth = lineWidth;
	            error.ctx.lineJoin = 'round';
	            error.ctx.strokeStyle = '#333';
	            error.ctx.stroke();

	            // Draw the text exclamation point
	            error.ctx.textAlign = 'center';
	            error.ctx.textBaseline = 'middle';
	            error.ctx.font = 'bold ' + Math.round(height / 1.3) + 'px "Times New Roman", Times, serif';
	            error.ctx.fillStyle = '#333';
	            try {
	                error.ctx.fillText('!', padding + width / 2, padding + height / 1.7);
	            }
	            catch (ex) {}
	        }
	        function destroy () {
	            error.ctx && error.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            middleView.removeChild(canvas);
	            canvas = null;
	            return null;
	        }
	        progress();
	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    function create (playerDivId, middleView, dimCheck, muted) {
	        var canvas = document.createElement('canvas'),
	            length,
	            x,
	            y,
	            radius,
	            startAngle,
	            endAngle,
	            counterClockwise = false;
	        var audioOnly = {
	            'id'  : 'audioOnly-' + playerDivId,
	            'ctx' : canvas.getContext('2d')
	        };
	        canvas.id = audioOnly.id;
	        canvas.style.zIndex = 1001;
	        middleView.appendChild(canvas);
	        function progress () {
	            var dim = dimCheck();
	            (middleView.style.width = dim.width + 'px') && (canvas.width = middleView.clientWidth);
	            (middleView.style.height = dim.height + 'px') && (canvas.height = middleView.clientHeight);
	            var ctx = audioOnly.ctx;
	            var length = canvas.width;
	            var points = {
	                'l175' : r(length * 0.175),
	                'l20'  : r(length * 0.2),
	                'l30'  : r(length * 0.3),
	                'l37'  : r(length * 0.37),
	                'l50'  : r(length * 0.5),
	                'l63'  : r(length * 0.63),
	                'l825' : r(length * 0.825)
	            };
	            ctx.beginPath();
	            ctx.fillStyle = 'rgba(255,255,255,1)';
	            ctx.strokeStyle = 'rgba(255,255,255,1)';
	            ctx.lineJoin = 'round';
	            ctx.moveTo(points.l20, points.l37);
	            ctx.lineTo(points.l20, points.l63);
	            ctx.lineTo(points.l30, points.l63);
	            ctx.lineTo(points.l50, points.l825);
	            ctx.lineTo(points.l50, points.l175);
	            ctx.lineTo(points.l30, points.l37);
	            ctx.fill();
	            ctx.lineWidth = r(length * 0.1);
	            ctx.lineCap = 'round';
	            if (muted) {
	                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
	            }
	            x = y = canvas.width / 2;
	            radius = length * 0.3;
	            startAngle = 1.6 * Math.PI;
	            endAngle = 0.4 * Math.PI;
	            ctx.beginPath();
	            ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);
	            ctx.stroke();
	            radius = length * 0.15;
	            startAngle = 1.7 * Math.PI;
	            endAngle = 0.3 * Math.PI;
	            ctx.beginPath();
	            ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);
	            ctx.stroke();
	        }
	        function r (x) {
	            return Math.round(x);
	        }
	        function destroy () {
	            audioOnly.ctx && audioOnly.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            middleView.removeChild(canvas);
	            canvas = null;
	            return null;
	        }
	        progress();
	        return {
	            'destroy': destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(111), __webpack_require__(118)], __WEBPACK_AMD_DEFINE_RESULT__ = function (styleNormalize, scalingModes) {
	    'use strict';

	    function create (playerDivId, mediaElement, videoInfo, scalingMode) {
	        scalingMode = scalingMode || scalingModes.LETTERBOX;
	        var player = document.getElementById(playerDivId);
	        var aspectRatioVideo = videoInfo.width / videoInfo.height;
	        function getDim () {
	            player = document.getElementById(playerDivId);
	            return {
	                'width'  : player.clientWidth,
	                'height' : player.clientHeight
	            };
	        }
	        function progress (rotation) {
	            if (mediaElement) {
	                rotation = typeof rotation === 'undefined' ? 0 : rotation;
	                var dim = getDim();
	                var res = ['100%', '100%'],
	                    aspectRatioPlayer = dim.width / dim.height,
	                    delta = (aspectRatioPlayer - aspectRatioVideo).toFixed(2);
	                var scaleX = 1,
	                    scaleY = 1;
	                switch (scalingMode) {
	                    case 'letterbox':
	                        if (rotation % 180) {
	                            scaleX = (scaleX / aspectRatioVideo).toFixed(2);
	                            scaleY = (scaleY / aspectRatioVideo).toFixed(2);
	                        }
	                        break;
	                    case 'crop':
	                        if (delta < 0) {
	                            scaleY = (dim.height / (dim.width / aspectRatioVideo)).toFixed(2);
	                            scaleX = scaleY;
	                        }
	                        else if (delta >= 0) {
	                            scaleX = (dim.width / (dim.height * aspectRatioVideo)).toFixed(2);
	                            scaleY = scaleX;
	                        }
	                        if (rotation % 180) {
	                            scaleX = (scaleX * delta).toFixed(2);
	                            scaleY = (scaleY * delta).toFixed(2);
	                        }
	                        break;
	                    case 'fill':
	                        if (delta < 0) {
	                            scaleY = (dim.height / (dim.width / aspectRatioVideo)).toFixed(2);
	                        }
	                        else if (delta >= 0) {
	                            scaleX = (dim.width / (dim.height * aspectRatioVideo)).toFixed(2);
	                        }
	                        break;
	                    case 'original':
	                        res[0] = videoInfo.width + 'px';
	                        res[1] = videoInfo.height + 'px';
	                        break;
	                    case 'resize':
	                        if (player.style.position !== 'fixed') {
	                            res[0] = videoInfo.width + 'px';
	                            res[1] = videoInfo.height + 'px';
	                            player.style.width = res[0];
	                            player.style.height = res[1];
	                        }
	                        break;
	                    default:
	                        break;
	                }
	                styleNormalize.normalize(
	                    mediaElement,
	                    'transform',
	                    'translate(-50%, -50%) scaleX(' + scaleX + ') scaleY(' + scaleY + ') rotate(' + rotation + 'deg)'
	                );
	                mediaElement.style.width = res[0];
	                mediaElement.style.height = res[1];
	            }
	        }
	        function update (mode, rotation) {
	            scalingMode = mode || scalingMode;
	            progress(rotation);
	        }
	        function destroy () {
	            mediaElement = null;
	            player = null;
	            return null;
	        }
	        progress();
	        return {
	            'update'  : update,
	            'destroy' : destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'NONE'      : 'none',
	        'LETTERBOX' : 'letterbox',
	        'CROP'      : 'crop',
	        'FILL'      : 'fill'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(120), __webpack_require__(123)], __WEBPACK_AMD_DEFINE_RESULT__ = function (native, emulate) {
	    'use strict';

	    function create (playerDivId, emitter) {
	        return nativeSupported() ? native.create(playerDivId, emitter) : emulate.create(playerDivId, emitter);
	    }
	    function nativeSupported () {
	        return (
	            document.exitFullscreen ||
	            document.mozCancelFullScreen ||
	            document.webkitExitFullscreen ||
	            document.msExitFullscreen
	        );
	    }
	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(121), __webpack_require__(122), __webpack_require__(105)], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    fullscreenStates,
	    fullscreenDomEvents,
	    fullscreenEvents
	) {
	    'use strict';

	    function create (playerDivId, emitter) {
	        var player = document.getElementById(playerDivId),
	            fullscreenState = fullscreenStates.EXITED;
	        player.requestFullScreen =
	            player.requestFullscreen ||
	            player.mozRequestFullScreen ||
	            player.webkitRequestFullscreen ||
	            player.msRequestFullscreen;
	        document.exitFullScreen =
	            document.exitFullscreen ||
	            document.mozCancelFullScreen ||
	            document.webkitExitFullscreen ||
	            document.msExitFullscreen;
	        var playerStyleCssText = player.style.cssText;
	        function addListener () {
	            for (var key in fullscreenDomEvents) {
	                fullscreenDomEvents.hasOwnProperty(key) &&
	                    document.addEventListener(fullscreenDomEvents[key], listener);
	            }
	        }
	        function removeListener () {
	            for (var key in fullscreenDomEvents) {
	                fullscreenDomEvents.hasOwnProperty(key) &&
	                    document.removeEventListener(fullscreenDomEvents[key], listener);
	            }
	        }
	        function listener (e) {
	            if (e.target !== player) return;
	            if (isPlayerFullScreen()) {
	                player.style.width = '100vw';
	                player.style.height = '100vh';
	            }
	            else {
	                player.style.cssText = playerStyleCssText;
	            }
	        }
	        function isPlayerFullScreen () {
	            var el = isFullscreen();
	            return el === player;
	        }
	        function isFullscreen () {
	            return (
	                document.fullscreenElement ||
	                document.mozFullScreenElement ||
	                document.webkitFullscreenElement ||
	                document.msFullscreenElement
	            );
	        }
	        function progress () {
	            try {
	                if (isPlayerFullScreen()) {
	                    document.exitFullScreen && document.exitFullScreen();
	                    fullscreenState = fullscreenStates.EXITED;
	                    emitter.emit(fullscreenEvents.FULLSCREEN_EXIT);
	                }
	                else {
	                    player.requestFullScreen && player.requestFullScreen();
	                    fullscreenState = fullscreenStates.ENTERED;
	                    emitter.emit(fullscreenEvents.FULLSCREEN_ENTER);
	                }
	            }
	            catch (err) {}
	        }
	        function change () {
	            progress();
	        }
	        function destroy () {
	            removeListener();
	            if (isPlayerFullScreen()) {
	                document.exitFullScreen && document.exitFullScreen();
	                fullscreenState = fullscreenStates.EXITED;
	                emitter.emit(fullscreenEvents.FULLSCREEN_EXIT);
	            }
	            player = null;
	            return null;
	        }
	        addListener();
	        return {
	            'change'  : change,
	            'destroy' : destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'ENTERED' : 'entered',
	        'EXITED'  : 'exited'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'FULLSCREEN_CHANGE'        : 'fullscreenChange',
	        'WEBKIT_FULLSCREEN_CHANGE' : 'webkitfullscreenchange',
	        'MOZ_FULLSCREEN_CHANGE'    : 'mozfullscreenchange',
	        'MS_FULLSCREEN_CHANGE'     : 'MSFullscreenChange'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(111), __webpack_require__(121), __webpack_require__(105)], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    styleNormalize,
	    fullscreenStates,
	    fullscreenEvents
	) {
	    'use strict';

	    function create (playerDivId, emitter) {
	        var player = document.getElementById(playerDivId),
	            fullscreenState = fullscreenStates.EXITED;
	        var playerStyleCssText = '',
	            bodyStyleCssText = '';
	        var usesViewPort = false;

	        var updateInterval = 0;

	        function init () {
	            var metas = document.querySelectorAll('meta'),
	                i;
	            for (i = 0; i < metas.length; ++i) {
	                var name = metas[i].getAttribute('name');
	                if (name && name.toLowerCase() === 'viewport') {
	                    usesViewPort = true;
	                }
	            }
	        }
	        function isFullscreen () {
	            return fullscreenState === fullscreenStates.ENTERED;
	        }
	        function progress () {
	            try {
	                if (isFullscreen()) {
	                    clearInterval(updateInterval);
	                    player.style.cssText = playerStyleCssText;
	                    fullscreenState = fullscreenStates.EXITED;
	                    emitter.emit(fullscreenEvents.FULLSCREEN_EXIT);
	                }
	                else {
	                    updateInterval = setInterval(update, 300);
	                    playerStyleCssText = player.style.cssText;
	                    bodyStyleCssText = document.body.style.cssText;
	                    player.style.position = 'fixed';
	                    player.style.left = 0;
	                    player.style.top = 0;
	                    calc();
	                    fullscreenState = fullscreenStates.ENTERED;
	                    emitter.emit(fullscreenEvents.FULLSCREEN_ENTER);
	                }
	            }
	            catch (err) {}
	        }
	        function calc () {
	            var zoomLevel = 1,
	                tH = 0;
	            zoomLevel = document.documentElement.clientWidth / window.innerWidth;
	            tH = (window.orientation === 0 ? screen.height : screen.width) - window.innerWidth * zoomLevel;
	            tH = tH > 1 && !usesViewPort ? tH : 0;
	            player.style.width = window.innerWidth * zoomLevel + 'px';
	            player.style.height = window.innerHeight * zoomLevel - tH + 'px';
	        }
	        function update () {
	            try {
	                if (isFullscreen()) {
	                    calc();
	                }
	            }
	            catch (err) {}
	        }
	        function change () {
	            progress();
	        }
	        function destroy () {
	            if (isFullscreen()) {
	                progress();
	            }
	            player = null;
	            return null;
	        }
	        init();
	        return {
	            'change'  : change,
	            'destroy' : destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(11),
	        __webpack_require__(104),
	        __webpack_require__(126),
	        __webpack_require__(127),
	        __webpack_require__(121),
	        __webpack_require__(125),
	        __webpack_require__(128),
	        __webpack_require__(129),
	        __webpack_require__(130),
	        __webpack_require__(131)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	        BrowserInfo,
	        domEvents,
	        playPauseStates,
	        muteStates,
	        fullscreenStates,
	        playPauseControl,
	        muteControl,
	        volumeControl,
	        fullscreenControl,
	        timeControl
	    ) {
	        'use strict';

	        function create (playerDivId, emitter, audioPlayer) {
	            var player = document.getElementById(playerDivId);
	            var controlsId = 'controls-' + playerDivId;
	            var controls = document.createElement('div');
	            var mobileTimeout = 0;
	            var items = {
	                'playPauseControl'  : undefined,
	                'muteControl'       : undefined,
	                'volumeControl'     : undefined,
	                'fullscreenControl' : undefined,
	                'timeControl'       : undefined
	            };
	            function show () {
	                controls && (controls.style.visibility = 'visible');
	            }
	            function hide () {
	                controls && (controls.style.visibility = 'hidden');
	            }
	            function add () {
	                if (!document.getElementById(controlsId)) {
	                    controls.id = controlsId;
	                    controls.style.width = '100%';
	                    controls.style.height =
	                        (audioPlayer ? '100' : Math.round(!BrowserInfo.mobile ? 100 / 12 : 100 / 6)) + '%';
	                    controls.style.maxHeight = player.clientWidth / 8 + 'px';
	                    controls.style.position = 'absolute';
	                    controls.style.left = '0';
	                    controls.style.bottom = '0';
	                    controls.style.zIndex = 2352346258378;
	                    controls.style.backgroundColor = audioPlayer ? 'white' : 'rgba(255,255,255,0.7)';
	                    !audioPlayer && hide();
	                    player.appendChild(controls);
	                    //controls.style.height = controls.clientHeight + 'px';
	                    items.timeControl = timeControl.create(controls, emitter);
	                    items.playPauseControl = playPauseControl.create(controls, emitter);
	                    items.muteControl = muteControl.create(controls, emitter, audioPlayer);
	                    items.volumeControl = volumeControl.create(controls, emitter, audioPlayer);
	                    !audioPlayer && (items.fullscreenControl = fullscreenControl.create(controls, emitter));
	                    !audioPlayer && player.addEventListener(domEvents.MOUSE_MOVE, onMouseMove, true);
	                }
	            }
	            function focus () {
	                controls.style.zIndex = 2352346258378;
	            }
	            function size () {
	                controls.style.width = '100%';
	                var landscape = Math.round(!BrowserInfo.mobile ? player.clientHeight / 12 : player.clientHeight / 6);
	                var portrait = Math.round(!BrowserInfo.mobile ? controls.clientWidth / 12 : controls.clientWidth / 8);
	                controls.style.height = (audioPlayer ? '100' : Math.min(landscape, portrait)) + 'px';
	                controls.style.maxHeight = player.clientWidth / 8 + 'px';
	                for (var item in items) {
	                    items[item].update && items[item].update();
	                }
	            }
	            function onMouseMove (e) {
	                if (e.button && e.button !== 0) return;
	                if (e.target.id && e.target.id.indexOf('playButton-') !== -1) return;
	                appear();
	            }
	            function appear () {
	                mobileTimeout && clearTimeout(mobileTimeout);
	                mobileTimeout = 0;
	                mobileTimeout = setTimeout(hide, 5000);
	                show();
	            }
	            function play () {
	                items.playPauseControl.update(playPauseStates.PLAY);
	            }
	            function pause () {
	                items.playPauseControl.update(playPauseStates.PAUSE);
	            }
	            function fullscreen (enable) {
	                if (audioPlayer) return;
	                focus();
	                if (enable) {
	                    items.fullscreenControl.update(fullscreenStates.ENTERED);
	                }
	                else {
	                    items.fullscreenControl.update(fullscreenStates.EXITED);
	                }
	            }
	            function mute () {
	                items.muteControl.update(muteStates.MUTED);
	            }
	            function unmute () {
	                items.muteControl.update(muteStates.UNMUTED);
	            }
	            function volume (volume) {
	                items.volumeControl.update(volume);
	            }
	            function time (time) {
	                items.timeControl.update(time);
	            }
	            function destroy () {
	                mobileTimeout && clearTimeout(mobileTimeout);
	                for (var item in items) {
	                    typeof items[item] !== 'undefined' && items[item].destroy();
	                    delete items[item];
	                }
	                audioPlayer && player.removeEventListener(domEvents.MOUSE_MOVE, onMouseMove);
	                player.removeChild(controls);
	                controls = null;
	                player = null;
	                return null;
	            }
	            add();
	            return {
	                'size'       : size,
	                'appear'     : appear,
	                'show'       : show,
	                'hide'       : hide,
	                'play'       : play,
	                'pause'      : pause,
	                'fullscreen' : fullscreen,
	                'mute'       : mute,
	                'unmute'     : unmute,
	                'volume'     : volume,
	                'time'       : time,
	                'destroy'    : destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(104), __webpack_require__(107), __webpack_require__(126)], __WEBPACK_AMD_DEFINE_RESULT__ = function (BrowserInfo, domEvents, controlEvents, playPauseStates) {
	        'use strict';

	        function create (controls, emitter) {
	            var canvas = document.createElement('canvas'),
	                playPauseState = playPauseStates.PLAY;
	            var playpause = {
	                'id'  : 'playpause-' + controls.id,
	                'ctx' : canvas.getContext('2d')
	            };
	            canvas.id = playpause.id;
	            canvas.style.left = 0;
	            canvas.style.position = 'absolute';
	            canvas.addEventListener(BrowserInfo.mobile ? domEvents.TOUCH_END : domEvents.MOUSE_UP, click);
	            controls.appendChild(canvas);
	            function progress () {
	                playpause.ctx && playpause.ctx.clearRect(0, 0, canvas.width, canvas.height);
	                canvas.width = canvas.height = controls.clientHeight;
	                canvas.style.left = 0;
	                var length = canvas.width;
	                var points = {
	                    'l20' : f(length * 0.2),
	                    'l30' : f(length * 0.3),
	                    'l45' : f(length * 0.45),
	                    'l50' : f(length * 0.5),
	                    'l55' : f(length * 0.55),
	                    'l70' : f(length * 0.7),
	                    'l75' : f(length * 0.75),
	                    'l80' : f(length * 0.8)
	                };
	                if (playPauseState === playPauseStates.PLAY) {
	                    playpause.ctx.beginPath();
	                    playpause.ctx.fillStyle = 'rgba(0,0,0,1)';
	                    playpause.ctx.moveTo(points.l30, points.l20);
	                    playpause.ctx.lineTo(points.l30, points.l80);
	                    playpause.ctx.lineTo(points.l75, points.l50);
	                    playpause.ctx.fill();
	                }
	                else if (playPauseState === playPauseStates.PAUSE) {
	                    playpause.ctx.beginPath();
	                    playpause.ctx.fillStyle = 'rgba(0,0,0,1)';
	                    playpause.ctx.moveTo(points.l30, points.l20);
	                    playpause.ctx.lineTo(points.l30, points.l80);
	                    playpause.ctx.lineTo(points.l45, points.l80);
	                    playpause.ctx.lineTo(points.l45, points.l20);
	                    playpause.ctx.moveTo(points.l55, points.l20);
	                    playpause.ctx.lineTo(points.l55, points.l80);
	                    playpause.ctx.lineTo(points.l70, points.l80);
	                    playpause.ctx.lineTo(points.l70, points.l20);
	                    playpause.ctx.fill();
	                }
	            }
	            function f (x) {
	                return Math.floor(x);
	            }
	            function update (state) {
	                state && (playPauseState = state);
	                progress();
	            }
	            function destroy () {
	                playpause.ctx && playpause.ctx.clearRect(0, 0, canvas.width, canvas.height);
	                controls.removeChild(canvas);
	                canvas = null;
	            }
	            function click (e) {
	                if (playPauseState === playPauseStates.PLAY) {
	                    emitter.emit(controlEvents.PLAY);
	                }
	                else if (playPauseState === playPauseStates.PAUSE) {
	                    emitter.emit(controlEvents.PAUSE);
	                }
	            }
	            progress();
	            return {
	                'update'  : update,
	                'destroy' : destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'PLAY'  : 'play',
	        'PAUSE' : 'pause'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return Object.freeze({
	        'MUTED'   : 'muted',
	        'UNMUTED' : 'unmuted'
	    });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(104), __webpack_require__(107), __webpack_require__(127)], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    BrowserInfo,
	    domEvents,
	    controlEvents,
	    muteStates
	) {
	    'use strict';

	    function create (controls, emitter, audioPlayer) {
	        var canvas = document.createElement('canvas'),
	            muteState = muteStates.UNMUTED,
	            length,
	            x,
	            y,
	            radius,
	            startAngle,
	            endAngle,
	            counterClockwise = false;
	        var mute = {
	            'id'  : 'mute-' + controls.id,
	            'ctx' : canvas.getContext('2d')
	        };
	        var rightFactor = +!audioPlayer + 3;
	        canvas.id = mute.id;
	        canvas.style.right = controls.clientHeight * rightFactor + 'px';
	        canvas.style.position = 'absolute';
	        canvas.addEventListener(BrowserInfo.mobile ? domEvents.TOUCH_END : domEvents.MOUSE_UP, click);
	        controls.appendChild(canvas);
	        function progress () {
	            mute.ctx && mute.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            canvas.width = canvas.height = controls.clientHeight;
	            canvas.style.right = controls.clientHeight * rightFactor + 'px';
	            var length = canvas.width;
	            var points = {
	                'l175' : r(length * 0.175),
	                'l20'  : r(length * 0.2),
	                'l30'  : r(length * 0.3),
	                'l37'  : r(length * 0.37),
	                'l50'  : r(length * 0.5),
	                'l63'  : r(length * 0.63),
	                'l825' : r(length * 0.825)
	            };
	            mute.ctx.beginPath();
	            mute.ctx.fillStyle = 'rgba(0,0,0,1)';
	            mute.ctx.strokeStyle = 'rgba(0,0,0,1)';
	            mute.ctx.lineJoin = 'round';
	            mute.ctx.moveTo(points.l20, points.l37);
	            mute.ctx.lineTo(points.l20, points.l63);
	            mute.ctx.lineTo(points.l30, points.l63);
	            mute.ctx.lineTo(points.l50, points.l825);
	            mute.ctx.lineTo(points.l50, points.l175);
	            mute.ctx.lineTo(points.l30, points.l37);
	            mute.ctx.fill();
	            mute.ctx.lineWidth = r(length * 0.1);
	            mute.ctx.lineCap = 'round';
	            if (muteState === muteStates.MUTED) {
	                mute.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
	            }
	            x = y = canvas.width / 2;
	            radius = length * 0.3;
	            startAngle = 1.6 * Math.PI;
	            endAngle = 0.4 * Math.PI;
	            mute.ctx.beginPath();
	            mute.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);
	            mute.ctx.stroke();
	            radius = length * 0.15;
	            startAngle = 1.7 * Math.PI;
	            endAngle = 0.3 * Math.PI;
	            mute.ctx.beginPath();
	            mute.ctx.arc(x, y, radius, startAngle, endAngle, counterClockwise);
	            mute.ctx.stroke();
	        }
	        function r (x) {
	            return Math.round(x);
	        }
	        function update (state) {
	            state && (muteState = state);
	            progress();
	        }
	        function destroy () {
	            mute.ctx && mute.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            controls.removeChild(canvas);
	            canvas = null;
	        }
	        function click (e) {
	            if (muteState === muteStates.MUTED) {
	                emitter.emit(controlEvents.UNMUTE);
	            }
	            else if (muteState === muteStates.UNMUTED) {
	                emitter.emit(controlEvents.MUTE);
	            }
	        }
	        progress();
	        return {
	            'update'  : update,
	            'destroy' : destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(104), __webpack_require__(107), __webpack_require__(127)], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    BrowserInfo,
	    domEvents,
	    controlEvents,
	    muteStates
	) {
	    'use strict';

	    function create (controls, emitter, audioPlayer) {
	        var canvas = document.createElement('canvas'),
	            width,
	            height,
	            startX,
	            startY,
	            fullX,
	            fullY,
	            volumeX,
	            volumeY,
	            leftOffset = 0.1,
	            topOffset = 0.15;
	        var volume = {
	            'id'    : 'volume-' + controls.id,
	            'ctx'   : canvas.getContext('2d'),
	            'value' : 1
	        };
	        var rightFactor = +!audioPlayer;
	        canvas.id = volume.id;
	        canvas.style.right = controls.clientHeight * rightFactor + 'px';
	        canvas.style.position = 'absolute';
	        canvas.style.display = 'block';
	        canvas.addEventListener(BrowserInfo.mobile ? domEvents.TOUCH_END : domEvents.MOUSE_UP, click);
	        controls.appendChild(canvas);
	        function progress () {
	            volume.ctx && volume.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            canvas.height = controls.clientHeight;
	            canvas.style.right = controls.clientHeight * rightFactor + 'px';
	            canvas.width = canvas.height * 3;
	            width = canvas.width;
	            height = canvas.height;
	            volume.ctx.beginPath();
	            volume.ctx.strokeStyle = 'rgba(0,0,0,1)';
	            volume.ctx.lineJoin = 'round';
	            startX = r(width * leftOffset);
	            startY = r(height * (1 - topOffset));
	            fullX = r(width * (1 - leftOffset));
	            fullY = r(height * topOffset);
	            volume.ctx.moveTo(startX, startY);
	            volume.ctx.lineTo(fullX, startY);
	            volume.ctx.lineTo(fullX, fullY);
	            volume.ctx.fillStyle = 'rgba(0,0,0,0.2)';
	            volume.ctx.fill();
	            if (volume.value) {
	                volume.ctx.closePath();
	                volume.ctx.beginPath();
	                volumeX = r(startX + volume.value * (fullX - startX));
	                volumeY = r(startY - volume.value * (startY - fullY));
	                volume.ctx.moveTo(startX, startY);
	                volume.ctx.lineTo(volumeX, startY);
	                volume.ctx.lineTo(volumeX, volumeY);
	                volume.ctx.fillStyle = 'rgba(0,0,0,1)';
	                volume.ctx.fill();
	            }
	        }
	        function r (x) {
	            return Math.round(x);
	        }
	        function update (vol) {
	            vol && (volume.value = vol);
	            progress();
	        }
	        function destroy () {
	            volume.ctx && volume.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            controls.removeChild(canvas);
	            canvas = null;
	        }
	        function click (e) {
	            var target = e.target || e.srcElement,
	                style = target.currentStyle || window.getComputedStyle(target, null),
	                borderLeftWidth = parseInt(style.borderLeftWidth, 10),
	                borderTopWidth = parseInt(style.borderTopWidth, 10),
	                rect = target.getBoundingClientRect(),
	                touch =
	                    e.changedTouches && e.changedTouches.length
	                        ? e.changedTouches[0]
	                        : e.touches && e.touches.length
	                            ? e.touches[0]
	                            : {
	                                'clientX' : rect.left,
	                                'clientY' : rect.top
	                            },
	                offSetX = (e.clientX ? e.clientX : touch.clientX) - borderLeftWidth - rect.left,
	                offSetY = (e.clientY ? e.clientY : touch.clientY) - borderTopWidth - rect.top;
	            var x = 0;
	            if (offSetX > startX && offSetX < fullX) {
	                x = (offSetX - startX) / (fullX - startX);
	            }
	            else if (offSetX > fullX) {
	                x = 1;
	            }
	            var vol = Math.round(100 * x) / 100;
	            emitter.emit(controlEvents.VOLUME_CHANGE, { 'volume': vol });
	        }
	        progress();
	        return {
	            'update'  : update,
	            'destroy' : destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(104), __webpack_require__(107), __webpack_require__(121)], __WEBPACK_AMD_DEFINE_RESULT__ = function (BrowserInfo, domEvents, controlEvents, fullscreenStates) {
	        'use strict';

	        function create (controls, emitter) {
	            var canvas = document.createElement('canvas'),
	                fullscreenState = fullscreenStates.EXITED,
	                length,
	                x,
	                y,
	                radius,
	                startAngle,
	                endAngle,
	                counterClockwise = false;
	            var fullscreen = {
	                'id'  : 'fullscreen-' + controls.id,
	                'ctx' : canvas.getContext('2d')
	            };
	            canvas.id = fullscreen.id;
	            canvas.style.right = 0;
	            canvas.style.position = 'absolute';
	            canvas.addEventListener(BrowserInfo.mobile ? domEvents.TOUCH_END : domEvents.MOUSE_UP, click);
	            controls.appendChild(canvas);
	            function progress () {
	                fullscreen.ctx && fullscreen.ctx.clearRect(0, 0, canvas.width, canvas.height);
	                canvas.width = canvas.height = controls.clientHeight;
	                canvas.style.right = 0;
	                var length = canvas.width;
	                var points = {
	                    'l20' : f(length * 0.2),
	                    'l35' : f(length * 0.35),
	                    'l65' : f(length * 0.65),
	                    'l80' : f(length * 0.8)
	                };
	                fullscreen.ctx.beginPath();
	                fullscreen.ctx.strokeStyle = 'rgba(0,0,0,1)';
	                fullscreen.ctx.lineCap = 'round';
	                fullscreen.ctx.lineWidth = r(length * 0.1);
	                if (fullscreenState === fullscreenStates.ENTERED) {
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l20, points.l35);
	                    fullscreen.ctx.lineTo(points.l35, points.l35);
	                    fullscreen.ctx.lineTo(points.l35, points.l20);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l65, points.l20);
	                    fullscreen.ctx.lineTo(points.l65, points.l35);
	                    fullscreen.ctx.lineTo(points.l80, points.l35);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l80, points.l65);
	                    fullscreen.ctx.lineTo(points.l65, points.l65);
	                    fullscreen.ctx.lineTo(points.l65, points.l80);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l35, points.l80);
	                    fullscreen.ctx.lineTo(points.l35, points.l65);
	                    fullscreen.ctx.lineTo(points.l20, points.l65);
	                    fullscreen.ctx.stroke();
	                }
	                else if (fullscreenState === fullscreenStates.EXITED) {
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l20, points.l35);
	                    fullscreen.ctx.lineTo(points.l20, points.l20);
	                    fullscreen.ctx.lineTo(points.l35, points.l20);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l65, points.l20);
	                    fullscreen.ctx.lineTo(points.l80, points.l20);
	                    fullscreen.ctx.lineTo(points.l80, points.l35);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l80, points.l65);
	                    fullscreen.ctx.lineTo(points.l80, points.l80);
	                    fullscreen.ctx.lineTo(points.l65, points.l80);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.beginPath();
	                    fullscreen.ctx.moveTo(points.l35, points.l80);
	                    fullscreen.ctx.lineTo(points.l20, points.l80);
	                    fullscreen.ctx.lineTo(points.l20, points.l65);
	                    fullscreen.ctx.stroke();
	                    fullscreen.ctx.stroke();
	                }
	            }
	            function f (x) {
	                return Math.floor(x) + 0.5;
	            }
	            function r (x) {
	                return Math.round(x);
	            }
	            function update (state) {
	                state && (fullscreenState = state);
	                progress();
	            }
	            function destroy () {
	                fullscreen.ctx && fullscreen.ctx.clearRect(0, 0, canvas.width, canvas.height);
	                controls.removeChild(canvas);
	                canvas = null;
	            }
	            function click (e) {
	                if (fullscreenState === fullscreenStates.EXITED) {
	                    emitter.emit(controlEvents.FULLSCREEN_ENTER);
	                }
	                else if (fullscreenState === fullscreenStates.ENTERED) {
	                    emitter.emit(controlEvents.FULLSCREEN_EXIT);
	                }
	            }
	            progress();
	            return {
	                'update'  : update,
	                'destroy' : destroy
	            };
	        }

	        return {
	            'create': create
	        };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    function create (controls, emitter) {
	        var canvas = document.createElement('canvas'),
	            currentTime = '0:00';
	        var time = {
	            'id'  : 'time-' + controls.id,
	            'ctx' : canvas.getContext('2d')
	        };
	        canvas.id = time.id;
	        canvas.style.left = controls.clientHeight * 1 + 'px';
	        canvas.style.position = 'absolute';
	        controls.appendChild(canvas);
	        function progress () {
	            time.ctx && time.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            var height = (canvas.height = controls.clientHeight);
	            canvas.style.left = controls.clientHeight * 1 + 'px';
	            var width = (canvas.width = canvas.height * 3);
	            time.ctx.textAlign = 'left';
	            time.ctx.textBaseline = 'middle';
	            time.ctx.font = 'bold ' + r(height * 0.6) + 'px "Arial"';
	            time.ctx.fillStyle = 'rgba(0,0,0,1)';
	            try {
	                time.ctx.fillText(currentTime, r(width * 0.1), r(height * 0.5));
	            }
	            catch (ex) {}
	        }
	        function r (x) {
	            return Math.round(x);
	        }
	        function format (seconds) {
	            var hours = Math.floor(seconds / 3600);
	            var minutes = Math.floor((seconds - hours * 3600) / 60);
	            var seconds = Math.floor(seconds - hours * 3600 - minutes * 60);
	            var time = '';
	            if (hours != 0) {
	                time = hours + ':';
	            }
	            minutes = minutes < 10 && time !== '' ? '0' + minutes : String(minutes);
	            time += minutes + ':';
	            time += seconds < 10 ? '0' + seconds : String(seconds);
	            return time;
	        }
	        function update (time) {
	            time && (currentTime = format(time));
	            progress();
	        }
	        function destroy () {
	            time.ctx && time.ctx.clearRect(0, 0, canvas.width, canvas.height);
	            controls.removeChild(canvas);
	            canvas = null;
	        }
	        progress();
	        return {
	            'update'  : update,
	            'destroy' : destroy
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	nanoStream Player
	(c) 2016, nanocosmos gmbh
	http://www.nanocosmos.de
	sales@nanocosmos.de

	LEGAL NOTICE:
	This material is subject to the terms and conditions defined in
	separate license conditions ('LICENSE.txt')
	All information contained herein is, and remains the property
	of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
	contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
	or copyright law. Dissemination of this information or reproduction of this material
	is strictly forbidden unless prior written permission is obtained from nanocosmos.
	All modifications will remain property of nanocosmos.
	*/

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(133), __webpack_require__(134), __webpack_require__(135)], __WEBPACK_AMD_DEFINE_RESULT__ = function (
	    emptyConfig,
	    Bintu,
	    BintuStreamFilter
	) {
	    'use strict';

	    function setup (config) {
	        var bintu;
	        return new Promise(function (resolve, reject) {
	            if (config.source.bintu) {
	                if (!config.source.bintu.apiurl) {
	                    config.source.bintu.apiurl = 'https://bintu.nanocosmos.de';
	                }
	                if (!config.source.bintu.streamid) {
	                    reject(Error('No bintu streamid passed'));
	                }
	                bintu = new Bintu(config.source.bintu.apiurl, null, null, 'player');
	                bintu.getStream(
	                    config.source.bintu.streamid,
	                    function success (request) {
	                        try {
	                            var response = JSON.parse(request.responseText);
	                            var id = response.id;
	                            var state = response.state;
	                            var playout = response.playout;
	                            var rtmp = playout.rtmp;
	                            var hls = playout.hls;
	                            var h5live = playout.h5live;
	                            if ((rtmp && !rtmp.length && !h5live) || (h5live && !h5live.length)) {
	                                reject(Error('Could not find stream. The stream is not live.'));
	                            }
	                            else {
	                                if (hls && hls.length) {
	                                    var hlsurl = hls[0].url;
	                                    config.source.hls = hlsurl;
	                                }
	                                if (h5live && h5live.length) {
	                                    config.source.h5live = config.source.h5live || {};
	                                    if (!config.source.h5live.server && (config.source.h5live.server = {})) {
	                                        for (var key in h5live[0].server) {
	                                            if (h5live[0].server.hasOwnProperty(key)) {
	                                                config.source.h5live.server[key] = h5live[0].server[key].replace(
	                                                    'bintu-stream',
	                                                    'bintu-h5live'
	                                                );
	                                            }
	                                        }
	                                    }
	                                    config.source.h5live.rtmp = {};
	                                    config.source.h5live.rtmp.url = h5live[0].rtmp.url;
	                                    config.source.h5live.rtmp.streamname = h5live[0].rtmp.streamname;
	                                }
	                                else if (rtmp && rtmp.length) {
	                                    config.source.h5live = config.source.h5live || {};
	                                    config.source.h5live.rtmp = {};
	                                    config.source.h5live.rtmp.url = h5live[0].rtmp.url;
	                                    config.source.h5live.rtmp.streamname = h5live[0].rtmp.streamname;
	                                }
	                            }
	                            resolve(config);
	                        }
	                        catch (err) {
	                            var message = err.message || 'unknown error';
	                            reject(Error(message));
	                        }
	                    },
	                    function error (err) {
	                        var message = err.error || 'unknown error';
	                        message += ' - ' + err.request.responseText;
	                        reject(Error(message));
	                    }
	                );
	            }
	            else {
	                resolve(config);
	            }
	        });
	    }

	    return {
	        'setup'       : setup,
	        'emptyConfig' : emptyConfig
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by nandor.kostyo on 2016-09-26.
	 */
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    function create () {
	        return {
	            'source': {
	                'bintu': {
	                    'apiurl'   : '',
	                    'streamid' : ''
	                }
	            }
	        };
	    }

	    return {
	        'create': create
	    };
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	 * http://www.nanocosmos.de
	 * Bintu Release Version 0.5
	 */

	/**
	 * @file Bintu Streaming API Class.
	 * @author nanocosmos IT GmbH
	 * @copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	 * @version 0.5
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    /**
	     * Bintu Streaming API.
	     * @class Bintu
	     * @classdesc Bintu Streaming API Class Version 0.5.
	     * @constructor
	     * @param {string} apiUrl - The base url to the Bintu API.
	     * @param {string} [apiKey] - The apikey to use with Bintu API.
	     * @param {string} [playerKey] - The playerkey to use with Bintu API.
	     * @param {string} [keyMode] - The keymode to use with Bintu API.
	     * @example Javascript
	     * var apiKey = 'dfg5490htk64jzep0zhdhdthjkhp69zuk';
	     * var apiUrl = 'https://bintu.nanocosmos.de';
	     * var bintu = new Bintu(apiKey, apiUrl);
	     */
	    var Bintu = function (apiUrl, apiKey, playerKey, keyMode) {
	        if (!(apiUrl.length > 0 && (typeof apiUrl === 'string' || apiUrl instanceof String))) {
	            throw new Error('The param \'apiUrl\' must be of type \'string\' and also may not be empty string.');
	            return;
	        }
	        else {
	            this.apiUrl = apiUrl;
	        }
	        if (!!apiKey && (typeof apiKey === 'string' || apiKey instanceof String)) {
	            this.apiKey = apiKey;
	        }
	        if (!!playerKey && (typeof playerKey === 'string' || playerKey instanceof String)) {
	            this.playerKey = playerKey;
	        }
	        if (!!keyMode && (typeof keyMode === 'string' || keyMode instanceof String)) {
	            if (keyMode === 'api' || keyMode === 'player') {
	                this.keyMode = keyMode;
	            }
	            else {
	                throw new Error('The param \'keyMode\' must be \'api\', \'player\' or undefined');
	                return;
	            }
	        }
	    };

	    /**
	     * The callback for a successful Bintu call
	     * @callback successCallback
	     * @see [Bintu]{@link Bintu}
	     * @param {XMLHttpRequest} request - The XMLHttpRequest with the response.
	     * @example
	     * function successCallback(request) {
	     *     var response = request.responseText;
	     *     try {
	     *         response = JSON.parse(response);
	     *         console.log(response);
	     *     } catch (err) {
	     *         console.error('error parsing json response: ' + err.message);
	     *     }
	     * }
	     */

	    /**
	     * The callback for a failed Bintu call
	     * @callback errorCallback
	     * @see [Bintu]{@link Bintu}
	     * @param {object} error - The error object.
	     * @param {string} error.error - The error cause.
	     * @param {XMLHttpRequest} error.request - The XMLHttpRequest with the response.
	     * @example
	     * function errorCallback(error) {
	     *     var errorCause = error.error;
	     *     console.log('error: ' + errorCause);
	     *     var response = error.request.responseText;
	     *     try {
	     *         response = JSON.parse(response);
	     *         console.log(response);
	     *     } catch (err) {
	     *         console.error('error parsing json response: ' + err.message);
	     *     }
	     * }
	     */

	    /**
	     * @typedef {object} stream
	     * @description A Bintu stream object returned in the response from a successful 'Bintu.createStream', 'Bintu.getStream' or 'Bintu.tagStream' request as JSON formatted string.
	     * @see [Bintu]{@link Bintu}
	     * @property {string}  id - The id of the stream.
	     * @property {string}  state - The state of the stream.
	     * @property {string}  type - The type of the stream.
	     * @property {string}  created_at - The time of creation.
	     * @property {string[]}  tags - The related tags of the stream.
	     * @property {object}  ingest - The ingest object.
	     * @property {object}  ingest.rtmp - This rtmp object of the ingest object.
	     * @property {string}  ingest.rtmp.url - The base rtmp ingest url.
	     * @property {string}  ingest.rtmp.streamname - The name of the rtmp stream.
	     * @property {object}  playout - The playout object.
	     * @property {object}  playout.rtmp - This rtmp object of the playout object.
	     * @property {string}  playout.rtmp.url - The base rtmp ingest url.
	     * @property {string}  playout.rtmp.streamname - This state represents the object null.
	     * @property {string}  playout.rtmp.type - The type of the rtmp playout.
	     * @property {object}  playout.hls - This hls object of the playout object.
	     * @property {string}  playout.hls.url - The url to the hls playout.
	     * @property {string}  playout.hls.type - The type of the hls playout.
	     * @property {object}  playout.web - This state represents the object null.
	     * @property {string}  playout.web.url - The url to the web playout.
	     * @property {string}  playout.web.type - The type of the web playout.
	     * @example
	     * {
	     *    "id":"5f86a12f-3801-415a-b450-6b6a46842349",
	     *    "state":"created",
	     *    "type":"wowza",
	     *    "created_at":"2016-04-25T11:51:05.200Z",
	     *    "tags":[
	     *       "webrtc"
	     *    ],
	     *    "ingest":{
	     *       "rtmp":{
	     *          "url":"rtmp://bintu-stream.nanocosmos.de:80/live",
	     *          "streamname":"hrzcqQ_58r"
	     *       }
	     *    },
	     *    "playout":{
	     *       "rtmp":[
	     *          {
	     *             "url":"rtmp://cdn-live.nanocosmos.de:1935/71026777.rtmp",
	     *             "streamname":"hrzcqQ_58r",
	     *             "type":"live"
	     *          }
	     *       ],
	     *       "hls":[
	     *          {
	     *             "url":"http://cdn-live.nanocosmos.de:80/71026777.http/hrzcqQ_58r/playlist.m3u8",
	     *             "type":"live"
	     *          }
	     *       ],
	     *       "web":[
	     *          {
	     *             "url":"https://bintu.nanocosmos.de:443/playout/5f86a12f-3801-415a-b450-6b6a46842349",
	     *             "type":"live"
	     *          }
	     *       ]
	     *    }
	     * }
	     */

	    /**
	     * @typedef {stream[]} streams
	     * @description An array of Bintu [stream]{@link stream} objects returned in the response from a successful 'Bintu.getStreams' request as JSON formatted string.
	     * @see [Bintu]{@link Bintu}
	     */

	    var proto = Bintu.prototype;

	    var Request = function (method, url, header, async, success, error) {
	        var self = this;
	        self.method = method || 'GET';
	        self.url = url || 'http://localhost:8088';
	        self.header = header || {};
	        self.async = async || true;
	        self.onSuccess = success || function (request) {};
	        self.onError = error || function (request) {};
	        self.Send = function (data) {
	            var request = new XMLHttpRequest();
	            request.open(self.method, self.url, self.async);
	            for (var a in self.header) {
	                request.setRequestHeader(a, self.header[a]);
	            }
	            request.onreadystatechange = function () {
	                if (request.readyState === 4 && request.status === 200) {
	                    'function' === typeof self.onSuccess && self.onSuccess(request);
	                }
	                else if (request.readyState === 4 && request.status !== 200) {
	                    'function' === typeof self.onError &&
	                        self.onError({
	                            'error'   : 'onstatuserror',
	                            'request' : request
	                        });
	                }
	            };
	            request.onabort = function () {
	                'function' === typeof self.onError &&
	                    self.onError({
	                        'error'   : 'onabort',
	                        'request' : request
	                    });
	            };
	            request.onerror = function () {
	                'function' === typeof self.onError &&
	                    self.onError({
	                        'error'   : 'onerror',
	                        'request' : request
	                    });
	            };
	            request.ontimeout = function () {
	                'function' === typeof self.onError &&
	                    self.onError({
	                        'error'   : 'ontimeout',
	                        'request' : request
	                    });
	            };
	            if (typeof data !== 'undefined') {
	                if (typeof data === 'string') {
	                    try {
	                        data = JSON.parse(data);
	                    }
	                    catch (e) {
	                        data = null;
	                        'function' === typeof self.onError &&
	                            self.onError({
	                                'error'   : 'invalid json string',
	                                'request' : request
	                            });
	                    }
	                }
	                if (typeof data === 'object') {
	                    try {
	                        data = JSON.stringify(data);
	                        request.send(data);
	                    }
	                    catch (e) {
	                        'function' === typeof self.onError &&
	                            self.onError({
	                                'error'   : 'invalid json object',
	                                'request' : request
	                            });
	                    }
	                }
	            }
	            else {
	                request.send();
	            }
	        };
	    };

	    /**
	     * @alias apiKey
	     * @memberOf Bintu#
	     * @description The apikey to use with Bintu API.
	     * @type {string}
	     * @example
	     * // bintu instance of Bintu class
	     * bintu.apiKey = 'sdfg896wgp8j28guq3tkmoakjfaest0kj89';
	     * console.log(bintu.apiKey);
	     */
	    proto.apiKey = null;

	    /**
	     * @alias apiUrl
	     * @memberOf Bintu#
	     * @description The base url to the Bintu API.
	     * @type {string}
	     * @example
	     * // bintu instance of Bintu class
	     * bintu.apiUrl = 'https://bintu2.nanocosmos.de';
	     * console.log(bintu.apiUrl);
	     */
	    proto.apiUrl = null;

	    /**
	     * @alias playerKey
	     * @memberOf Bintu#
	     * @description The playerkey to use with Bintu API.
	     * @type {string}
	     * @example
	     * // bintu instance of Bintu class
	     * bintu.playerKey = 'serzghqar3ehztdolguipt546we454';
	     * console.log(bintu.playerKey);
	     */
	    proto.playerKey = null;

	    /**
	     * @alias keyMode
	     * @memberOf Bintu#
	     * @description Defines which key should be used.
	     * @type {string}
	     * @example
	     * // bintu instance of Bintu class
	     * bintu.keyMode = 'player';
	     * console.log(bintu.keyMode);
	     * @default
	     */
	    proto.keyMode = 'api';

	    /**
	     * @alias createStream
	     * @memberOf Bintu#
	     * @description Creates a new Bintu stream.
	     * @param {string[]} [tags] - The array of tags as strings.
	     * @param {successCallback} [success] - The success callback with the request passed.
	     * @param {errorCallback} [error] - The error callback with the request passed.
	     * @example
	     * // bintu instance of Bintu class
	     * var tags = ['myTag', 'title:This is a title', 'doc'];
	     * bintu.createStream(tags,
	     *     function success(request) {
	     *         try {
	     *             var response = JSON.parse(request.responseText);
	     *             var id = response.id;
	     *             console.log('success - new stream created with id:' + id);
	     *             var state = response.state;
	     *             var ingest = response.ingest;
	     *             var rtmp = ingest.rtmp;
	     *             var url = rtmp.url;
	     *             var streamname = rtmp.streamname;
	     *             console.log('created with state: ' + state);
	     *             console.log('rtmp ingest: ' + url + "/" + streamname);
	     *         } catch (err) {
	     *             console.error(err);
	     *         }
	     *     }, function error(e) {
	     *         var error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *         console.error(error);
	     *         try {
	     *             error = (typeof e.error !== 'undefined') ? e.error : '';
	     *             var response = JSON.parse(e.request.responseText);
	     *             alert('error while creating new bintu stream (' + error + '): status=' + response.status + ', message=' + response.message, 1);
	     *         } catch (ex) {
	     *             error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *             alert(error);
	     *         }
	     *     });
	     */
	    proto.createStream = function (tags, success, error) {
	        if (!this.apiUrl) {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api url set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (!this.apiKey) {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api key set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (this.keyMode !== 'api') {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'wrong key mode set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        var request = new Request('POST', this.apiUrl + '/stream');
	        request.header = {
	            'Accept'         : 'application/json',
	            'Content-Type'   : 'application/json',
	            'X-BINTU-APIKEY' : this.apiKey
	        };
	        request.onSuccess = success;
	        request.onError = error;
	        if (
	            typeof tags === 'object' &&
	            typeof tags.push === 'function' &&
	            tags.length > 0 &&
	            (typeof tags[0] === 'string' || tags[0] instanceof String)
	        ) {
	            request.Send({ 'tags': tags });
	        }
	        else {
	            request.Send();
	        }
	    };

	    /**
	     * @alias getStream
	     * @memberOf Bintu#
	     * @description Returns a Bintu stream specified by a stream id.
	     * @param {string} streamId - The streamId of the Bintu Stream.
	     * @param {successCallback} [success] - The success callback with the request passed.
	     * @param {errorCallback} [error] - The error callback with the request passed.
	     * @example
	     * // bintu instance of Bintu class
	     * var streamId = 'regwerghsthe6uwj57ikek6ugjghjf';
	     * bintu.getStream(streamId,
	     *     function success(request) {
	     *         try {
	     *             var response = JSON.parse(request.responseText);
	     *             var id = response.id;
	     *             console.log('success - get stream with id: ' + id);
	     *             var state = response.state;
	     *             var ingest = response.ingest;
	     *             var rtmp = ingest.rtmp;
	     *             var url = rtmp.url;
	     *             var streamname = rtmp.streamname;
	     *             console.log('state: ' + state);
	     *             console.log('rtmp ingest: ' + url + "/" + streamname);
	     *         } catch (err) {
	     *             console.error(err);
	     *         }
	     *     }, function error(e) {
	     *         var error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *         console.error(error);
	     *         try {
	     *             error = (typeof e.error !== 'undefined') ? e.error : '';
	     *             var response = JSON.parse(e.request.responseText);
	     *             alert('error while getting bintu stream (' + error + '): status=' + response.status + ', message=' + response.message, 1);
	     *         } catch (ex) {
	     *             error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *             alert(error);
	     *         }
	     *     });
	     */
	    proto.getStream = function (streamId, success, error) {
	        if (!this.apiUrl) {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api url set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (!this.apiKey && this.keyMode === 'api') {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api key set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        var request = new Request('GET', this.apiUrl + '/stream/' + streamId);
	        request.header =
	            this.keyMode === 'api' && this.apiKey
	                ? {
	                    'Accept'         : 'application/json',
	                    'Content-Type'   : 'application/json',
	                    'X-BINTU-APIKEY' : this.apiKey
	                }
	                : {
	                    'Accept'       : 'application/json',
	                    'Content-Type' : 'application/json; charset=utf-8'
	                };
	        request.onSuccess = success;
	        request.onError = error;
	        request.Send();
	    };

	    /**
	     * @alias getStreams
	     * @memberOf Bintu#
	     * @description Returns one or many Bintu streams optional filtered by related tags and/or state.
	     * @param {BintuStreamFilter} [filter] - The filter for the search.
	     * @param {successCallback} [success] - The success callback with the request passed.
	     * @param {errorCallback} [error] - The error callback with the request passed.
	     * @example
	     * // bintu instance of Bintu class
	     * var streamFilter = new BintuStreamFilter();
	     * var state = BintuStreamFilter.STATE.LIVE;
	     * var tags = ['myTag', 'doc'];
	     * streamFilter.setState(state);
	     * streamFilter.addTags(tags);
	     * streamFilter.addTag('title:This is a title');
	     * bintu.getStreams(streamFilter,
	     *     function success(request) {
	     *         var response = request.responseText;
	     *         try {
	     *             response = JSON.parse(response);
	     *             console.log('success - get streams');
	     *         } catch (err) {
	     *             response = [];
	     *             console.error(err);
	     *         }
	     *         var i, len;
	     *         for (i = 0, len = response.length; i < len; i += 1) {
	     *             var state = response[i].state;
	     *             var streamId = response[i].id;
	     *             console.log('found stream with id: ' + streamId);
	     *             var url = response[i].playout.rtmp[0].url + '/' + response[i].playout.rtmp[0].streamname;
	     *             console.log('rtmp playout: ' + url);
	     *             var tags = response[i].tags;
	     *             var message = "";
	     *             if (tags && tags.push) {
	     *                 var j, tLen;
	     *                 for (j = 0, tLen = tags.length; j < tLen; j += 1) {
	     *                     if (j === 0)
	     *                         message += 'tags: ';
	     *                     message += tags[j];
	     *                     if (j !== tLen - 1)
	     *                         message += ',';
	     *                 }
	     *             }
	     *             console.log(message);
	     *         }
	     *         if (len === 0) {
	     *             console.log('no stream found with the given search parameters');
	     *         }
	     *     },
	     *     function error(e) {
	     *         var error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *         console.error(error);
	     *         try {
	     *             error = (typeof e.error !== 'undefined') ? e.error : '';
	     *             var response = JSON.parse(e.request.responseText);
	     *             alert('error while getting bintu streams (' + error + '): status=' + response.status + ', message=' + response.message, 1);
	     *         } catch (ex) {
	     *             error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *             alert(error);
	     *         }
	     *     });
	     */
	    proto.getStreams = function (filter, success, error) {
	        if (!this.apiUrl) {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api url set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (!this.apiKey && this.keyMode === 'api') {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api key set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (!this.playerKey && this.keyMode === 'player') {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no player key set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        var request = new Request('GET', this.apiUrl + '/stream/' + streamId);
	        var url = this.apiUrl + '/stream';
	        if (filter instanceof BintuStreamFilter) {
	            if (filter.tags.length === 0 && this.keyMode === 'player') {
	                return (
	                    'function' === typeof error &&
	                    error({
	                        'error'   : 'no tags set',
	                        'request' : { 'responseText': 'no response error' }
	                    })
	                );
	            }
	            url += filter.getQueryString();
	        }
	        var request = new Request('GET', url);
	        request.header =
	            this.keyMode === 'api'
	                ? {
	                    'Accept'         : 'application/json',
	                    'Content-Type'   : 'application/json',
	                    'X-BINTU-APIKEY' : this.apiKey
	                }
	                : {
	                    'Accept'            : 'application/json',
	                    'Content-Type'      : 'application/json',
	                    'X-BINTU-PLAYERKEY' : this.playerKey
	                };
	        request.onSuccess = success;
	        request.onError = error;
	        request.Send();
	    };

	    /**
	     * @alias tagStream
	     * @memberOf Bintu#
	     * @description Tags an existing Bintu streams by overwriting.
	     * @param {string} streamId - The streamId of the Bintu Stream.
	     * @param {string[]} tags - The tags as an array of string related to streams.
	     * @param {successCallback} [success] - The success callback with the request passed.
	     * @param {errorCallback} [error] - The error callback with the request passed.
	     * @example
	     * // bintu instance of Bintu class
	     * var streamId = '23w45rt8t3wtgjpsp9054wawegf34590g4w';
	     * var tags = ['newTag, test, webrtc'];
	     * bintu.tagStream(streamId, tags,
	     *     function success(request) {
	     *         var response = request.responseText;
	     *         try {
	     *             response = JSON.parse(response);
	     *             var id = response.id;
	     *             console.log('success - tag stream with id: ' + id)
	     *             var tags = response.tags;
	     *             var message = "";
	     *             if (tags && tags.push) {
	     *                 var j, tLen;
	     *                 for (j = 0, tLen = tags.length; j < tLen; j += 1) {
	     *                     if (j === 0)
	     *                         message += 'new tags: ';
	     *                     message += tags[j];
	     *                     if (j !== tLen - 1)
	     *                         message += ',';
	     *                 }
	     *             }
	     *             console.log(message);
	     *         } catch (err) {
	     *             console.error(err);
	     *         }
	     *     },
	     *     function error(e) {
	     *         var error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *         console.error(error);
	     *         try {
	     *             error = (typeof e.error !== 'undefined') ? e.error : '';
	     *             var response = JSON.parse(e.request.responseText);
	     *             alert('error while tagging bintu streams (' + error + '): status=' + response.status + ', message=' + response.message, 1);
	     *         } catch (ex) {
	     *             error = (typeof e.error !== 'undefined') ? e.error + ': ' + e.request.responseText : 'error: ' + e.request.responseText;
	     *             alert(error);
	     *         }
	     *     });
	     */
	    proto.tagStream = function (streamId, tags, success, error) {
	        if (!this.apiUrl) {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api url set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (!this.apiKey) {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'no api key set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        else if (this.keyMode !== 'api') {
	            return (
	                'function' === typeof error &&
	                error({
	                    'error'   : 'wrong key mode set',
	                    'request' : { 'responseText': 'no response error' }
	                })
	            );
	        }
	        if (!streamId) {
	            return 'function' === typeof error && error({ 'error': 'no stream id set' });
	        }
	        var request = new Request('PUT', this.apiUrl + '/stream/' + streamId + '/tag');
	        request.header = {
	            'Accept'         : 'application/json',
	            'Content-Type'   : 'application/json',
	            'X-BINTU-APIKEY' : this.apiKey
	        };
	        request.onSuccess = success;
	        request.onError = error;
	        if (
	            typeof tags === 'object' &&
	            typeof tags.push === 'function' &&
	            tags.length > 0 &&
	            (typeof tags[0] === 'string' || tags[0] instanceof String)
	        ) {
	            request.Send({ 'tags': tags });
	        }
	        else {
	            request.Send();
	        }
	    };

	    return Bintu;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	 * http://www.nanocosmos.de
	 * Bintu Release Version 0.5
	 */

	/**
	 * @file Bintu Stream Filter Class.
	 * @author nanocosmos IT GmbH
	 * @copyright (c) 2016 nanocosmos IT GmbH. All rights reserved.
	 * @version 0.5
	 */

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    'use strict';

	    /**
	     * Bintu Stream Filter for Bintu Streaming API.
	     * @class BintuStreamFilter
	     * @classdesc Bintu Stream Filter Class Version 0.4 for Bintu Streaming API Class.
	     * @example
	     * var streamFilter = new BintuStreamFilter();
	     */
	    function BintuStreamFilter () {
	        /**
	         * @alias state
	         * @memberOf BintuStreamFilter#
	         * @description The state of the Bintu Streams to filter.
	         * @type {BintuStreamFilter.STATE}
	         * @default BintuStreamFilter.STATE.ALL
	         */
	        this.state = this.setState(BintuStreamFilter.STATE.ALL);

	        /**
	         * @alias tags
	         * @memberOf BintuStreamFilter#
	         * @description The array of tags of the Bintu Streams to filter.
	         * @type {string[]}
	         */
	        this.tags = [];
	    }

	    var proto = BintuStreamFilter.prototype;

	    /**
	     * @alias STATE
	     * @memberOf BintuStreamFilter
	     * @readonly
	     * @static
	     * @description Bintu Stream States.
	     * @property {string}  LIVE - This state represents the string 'live'.
	     * @property {string}  CREATED - This state represents the string 'created'.
	     * @property {string}  ENDED - This state represents the string 'ended'.
	     * @property {null}  ALL - This state represents the object null.
	     */
	    BintuStreamFilter.STATE = Object.create({
	        'LIVE'    : 'live',
	        'CREATED' : 'created',
	        'ENDED'   : 'ended',
	        'ALL'     : null
	    });

	    /**
	     * @alias setState
	     * @memberOf BintuStreamFilter#
	     * @description Sets the state for the filter.
	     * @param {BintuStreamFilter.STATE} state - The state of the Bintu Streams to filter.
	     * @returns {BintuStreamFilter} The instance of the BintuStreamFilter
	     * @example
	     * // streamFilter instance of BintuStreamFilter
	     * var state = BintuStreamFilter.STATE.LIVE;
	     * streamFilter.setState(state);
	     */
	    proto.setState = function (state) {
	        var newState = undefined;
	        for (var s in BintuStreamFilter.STATE) {
	            if (BintuStreamFilter.STATE[s] === state) newState = BintuStreamFilter.STATE[s];
	        }
	        if (typeof newState === 'undefined') {
	            throw new Error('The param \'state\' must be of type \'BintuStreamFilter.STATE\'');
	            return;
	        }
	        this.state = newState;
	        return this;
	    };

	    /**
	     * @alias addTag
	     * @memberOf BintuStreamFilter#
	     * @description Adds a tag to the filter.
	     * @param {string} tag - The tag of the Bintu Streams to filter.
	     * @returns {BintuStreamFilter} The instance of the BintuStreamFilter
	     * @example
	     * // streamFilter instance of BintuStreamFilter
	     * var tag = 'myTag';
	     * streamFilter.addTag(tag);
	     * console.log(streamFilter.tags); // prints 'myTag'
	     * streamFilter.addTag('otherTag');
	     * console.log(streamFilter.tags); // prints 'myTag, otherTag'
	     * streamFilter.addTag('myTag');
	     * console.log(streamFilter.tags); // prints 'myTag, otherTag'
	     */
	    proto.addTag = function (tag) {
	        if (!(tag.length > 0 && (typeof tag === 'string' || tag instanceof String))) {
	            throw new Error('The param \'tag\' must be of type \'string\' and also may not be empty string.');
	            return;
	        }
	        this.tags.push(tag);
	        this.tags = this._reduceDuplicates(this.tags);
	        return this;
	    };

	    /**
	     * @alias addTags
	     * @memberOf BintuStreamFilter#
	     * @description Adds tags to the filter.
	     * @param {string[]} tags - The tags of the Bintu Streams to filter.
	     * @returns {BintuStreamFilter} The instance of the BintuStreamFilter
	     * @example
	     * // streamFilter instance of BintuStreamFilter
	     * var tags = ['myTag', 'otherTag'];
	     * streamFilter.addTags(tags);
	     * console.log(streamFilter.tags); // prints 'myTag, otherTag'
	     * tags = ['newTag', 'otherTag'];
	     * streamFilter.addTags(tags);
	     * console.log(streamFilter.tags); // prints 'myTag, newTag, otherTag'
	     */
	    proto.addTags = function (tags) {
	        if (
	            !(
	                typeof tags === 'object' &&
	                typeof tags.push === 'function' &&
	                (tags.length === 0 || (tags.length > 0 && (typeof tags[0] === 'string' || tags[0] instanceof String)))
	            )
	        ) {
	            throw new Error('The param \'tags\' must be of type \'string array\'');
	            return;
	        }
	        this.tags = this.tags.concat(tags);
	        this.tags = this._reduceDuplicates(this.tags);
	        return this;
	    };

	    /**
	     * @alias getQueryString
	     * @memberOf BintuStreamFilter#
	     * @description Returns the query string for the search that can be added to the url of the GET request.
	     * @returns {string} The query string
	     * @example
	     * // streamFilter instance of BintuStreamFilter
	     * streamFilter.addTags(['myTag', 'otherTag']);
	     * streamFilter.addTag('newTag');
	     * streamFilter.setState(BintuStreamFilter.STATE.LIVE);
	     * var queryString = streamFilter.getQueryString();
	     * console.log(queryString); // prints '?tags[]=myTag&tags[]=newTag&tags[]=otherTag&state=live'
	     */
	    proto.getQueryString = function () {
	        var queryString = '';
	        if (typeof this.tags === 'object' && typeof this.tags.push === 'function' && this.tags.length > 0) {
	            for (var i = 0; i < this.tags.length; i += 1) {
	                if (typeof this.tags[i] !== 'string') continue;
	                queryString += i === 0 ? '?' : '&';
	                queryString += 'tags[]=' + this.tags[i];
	            }
	        }
	        if (typeof this.state === 'string' && this.state.length > 0) {
	            queryString += queryString.indexOf('?') === -1 ? '?' : '&';
	            queryString += 'state=' + this.state;
	        }
	        return queryString;
	    };

	    /**
	     * @private
	     * @alias _reduceDuplicates
	     * @member
	     * @description Delete duplicated tags.
	     * @param {string[]} tags - The tags of the Bintu Streams to filter.
	     * @returns {string[]} The reduced tags
	     */
	    proto._reduceDuplicates = function (tags) {
	        if (
	            !(
	                typeof tags === 'object' &&
	                typeof tags.push === 'function' &&
	                (tags.length === 0 || (tags.length > 0 && (typeof tags[0] === 'string' || tags[0] instanceof String)))
	            )
	        ) {
	            throw new Error('The param \'tags\' must be of type \'string array\'');
	            return;
	        }
	        return tags.reduce(function (a, b) {
	            if (a.indexOf(b) < 0) a.push(b);
	            return a;
	        }, []);
	    };

	    return BintuStreamFilter;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })
/******/ ]);
